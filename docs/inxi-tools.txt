================================================================================
INXI TOOLS
================================================================================
FILE:    inxi-tools.txt
VERSION: 1.0
DATE:    2018-02-16

----------------------------------------
Docs:
See: docs/inxi-values.txt
See: docs/optimization.txt

----------------------------------------
Code: 
See:

----------------------------------------
Comments:

This constitues the essential internal 'api' of inxi, and is a reference 
document for programming inxi.

================================================================================

Sections:
1. CORE TOOLS
2. SPECIFIC TOOLS

================================================================================
CORE TOOLS
--------------------------------------------------------------------------------

These are the tools you'd use in working on features of inxi. That is, don't
reinvent the wheel, if a tool is already done, then use it. Most tools feature 
logging when the debugger logging flag is set, which is useful to seeing 
execution times and flows, as well as what was passed to the tools.

========================================
AWK
----------------------------------------

Emulates to some degree how awk works, pass it:

Duplicates the functionality of awk to allow for one liner
type data parsing. note: -1 corresponds to awk NF
args:
1: array of data; 
2: search term; 
3: field result - this is integer, starting at 1, not 0
4: separator - optional

correpsonds to: awk -F='separator' '/search/ {print $2}' <<< @data
array is sent by reference so it must be dereferenced
NOTE: if you just want the first row, pass it \S as search string
NOTE: if $num is undefined, it will skip the second step

----------------------------------------
  CODE
----------------------------------------

$value = main::awk(\@data,'something',3);

========================================
CHECK PROGRAM
----------------------------------------

arg: 
1 - string or path to search gneerated @paths data for.

note: a few nano seconds are saved by using raw $_[0] for program

Returns full path in system, which can then be sent to program_version 
to save that step in looking for it. When program_version receives a file
name starting with /, it assumes it's a valid path and uses that.

----------------------------------------
  CODE
----------------------------------------

$path = main::check_program('lspci');

========================================
COUNT DIR FILES
----------------------------------------

Args:
1. Directory

returns count of files in directory, if 0, dir is empty

----------------------------------------
  CODE
----------------------------------------

$count = main::count_dir_files('/sys');

========================================
GET PIECE
----------------------------------------

args: 
1 - the string to get piece of
2 - the position in string, starting at 1 for 0 index.
3 - the separator, default is ' '

----------------------------------------
  CODE
----------------------------------------

$result = main::get_piece($string,3,"\n");

========================================
GRABBER
----------------------------------------

args: 
1 - command to turn into an array; 
2 - optional: splitter - default: \n
3 - optional, strip and clean data, remove leading trailing whitespace etc

Similar to reader() except this creates an array of data 
by lines from the command arg

----------------------------------------
  CODE
----------------------------------------

@content = main::grabber('lspci -knn',"\n",'strip');

========================================
GLOBBER
----------------------------------------

args: 
1 - string value to glob

Note: returns full path per result.

----------------------------------------
  CODE
----------------------------------------

@files = main::globber('/sys/*/*');

========================================
JOINER
----------------------------------------

args:
1 - array to join, by ref. NOTE: a reference of an undefined array is NOT undefined!
2 - separator for join action
3 - default value, return this if array is unset or undefined

Gets array ref, which may be undefined, plus join string
This helps avoid debugger print errors when we are printing arrays
which we don't know are defined or not null.

Tests to see if array is unset. Array is passed by reference.

----------------------------------------
  CODE
----------------------------------------

$string = main::joiner(\@data,'; ', 'unset');

========================================
PROGRAM VALUES
----------------------------------------

Returns array of:
0 - match string; 
1 - search number; 
2 - version string; 
3 - Print name
4 - console 0/1; 
5 - 0/1 exit version loop at first iteration

args: 
1 - program lower case name

----------------------------------------
  CODE
----------------------------------------

@data = main::program_values('blackbox');

========================================
PROGRAM VERSION
----------------------------------------

args: 
1 - desktop/app command for --version; 
2 - search string; 
3 - space print number; 
4 - [optional] version arg: -v, version, etc

NOTE: if you used check_program, it returns full path, so program_version
doesn't need to search for the path again.

This runs the variant of --version that applies, checks stderr if output
goes there, which it does for some programs and applications. See logic
for specifics. --version data going to stderr is more common than you might
think!

----------------------------------------
  CODE
----------------------------------------

$version = main::program_version($path,'^nano',3);

========================================
READER
----------------------------------------

arg: 
1 - full file path, returns array of file lines.
2 - optionsl, strip and clean data

Note: chomp has to chomp the entire action, not just <$fh>
That's inside this sub routine, not something you do.

Returns array of lines of output.

----------------------------------------
  CODE
----------------------------------------

@data = main::reader($path,'strip');

========================================
TOUCHER
----------------------------------------

args: 
1 - the file to create if not exists

Failure is handled by main::error_handler(), and will terminate script execution.

This may require changing in full production pinxi, we'll see, but technically, 
the user who runs pinxi should be running with their user permissions, so the files
should be writable always in their $HOME data.

----------------------------------------
  CODE
----------------------------------------

main::toucher($file_path);

========================================
TRIMMER
----------------------------------------

Calling it trimmer to avoid conflicts with existing trim stuff in Perl.

args:
1 - string to be right left trimmed. Also slices off \n so no chomp needed

This thing is super fast, no need to log its times etc, 0.0001 seconds or less

Receives string, returns trimmed string.

----------------------------------------
  CODE
----------------------------------------

$string = main::trimmer($string);

========================================
UNIQ
----------------------------------------

Just like shell uniq, returns unique items only.

args:
1 - array to return only unique elements of

Send array, assign to hash, return array, uniq values only.

----------------------------------------
  CODE
----------------------------------------

@data = main::uniq(@data);

========================================
WRITER
----------------------------------------

args: 
1 - file full  path to write to; 
2 - array of data to write. 

Note: turning off strict refs so we can pass it a scalar or an array reference.
That's only done within the scope of writer()

----------------------------------------
  CODE
----------------------------------------

main::writer($full_path, @data);

================================================================================
SPECIFIC TOOLS
--------------------------------------------------------------------------------

These tools are specialized and will only be used under very specific
circumstances.

========================================

----------------------------------------



----------------------------------------
  CODE
----------------------------------------

========================================

----------------------------------------



----------------------------------------
  CODE
----------------------------------------

========================================

----------------------------------------



----------------------------------------
  CODE
----------------------------------------
