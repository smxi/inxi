#!/bin/bash
########################################################################
####  Script Name: inxi
####  version: 0.4.17
####  Date: November 8 2008
########################################################################
####  inxi is a fork of infobash, the original bash sys info script by locsmif
####  As time permits functionality improvements and recoding will occur.
####
####  inxi, the universal, portable, system info script for irc.
####  Tested with Irssi, Xchat, Konversation, BitchX, KSirc, ircII,
####  Gaim/Pidgin, Weechat, KVIrc and Kopete.
####  Original infobash author and copyright holder:
####  Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif <infobash@rebelhomicide.demon.nl>
####  inxi version: Copyright (C) 2008 Warren Scott Rogers & Harald Hope
####
####  Current script home page: http://techpatterns.com/forums/about1131.html
####  Script svn: http://code.google.com/p/inxi
####
####  This program is free software; you can redistribute it and/or modify
####  it under the terms of the GNU General Public License as published by
####  the Free Software Foundation; either version 3 of the License, or
####  (at your option) any later version.
####
####  This program is distributed in the hope that it will be useful,
####  but WITHOUT ANY WARRANTY; without even the implied warranty of
####  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
####  GNU General Public License for more details.
####
####  You should have received a copy of the GNU General Public License
####  along with this program.  If not, see <http://www.gnu.org/licenses/>.

####  DEPENDENCIES
####  bash >=2.05b(bash), df;readlink;stty;tr;uname;wc(coreutils),
####  gawk(gawk), grep(grep), hostname(hostname), lspci(pciutils),
####  ps;uptime(procps), runlevel(sysvinit), glxinfo;xdpyinfo;xrandr(xbase-clients)
####  Also the proc filesystem should be present and mounted
########################################################################
#### VARIABLES
########################################################################

## NOTE: we can use hwinfo if it's available in all systems, or most, to get
## a lot more data and verbosity levels going

### Variable initializations: null values
CMDL_MAX=''
COLOR_SCHEME=''
COLOR_SCHEME_SET=''
IRC_CLIENT=''
IRC_CLIENT_VERSION=''

### primary data array holders
A_AUDIO_DATA=''
A_CMDL=''
A_CPU_CORE_DATA=''
A_CPU_DATA=''
A_GFX_CARD_DATA=''
A_GLX_DATA=''
A_HDD_DATA=''
A_NETWORK_DATA=''
A_PARTITION_DATA=''
A_X_DATA=''

### Boolean true/false globals
# check to make sure initial steps run without error for debugging
# inxi hasn't been 'booted' yet.
B_ALL_UP='false'
# triggers full display of cpu flags
B_CPU_FLAGS_FULL='false'
# Debug flood override: make 'true' to allow long debug output
B_DEBUG_FLOOD='false'
# show extra output data
B_EXTRA_DATA='false'
# override certain errors due to currupted data
B_HANDLE_CORRUPT_DATA='false'
# Running in a shell? Defaults to false, and is determined later.
B_RUNNING_IN_SHELL='false'
# Set this to 'false' to avoid printing the hostname
B_SHOW_HOST='true'
# Show sound card data
B_SHOW_SOUND='false'
# triggers various debugging and new option testing
B_TESTING_FLAG='false'
# Test for X running
B_X_RUNNING='false'
if [[ -n $DISPLAY ]];then
	B_X_RUNNING='true'
fi

### Variable initializations: constants
DCOPOBJ="default"
DEBUG=0 # Set debug levels from 1-10
# Debug Buffer Index, index into a debug buffer storing debug messages until inxi is 'all up'
DEBUG_BUFFER_INDEX=0
### Reroute all error messages to the bitbucket (if not debugging)
if [[ $DEBUG -eq 0 ]]
then
	exec 2>/dev/null
fi
#((DEBUG)) && exec 2>&1 # This is for debugging konversation

# Defaults to 2, make this 1 for normal, 0 for no colorcodes at all. Set to any other valid scheme you like.
# Same as runtime parameter.
DEFAULT_SCHEME=2
# Default indentation level
INDENT=10
# default to false, no konversation found, 1 is /cmd inxi start, 2 is native konvi script mode
KONVI=0
# NO_CPU_COUNT=0	# Wether or not the string "dual" or similar is found in cpuinfo output. If so, avoid dups.
# This is a variable that controls how many parameters inxi will parse in a /proc/<pid>/cmdline file before stopping.
PARAMETER_LIMIT=30
SCHEME=0 # set default scheme
# SHOW_IRC=1 to avoid showing the irc client version number, or SHOW_IRC=0 to disable client information completely.
SHOW_IRC=2
# Verbosity level defaults to 0, this can also be set with -v0, -v2, -v3, etc as a parameter.
VERBOSITY_LEVEL=0
# Supported number of verbosity levels, including 0
VERBOSITY_LEVELS=5

# Clear nullglob, because it creates unpredictable situations with IFS=$'\n' ARR=($VAR) IFS="$ORIGINAL_IFS"
# type constructs. Stuff like [rev a1] is now seen as a glob expansion pattern, and fails, and
# therefore results in nothing. Tricky as fuck.
shopt -u nullglob
## info on bash built in: $IFS - http://tldp.org/LDP/abs/html/internalvariables.html
# Backup the current Internal Field Separator
ORIGINAL_IFS="$IFS"
# These two determine separators in single line output, to force irc clients not to break off sections
FL1='-'
FL2=''

### Script names/paths
SCRIPT_NAME="inxi"
SCRIPT_PATH=$( dirname $0 )
SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | gawk '{print $3}' )
KONVI_CFG="konversation/scripts/$SCRIPT_NAME.conf" # relative path to $(kde-config --path data)

### Script Localization
# Make sure every program speaks English.
LC_ALL="C"
export LC_ALL

### Output Colors
# A more elegant way to have a scheme that doesn't print color codes (neither ANSI nor mIRC) at all. See below.
unset EMPTY
#         DGREY    BLACK    RED      DRED     GREEN    DGREEN   YELLOW   DYELLOW
ANSI_COLORS="[1;30m [0;30m [1;31m [0;31m [1;32m [0;32m [1;33m [0;33m"
IRC_COLORS="   \x0314   \x0301   \x0304   \x0305   \x0309   \x0303   \x0308   \x0307"
#                 BLUE     DBLUE    MAGENTA  DMAGENTA CYAN     DCYAN    WHITE    GREY     NORMAL
ANSI_COLORS="$ANSI_COLORS [1;34m [0;34m [1;35m [0;35m [1;36m [0;36m [1;37m [0;37m [0;37m"
IRC_COLORS=" $IRC_COLORS    \x0312   \x0302   \x0313   \x0306   \x0311   \x0310   \x0300   \x0315   \x03"
#ANSI_COLORS=($ANSI_COLORS); IRC_COLORS=($IRC_COLORS)
A_COLORS_AVAILABLE=( DGREY BLACK RED DRED GREEN DGREEN YELLOW DYELLOW BLUE DBLUE MAGENTA DMAGENTA CYAN DCYAN WHITE GREY NORMAL )
# See above for notes on EMPTY
A_COLOR_SCHEMES=( EMPTY,EMPTY,EMPTY NORMAL,NORMAL,NORMAL BLUE,NORMAL,NORMAL GREEN,YELLOW,NORMAL DYELLOW,NORMAL,NORMAL CYAN,BLUE,NORMAL RED,NORMAL,NORMAL GREEN,NORMAL,NORMAL YELLOW,NORMAL,NORMAL GREEN,DGREEN,NORMAL BLUE,RED,NORMAL BLUE,NORMAL,RED YELLOW,WHITE,GREEN BLUE,NORMAL,GREEN DCYAN,NORMAL,DMAGENTA )
## Actual color variables
C1=''
C2=''
CN=''

### Distro Data
# In cases of derived distros where the version file of the base distro can also be found under /etc,
# the derived distro's version file should go first. (Such as with Sabayon / Gentoo)
DISTROS_DERIVED="antix-version kanotix-version knoppix-version redhat-release sabayon-release sidux-version turbolinux-release zenwalk-version"
# debian_version excluded from DISTROS_PRIMARY so Debian can fall through to /etc/issue detection. Same goes for Ubuntu.
DISTROS_EXCLUDE_LIST="debian_version ubuntu_version"
DISTROS_PRIMARY="gentoo-release mandrake-release redhat-release slackware-version SuSE-release"

### Bans Data
# Precede a banword with $'\2' to prevent it from being subject to automated escaping by the make_ban_lists routine
# $'\1' gets weird results :
# user@host $ ARR=($'\x01'"one two" three four); echo ${ARR[0]} | hd -v
# 00000000  01 01 6f 6e 65 20 74 77  6f 0a                    |..one two.|
A_NORMAL_BANS=( corporation communications gmbh technologies technology group $'\2'"\<ltd\>" ltd. $'\2'"\<inc\>" inc. $'\2'\<co\> co. "(tm)" "(r)" $'\2'"\(rev ..\)" )
A_CPU_BANS=( @ cpu deca 'dual core' 'tri core' 'quad core' ennea genuine hepta hexa multi octa penta 'processor' processor single triple $'\2'"[0-9.]+ *[MmGg][Hh][Zz]" )
# after processing, the ban arrays will be put into these:
BAN_LIST_NORMAL=''
BAN_LIST_CPU=''

### Source global config overrides
if [[ -s /etc/$SCRIPT_NAME.conf ]];then
	source /etc/$SCRIPT_NAME.conf
fi
# Source user config overrides
if [[ -s $HOME/.$SCRIPT_NAME ]];then
	source $HOME/.$SCRIPT_NAME
fi

# WARNING: In the main part below (search for 'KONVI')
# there's a check for Konversation-specific config files.
# Any one of these can override the above if inxi is run
# from Konversation!

########################################################################
#### UTILITY FUNCTIONS
########################################################################

#### -------------------------------------------------------------------
#### error handler and debugger
#### -------------------------------------------------------------------

# Error handling
# args: $1 - error number; $2 - optional, extra information
error_handler()
{
	local error_message=''

	# assemble the error message
	case $1 in
		2)	error_message="large flood danger, debug buffer full!"
			;;
		3)	error_message="unsupported color scheme number: $2"
			;;
		4)	error_message="unsupported verbosity level: $2"
			;;
		5)	error_message="dependency not met: $2 not found in path"
			;;
		6)	error_message="/proc not found! Quitting..."
			;;
		7)	error_message="unsupported script parameter: $2\nFor supported options, check the help menu: $SCRIPT_NAME -h"
			;;
		8)	error_message="the self-updater failed, wget exited with error: $2.\nYou probably need to be root.\nHint, to make for easy updates without being root, do: chown <user name> $SCRIPT_PATH/$SCRIPT_NAME"
			;;
		*)	error_message="error unknown: $@"
			set -- 99
			;;
	esac
	# then print it and exit
	print_screen_output "$SCRIPT_NAME: $error_message"
	exit $1
}

script_debugger()
{
	local a_debug_buffer=''

	if [[ $B_ALL_UP == 'true' ]];then
		if [[ $DEBUG -eq 0 ]];then
			return
		fi
		if [[ $DEBUG_BUFFER_INDEX -gt 0 ]];then
			for (( DEBUG_BUFFER_INDEX=0; DEBUG_BUFFER_INDEX < ${#a_debug_buffer[@]}; DEBUG_BUFFER_INDEX++ ))
			do
				print_screen_output "${a_debug_buffer[DEBUG_BUFFER_INDEX]}"
			done
			DEBUG_BUFFER_INDEX=0
		fi
		print_screen_output "$@"
	else
		if [[ $B_DEBUG_FLOOD == 'true' && $DEBUG_BUFFER_INDEX -gt 10 ]];then
			error_handler 2
		fi
		a_debug_buffer[DEBUG_BUFFER_INDEX++]="$@"
	fi
}

#### -------------------------------------------------------------------
#### print / output cleaners
#### -------------------------------------------------------------------

# inxi speaks through here. When run by Konversation, uses DCOP
# note, this is a huge bug trap, for now we're not using this at all except to
# output basic stuff. At some point in the future we'll debug the dcop stuff,
# but that only works if inxi is being run as a konversation script to begin with
print_screen_output()
{
	if [[ $DEBUG -gt 5 ]];then
		if [[ $KONVI -eq 1 ]];then
			dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "konvi='$KONVI'  saying : '$@'"
		else
			echo "konvi='$KONVI'  saying : '$@'"
		fi
		#echo "konvi='$KONVI'  saying : '$@'"
		#((KONVI)) && dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "konvi='$KONVI'  saying : '$@'" || echo "konvi='$KONVI'  saying : '$@'"
	fi
	#((KONVI)) && dcop $DCPORT Konversation print_screen_output $DCSERVER "$DCTARGET" "$1" || echo -ne "$1\n"

	if [[ $KONVI -eq 1 ]];then
		dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "$1"
	else
		echo -ne "$1\n"
	fi
	#((KONVI)) && dcop "$DCPORT" "$DCOPOBJ" print_screen_output "$DCSERVER" "$DCTARGET" "$1" || echo -ne "$1\n"
	# echo -ne "$1\n"
}

## this handles all verbose line construction with indentation/line starter
## args: $1 - null (, actually: " ") or line starter; $2 - line content
create_print_line()
{
	printf "${C1}%-${INDENT}s${C2} %s" "$1" "$2"
}

# this removes newline and pipes.
# args: $1 - string to clean
remove_erroneous_chars()
{
	## RS is input record separator
	## gsub is substitute;
	gawk '
	BEGIN { RS="" } {
		gsub(/\n$/,"")         ## (newline; end of string) with (nothing)
		gsub(/\n/," ");        ## (newline) with (space)
		gsub(/^ *| *$/, "")    ## (pipe char) with (nothing)
		gsub(/  +/, " ")       ## ( +) with (space)
		gsub(/ [ ]+/, " ")     ## ([ ]+) with (space)
		gsub(/^ +| +$/, "")    ## (pipe char) with (nothing)
		printf $0
	}' "$1"      ## prints (returns) cleaned input
}

## note: this is now running inside each gawk sequence directly to avoid exiting gawk
## looping in bash through arrays, then re-entering gawk to clean up, then writing back to array
## in bash. For now I'll leave this here because there's still some interesting stuff to get re methods
# Enforce boilerplate and buzzword filters
# args: $1 - BAN_LIST_NORMAL/BAN_LIST_CPU; $2 - string to sanitize
sanitize_characters()
{
	# Cannot use strong quotes to unquote a string with pipes in it!
	# bash will interpret the |'s as usual and try to run a subshell!
	# Using weak quotes instead, or use '"..."'
	echo "$2" | gawk "
	BEGIN { IGNORECASE=1 } {
		gsub(/${!1}/,\"\")
		gsub(/ [ ]+/,\" \")    ## ([ ]+) with (space)
		gsub(/^ +| +$/,\"\")   ## (pipe char) with (nothing)
		print                  ## prints (returns) cleaned input
	}"
}

#### -------------------------------------------------------------------
#### basic tests
#### -------------------------------------------------------------------

# Determine if any of the absolutely necessary tools are absent
check_script_depends()
{
	local app_name='' app_data=''

	if [[ ! -d /proc/ ]];then
		error_handler 6
	fi

	if [[ $B_X_RUNNING == 'true' ]];then
		for app_name in xrandr xdpyinfo glxinfo
		do
			app_data=$( type -p $app_name )
			if [[ -z $app_data ]];then
				script_debugger "inxi: Resuming in non X mode: $app_name not found in path"
				B_X_RUNNING='false'
				break
			fi
		done
	fi

	app_name=''
	# bc removed from deps for now
	for app_name in df free gawk grep hostname lspci ps readlink runlevel tr uname uptime wc
	do
		app_data=$( type -p $app_name )
		if [[ -z $app_data ]];then
			error_handler 5 "$app_name"
		fi
	done
}

# Filter boilerplate & buzzwords.
# args: $1 - quoted: "$@" array of ban terms
make_ban_lists()
{
	local ban_list=''
	# Iterate over $@
	## note: this is a weird, non-intuitive method, needs some documentation or rewriting
	## if you declare ban_string it stops working, have to read up on this
	for ban_string
	do
		# echo "term=\"$ban_string\"" # >&2
		if [[ ${ban_string:0:1} = $'\2' ]];then
			ban_list="${ban_list}${ban_list+|}${ban_string:1:${#ban_string}-1}"
		else
			# Automatically escapes [ ] ( ) . and +
			ban_list="${ban_list}${ban_list+|}$( echo "$ban_string" | gawk '{
				gsub(/([\[\]+().])/,"\\\\&")
				print
			}' )"
		fi
	done

	echo "$ban_list"
}
# make_ban_lists "${A_CPU_BANS[@]}";exit

# Set the colorscheme
# args: $1 = <scheme number>|<"none">
set_color_scheme()
{
	local i='' script_colors='' color_codes=''

	if [[ $1 -ge ${#A_COLOR_SCHEMES[@]} ]];then
		set -- 1
	fi
	SCHEME="$1" # Set a global variable to allow checking for chosen scheme later
	if [[ $B_RUNNING_IN_SHELL == 'true' ]];then
		color_codes=( $ANSI_COLORS )
	else
		color_codes=( $IRC_COLORS )
	fi
	for (( i=0; i < ${#A_COLORS_AVAILABLE[@]}; i++ ))
	do
		eval "${A_COLORS_AVAILABLE[i]}=\"${color_codes[i]}\""
	done
	IFS=","
	script_colors=( ${A_COLOR_SCHEMES[$1]} )
	IFS="$ORIGINAL_IFS"
	C1="${!script_colors[0]}"
	C2="${!script_colors[1]}"
	CN="${!script_colors[2]}"
	# ((COLOR_SCHEME++)) ## note: why is this? ##
}

# Parse the null separated commandline under /proc/<pid passed in $1>/cmdline
# args: $1 - $PPID
get_cmdline()
{
	local i=0 ppid=$1

	if [[ ! -e /proc/$ppid/cmdline ]];then
		echo 0
		return
	fi
	##print_screen_output "Marker"
	##print_screen_output "\$ppid='$ppid' -=- $(< /proc/$ppid/cmdline)"
	unset A_CMDL
	## note: need to figure this one out, and ideally clean it up and make it readable
	while read -d $'\0' L && [ "$i" -lt 32 ]
	do
		A_CMDL[i++]="$L" ## note: make sure this is valid - What does L mean? ##
	done </proc/$ppid/cmdline
	##print_screen_output "\$i='$i'"
	if [[ $i -eq 0 ]];then
		A_CMDL[0]=$(< /proc/$ppid/cmdline)
		if [[ -n ${A_CMDL[0]} ]];then
			i=1
		fi
	fi
	CMDL_MAX=$i
}

# Get the parameters. Note: standard options should be lower case, advanced or testing, upper
# args: $1 - full script startup args: $@
get_parameters()
{
	local opt=''

	if [[ -z $1 ]];then
		return 1
	fi

	while getopts c:CdDfFhsTUv:Vx opt
	do
		case $opt in
		c)	if [[ -n $( egrep '^[0-9][0-9]?$' <<< $OPTARG ) ]];then
				COLOR_SCHEME_SET='true'
				## note: not sure about this, you'd think user values should be overridden, but
				## we'll leave this for now
				if [[ -z $COLOR_SCHEME ]];then
					set_color_scheme "$OPTARG"
				fi
			else
				error_handler 3 "$OPTARG"
			fi
			;;
		C)	B_HANDLE_CORRUPT_DATA='true'
			;;
		d)	VERBOSITY_LEVEL=1
			;;
		D)	DEBUG=1
			exec 2>&1
			;;
		f)	B_CPU_FLAGS_FULL='true'
			;;
		F)	VERBOSITY_LEVEL=$VERBOSITY_LEVELS
			B_CPU_FLAGS_FULL='true'
			B_SHOW_SOUND='true'
			B_EXTRA_DATA='true'
			;;
		s)	B_SHOW_SOUND='true'
			;;
		T)	B_TESTING_FLAG='true'
			;;
		v)	if [[ -n $( egrep "^[0-9][0-9]?$" <<< $OPTARG ) && $OPTARG -le $VERBOSITY_LEVELS ]];then
				VERBOSITY_LEVEL="$OPTARG"
			else
				error_handler 4 "$OPTARG"
			fi
			;;
		U)	script_self_updater
			;;
		V)	print_version_info
			exit 0
			;;
		x)	B_EXTRA_DATA='true'
			;;
		h)	show_options
			exit 0
			;;
		*)	error_handler 7 "$opt"
			;;
		esac
	done
}

## print out help menu, not including Testing or Debugger stuff because it's not needed
show_options()
{
	local color_scheme_count=${#A_COLOR_SCHEMES[@]}

	print_screen_output "$SCRIPT_NAME supports the following options. You can combine"
	print_screen_output "them, or list them one by one: Examples: $SCRIPT_NAME -v4 -c6 OR $SCRIPT_NAME -dc 6"
	print_screen_output "Note: all extra output options (like -d, -f, -x) require a verbosity level of 1 or higher."
	print_screen_output "In other words, they do not run if you do not use either -d or -v1 (or higher)"
	print_screen_output "- - - - - - - - - - - - - - - - - - - - - - - - - - - - -"
	print_screen_output "-C  Overrides defective or corrupted data."
	print_screen_output "-c  Available color schemes. Scheme number is required."
	print_screen_output "    Supported schemes: 0-$color_scheme_count Example: $SCRIPT_NAME -c 11"
	print_screen_output "-d  Default output verbosity level, same as: $SCRIPT_NAME -v 1"
	print_screen_output "-f  Show all cpu flags used, not just the short list."
	print_screen_output "-F  Show Full, all possible, output for $SCRIPT_NAME."
	print_screen_output "-U  Autoupdate script. Note: if you installed as root, you"
	print_screen_output "    must be root to update, otherwise user is fine."
	print_screen_output "-v  Script verbosity levels. Verbosity level number is required."
	print_screen_output "    Supported levels: 0-${VERBOSITY_LEVELS} Example: $SCRIPT_NAME -v 4"
	print_screen_output "    0 - short output, same as using nothing: $SCRIPT_NAME"
	print_screen_output "    1 - basic verbose, same as: $SCRIPT_NAME -d"
	print_screen_output "    2 - Also show networking card data"
	print_screen_output "    3 - Also show hard disk names as detected."
	print_screen_output "    4 - Also show partition size/filled data for (if present):/, /home, /var/, /boot"
	print_screen_output "    5 - For multicore systems, also show per core clock speeds."
	print_screen_output "-V  $SCRIPT_NAME version information. Prints information then exits."
	print_screen_output "-x  Show extra data: bogomips on cpu; full hard disk info (using -v3 or greater)."
	rint_screen_output ""
}

## print out version information for -V/--version
print_version_info()
{
	local last_modified=$( grep -im 1 'date:' $SCRIPT_PATH/$SCRIPT_NAME | gawk '{print $3,$4,$5}' )

	print_screen_output "$SCRIPT_NAME - the universal, portable, system info script for irc."
	print_screen_output "Version: $SCRIPT_VERSION_NUMBER"
	print_screen_output "Script Last Modified: $last_modified"
	print_screen_output "Script Location: $SCRIPT_PATH"
	print_screen_output ""
	print_screen_output "Tested with Irssi, Xchat, Konversation, BitchX, KSirc, ircII,"
	print_screen_output "Gaim/Pidgin, Weechat, KVIrc and Kopete."
	print_screen_output ""
	print_screen_output "This script is a fork of Infobash, which is:"
	print_screen_output "Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif <infobash@rebelhomicide.demon.nl>"
	print_screen_output "Subsequent changes and modifications (after Infobash 3.02) are:"
	print_screen_output "Copyright (C) 2008 Scott Rogers, Harald Hope, aka trash80 & h2"
	print_screen_output ""
	print_screen_output "This program is free software; you can redistribute it and/or modify"
	print_screen_output "it under the terms of the GNU General Public License as published by"
	print_screen_output "the Free Software Foundation; either version 3 of the License, or"
	print_screen_output "(at your option) any later version."
}

script_self_updater()
{
	print_screen_output "Starting $SCRIPT_NAME self updater."
	print_screen_output "Currently running $SCRIPT_NAME version number: $SCRIPT_VERSION_NUMBER"
	print_screen_output "Updating $SCRIPT_NAME in $SCRIPT_PATH now..."
	wget -O $SCRIPT_PATH/$SCRIPT_NAME http://techpatterns.com/downloads/distro/$SCRIPT_NAME || error_handler 8 "$?"
	if [[ $? -eq 0 ]];then
		SCRIPT_VERSION_NUMBER=$( grep -im 1 'version:' $SCRIPT_PATH/$SCRIPT_NAME | gawk '{print $3}' )
		print_screen_output "Successfully updated to version: $SCRIPT_VERSION_NUMBER\nTo run the new version, just start $SCRIPT_NAME again."
		exit 0
	fi
}

########################################################################
#### MAIN FUNCTIONS
########################################################################

#### -------------------------------------------------------------------
#### initial startup stuff
#### -------------------------------------------------------------------

# Determine where inxi was run from, set IRC_CLIENT and IRC_CLIENT_VERSION
get_start_client()
{
	local irc_client_path='' irc_client_path_lower='' non_native_konvi='' i=''

	if tty >/dev/null;then
		IRC_CLIENT="Shell"
		unset IRC_CLIENT_VERSION
		B_RUNNING_IN_SHELL='true'
	elif [[ -n $PPID && -f /proc/$PPID/exe ]];then
		irc_client_path=$( readlink /proc/$PPID/exe )
		irc_client_path_lower=$( tr '[:upper:]' '[:lower:]' <<< $irc_client_path )
		# from sidux infobash, handle bad detection of shell; Horst Tritremmel <hjt at sidux.com>
		echo irc_client_path $irc_client_path
		echo irc_client_path_lower $irc_client_path_lower
		echo pspppid:$(ps -p $PPID -o ppid --no-headers | sed 's/ //g'):
		echo irc_client_path_lower::: ${irc_client_path_lower##*/}
		[[ ${irc_client_path_lower##*/} =~ dash|bash|sh ]] && echo yes || echo no
		exit

		# note: do NOT put into '' or "" the dash|bash stuff, otherwise the structure fails
		if [[ ${irc_client_path_lower##*/} =~ dash|bash|sh ]]; then
			# We want to know who wrapped it into the shell.
			PPPID="$( ps -p $PPID -o ppid --no-headers | sed 's/ //g' )"
			if [[ -n $PPPID && -f /proc/$PPPID/exe ]];then
				irc_client_path="$( readlink /proc/$PPPID/exe )"
				irc_client_path_lower="$( tr '[:upper:]' '[:lower:]' <<< $irc_client_path )"
			fi
		fi

		# this handles the problem with konversation reporting itself as perl, which was missed because
		# when konversation starts inxi from inside itself, as a script, the parent is konversation, not perl
		if [[ -z $( grep -i 'konversation' <<< $irc_client_path ) && -n $( grep -i 'perl' <<< $irc_client_path ) && -n $( pidof konversation ) ]];then
			irc_client_path=$( which konversation )
			irc_client_path_lower=$( tr '[:upper:]' '[:lower:]' <<< $irc_client_path )
			non_native_konvi='true'
		fi

		case $irc_client_path_lower in
			*irssi-text*|*irssi*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="Irssi"
				;;
			*konversation*)
				# this is necessary to avoid the dcop errors from starting inxi as a /cmd started script
				if [[ $non_native_konvi == 'true' ]];then
					KONVI=2
				else
					KONVI=1
				fi
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk '
				/Konversation:/ {
					for ( i=2; i<=NF; i++ ) {
						if (i == NF) {
							print $i
						}
						else {
							printf $i" "
						}
					}
					exit
				}' )"
				T=($IRC_CLIENT_VERSION)
				if [[ ${T[0]} == *+* ]];then
					# < Sho_> locsmif: The version numbers of SVN versions look like this:
					#         "<version number of last release>+ #<build number", i.e. "1.0+ #3177" ...
					#         for releases we remove the + and build number, i.e. "1.0" or soon "1.0.1"
					IRC_CLIENT_VERSION=" CVS $IRC_CLIENT_VERSION"
					T2="${T[0]/+/}"
				else
					IRC_CLIENT_VERSION=" ${T[0]}"
					T2="${T[0]}"
				fi
				# Remove any dots except the first, and make sure there are no trailing zeroes,
				T2=$( echo "$T2" | gawk '
				{
					sub(/\./, " ")
					gsub(/\./, "")
					sub(/ /, ".")
					printf("%g\n", $0)
				}' )
				# Since Konversation 1.0, the DCOP interface has changed a bit: dcop "$DCPORT" Konversation ..etc
				# becomes : dcop "$DCPORT" default ... or dcop "$DCPORT" irc ..etc. So we check for versions smaller
				# than 1 and change the DCOP parameter/object accordingly.
				if [[ ${T2} < 1 ]];then
					DCOPOBJ="Konversation"
				fi
				IRC_CLIENT="Konversation"
				;;
			*xchat-gnome)
				RC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="X-Chat-Gnome"
				;;
			*xchat*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="X-Chat"
				;;
			*bitchx*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk '
				/Version/ {
					a=tolower($2)
					gsub(/[()]|bitchx-/,"",a)
					print a
					exit
				}
				$2 == "version" {
					a=tolower($3)
					sub(/bitchx-/,"",a)
					print a
					exit
				}' )"
				IRC_CLIENT="BitchX"
				;;
			*ircii*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $3 }' )"
				IRC_CLIENT="ircII"
				;;
			*gaim*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="Gaim"
				;;
			*pidgin*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v | gawk 'NR == 1 { print $2 }' )"
				IRC_CLIENT="Pidgin"
				;;
			*weechat-curses*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v) "
				IRC_CLIENT="Weechat"
				;;
			*kvirc*)
				IRC_CLIENT_VERSION=" $( $irc_client_path -v 2>&1 | gawk '{
					for ( i=2; i<=NF; i++) {
				 		if (i==NF) {
				 			print $i
				 		}
				 		else {
				 			printf $i" "
				 		}
				 	}exit
				 }' )"
				IRC_CLIENT="KVIrc"
				;;
			*kopete*)
				IRC_CLIENT_VERSION=" $( kopete -v | gawk '
				/Kopete:/ {
					print $2
					exit
				}' )"
				IRC_CLIENT="Kopete"
				;;
			*perl*)
				unset IRC_CLIENT_VERSION	# KSirc is one of the possibilities now. KSirc is a wrapper around dsirc, a perl client
				get_cmdline $PPID
				for (( i=0; i <= $CMDL_MAX; i++ ))
				do
					case ${A_CMDL[i]} in
						*dsirc*)
							IRC_CLIENT="KSirc"
							# Dynamic runpath detection is too complex with KSirc, because KSirc is started from
							# kdeinit. /proc/<pid of the grandparent of this process>/exe is a link to /usr/bin/kdeinit
							# with one parameter which contains parameters separated by spaces(??), first param being KSirc.
							# Then, KSirc runs dsirc as the perl irc script and wraps around it. When /exec is executed,
							# dsirc is the program that runs inxi, therefore that is the parent process that we see.
							# You can imagine how hosed I am if I try to make inxi find out dynamically with which path
							# KSirc was run by browsing up the process tree in /proc. That alone is straightjacket material.
							# (KSirc sucks anyway ;)
							IRC_CLIENT_VERSION=" $( ksirc -v | gawk '
							/KSirc:/ {
								print $2
								exit
							}' )"
							break
							;;
					esac
				done
				if [[ -z $IRC_CLIENT_VERSION ]];then
					IRC_CLIENT="Unknown Perl client"
				fi
				;;
			*bash*|*sh*)
				unset IRC_CLIENT_VERSION
				IRC_CLIENT="Shell wrapper"
				;;
			*)
				IRC_CLIENT="Unknown : ${irc_client_path##*/}"
				unset IRC_CLIENT_VERSION
				;;
		esac
		if [[ $SHOW_IRC -lt 2 ]];then
			unset IRC_CLIENT_VERSION
		fi
	else
		IRC_CLIENT="PPID=\"$PPID\" - empty?"
		unset IRC_CLIENT_VERSION
	fi
}

## this is a mishmash and will be mostly moved to other places over time, for now
## it's just a holder for some misc stuff that has to happen
set_calculated_variables()
{
	local path='' sys_path='' added_path='' b_path_found=''
	# Extra path variable to make execute failures less likely, merged below
	local extra_paths="/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin"

	# Fallback paths put into $extra_paths; This might, among others, help on gentoo.
	# Now, create a difference of $PATH and $extra_paths and add that to $PATH:
	IFS=":"
	for path in $extra_paths
	do
		b_path_found='false'
		for sys_path in $PATH
		do
			if [[ $path == $sys_path ]];then
				b_path_found='true'
			fi
		done
		if [[ $b_path_found == 'false' ]];then
			added_path="$added_path:$path"
		fi
	done
	IFS="$ORIGINAL_IFS"
	PATH="${PATH}${added_path}"
	##echo "PATH='$PATH'"
	##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""'

	# Do this after sourcing of config overrides so user can customize banwords
	BAN_LIST_NORMAL=$( make_ban_lists "${A_NORMAL_BANS[@]}" ) # Contrary to my previous belief, "${ARR[@]}" passes a quoted list, not one string
	BAN_LIST_CPU=$( make_ban_lists "${A_CPU_BANS[@]}" )
	##echo "BAN_LIST_NORMAL='$BAN_LIST_NORMAL'"
}

#### -------------------------------------------------------------------
#### get data types
#### -------------------------------------------------------------------
## create array of sound cards installed on system
get_audio_data()
{
	local i=''

	IFS=$'\n'
	A_AUDIO_DATA=( $( echo "$lspci_data" | gawk -F': ' '
	{ IGNORECASE=1 }
	/multimedia audio controller|audio device/ {
		gsub(/'"$BAN_LIST_NORMAL"'/, "", $NF )
		gsub(/,/," ",$NF)
		gsub(/^ +| +$/,"",$NF)
		gsub(/ [ \t]+/," ",$NF)
		print $NF
	}' ) )
	IFS="$ORIGINAL_IFS"

	# handle cases where card detection fails, like in PS3, where lspci gives no output, or headless boxes..
	if [[ ${#A_AUDIO_DATA[@]} -eq 0 ]];then
		A_AUDIO_DATA[0]='Failed to Detect Sound Card!'
	fi
}

## create A_CPU_CORE_DATA, currently with two values: integer core count; core string text
## return value cpu core count string, this helps resolve the multi redundant lines of old style output
get_cpu_core_count()
{
	## Because of the upcoming release of cpus with core counts over 6, a count of cores is given after Deca (10)
	# count the number of processors given
	local cpu_core_count=$(grep -ic "cpu cores" /proc/cpuinfo| cut -d':' -f2)

	if [[ $cpu_core_count -eq 0 ]];then
		cpu_core_count=$(grep -ic "^processor" /proc/cpuinfo| cut -d':' -f2)
	fi
	local cpu_alpha_count=''

	if [[ $cpu_core_count -lt 2 ]]; then
		cpu_core_count=1
	fi

	# match the numberic value to an alpha value
	case $cpu_core_count in
		1) cpu_alpha_count='Single';;
		2) cpu_alpha_count='Dual';;
		3) cpu_alpha_count='Triple';;
		4) cpu_alpha_count='Quad';;
		5) cpu_alpha_count='Penta';;
		6) cpu_alpha_count='Hexa';;
		7) cpu_alpha_count='Hepta';;
		8) cpu_alpha_count='Octa';;
		9) cpu_alpha_count='Ennea';;
		10) cpu_alpha_count='Deca';;
		*) cpu_alpha_count='Multi';;
	esac
	# create array, core count integer; core count string
	A_CPU_CORE_DATA=( "$cpu_core_count" "$cpu_alpha_count Core"  )
}

## working, will be replaced by new trash80 stuff
get_cpu_data()
{
	local i='' j='' cpu_array_nu='' a_cpu_working='' multi_cpu=''

	IFS=$'\n'
	A_CPU_DATA=($(gawk -F': ' '
	{ IGNORECASE=1 }
	# TAKE NOTE: \t+ will work for /proc/cpuinfo, but SOME ARBITRARY FILE used for TESTING might contain SPACES!
	# Therefore PATCH to use [ \t]+ when TESTING!
	/^processor\t+:/ { nr = $NF }

	/^model name|^cpu\t+:/ {
		gsub(/'"$BAN_LIST_NORMAL"'/, "", $NF )
		gsub(/'"$BAN_LIST_CPU"'/, "", $NF )
		gsub(/,/, " ", $NF)
		gsub(/^ +| +$/, "", $NF)
		gsub(/ [ \t]+/, " ", $NF)
		cpu[nr, "model"] = $NF
	}

	/^cpu MHz|^clock\t+:/ {
		if (!min) {
			min = $NF
		}
		else {
			if ($NF < min) {
				min = $NF
			}
		}

		if ($NF > max) {
			max = $NF
		}
		gsub(/MHZ/,"",$NF) ## clears out for cell cpu
		gsub(/.00[0]+$/,".00",$NF) ## clears out excessive zeros
		cpu[nr, "speed"] = $NF
	}

	/^cache size/      { cpu[nr, "cache"] = $NF }

	/^flags/      { cpu[nr, "flags"] = $NF }

	/^bogomips/   { cpu[nr, "bogomips"] = $NF }

	/vendor_id/ {
		gsub(/genuine|authentic/,"",$NF)
		cpu[nr, "vendor"] = tolower( $NF )
	}

	END {
		#if (!nr) { print ",,,"; exit } # <- should this be necessary or should bash handle that
		for ( i = 0; i <= nr; i++ ) {
			print cpu[i, "model"] "," cpu[i, "speed"] "," cpu[i, "cache"] "," cpu[i, "flags"] "," cpu[i, "bogomips"] ","  cpu[nr, "vendor"]
		}
		if (!min) {
			print "not found"
			exit
		}
		if (min != max) {
			printf("Min:%s%s Max:%s%s\n", min, "Mhz", max, "Mhz")
		}
		else {
			printf("%s %s\n", max, "Mhz")
		}
	}' /proc/cpuinfo))

	IFS="$ORIGINAL_IFS"
}

## return distro name/id if found
get_distro_data()
{
	local i='' distro='' distro_file='' a_distro_glob=''

	shopt -s nullglob
	cd /etc
	a_distro_glob=(*[-_]{release,version})
	cd "$OLDPWD"
	shopt -u nullglob

	if [[ ${#a_distro_glob[@]} -eq 1 ]];then
		distro_file="${a_distro_glob}"
	elif [[ ${#a_distro_glob[@]} -gt 1 ]];then
		for i in $DISTROS_DERIVED $DISTROS_PRIMARY
		do
			# Only echo works with ${var[@]}, not print_screen_output() or script_debugger()
			# This is a known bug, search for the word "strange" inside comments
			# echo "i='$i' a_distro_glob[@]='${a_distro_glob[@]}'"
			## note: this method only works with [[ brackets, not [. It's very hard to actually
			## use this, it should probably be made more explicit.
			if [[ " ${a_distro_glob[@]} " == *" $i "* ]];then
				distro_file="${i}"
				break
			fi
		done
	fi
	if [[ -n $distro_file && -s /etc/$distro_file && " $DISTROS_EXCLUDE_LIST " != *" $distro_file "* ]];then
		distro=$( remove_erroneous_chars "/etc/$distro_file" )
	# this is necessary because antiX doesn't use version/release in its distro id file name
	# so the glob tests fail. I expect those tests will need to be redone at some point to avoid this
	elif [[ -e /etc/antiX ]];then
		distro="$( egrep -oi 'antix.*\.iso' <<< $( remove_erroneous_chars '/etc/antiX' ) | sed 's/\.iso//' )"
	else
		# Debian pure should fall through here
		distro_file="issue"
		distro=$( gawk '
		BEGIN { RS="" } {
			gsub(/\\[a-z]/, "")
			gsub(/,/, " ")
			gsub(/^ +| +$/, "")
			gsub(/ [ \t]+/, " ")
			print
		}' "/etc/${distro_file}" )
	fi
	if [[ ${#distro} -gt 80 && $B_HANDLE_CORRUPT_DATA != 'true' ]];then
		distro="${RED}/etc/${distro_file} corrupted, use -C to override${NORMAL}"
	fi
	## note: would like to actually understand the method even if it's not used
	# : ${distro:=Unknown distro o_O}
	if [[ -z $distro ]];then
		distro='Unknown distro o_O'
	fi

	# this handles an arch bug where /etc/arch-release is empty and /etc/issue is corrupted
	if [[ -n $( grep -i 'arch linux' <<< $distro ) ]];then
		distro='Arch Linux'
	fi
	echo "$distro"
}

## create array of gfx cards installed on system
get_graphics_card_data()
{
	local i=''

	IFS=$'\n'
	A_GFX_CARD_DATA=( $( echo "$lspci_data" | gawk -F': ' '
	{ IGNORECASE=1 }
	/vga compatible controller/ {
		gsub(/'"$BAN_LIST_NORMAL"'/, "", $NF)
		gsub(/,/, " ", $NF)
		gsub(/^ +| +$/, "", $NF)
		gsub(/ [ \t]+/, " ", $NF)
		print $NF
	}' ) )
	IFS="$ORIGINAL_IFS"
# 	for (( i=0; i < ${#A_GFX_CARD_DATA[@]}; i++ ))
# 	do
# 		A_GFX_CARD_DATA[i]=$( sanitize_characters BAN_LIST_NORMAL "${A_GFX_CARD_DATA[i]}" )
# 	done
	# handle cases where card detection fails, like in PS3, where lspci gives no output, or headless boxes..
	if [[ ${#A_GFX_CARD_DATA[@]} -eq 0 ]];then
		A_GFX_CARD_DATA[0]='Failed to Detect Video Card!'
	fi

	# GFXMEM is UNUSED at the moment, because it shows AGP aperture size, which is not necessarily equal to GFX memory..
	# GFXMEM="size=[$(echo "$lspci_data" | gawk '/VGA/{while (!/^$/) {getline;if (/size=[0-9][0-9]*M/) {size2=gensub(/.*\[size=([0-9]+)M\].*/,"\\1","g",$0);if (size<size2){size=size2}}}}END{print size2}')M]"
}

## create array of glx data
get_graphics_glx_data()
{
	if [[ $B_X_RUNNING == 'true' ]];then
		IFS=$'\n'
		A_GLX_DATA=( $( glxinfo | gawk -F ': ' '
		function join(arr, sep) {
			s=""
			i=flag=0
			for (i in arr) {
				if (flag++) s = s sep
				s = s i
			}
			return s
		}

		BEGIN { IGNORECASE=1 }
		/opengl renderer/ {
			if ($2 ~ /mesa/) {
				# Allow r300 et al, but not the rest
				if ($2 ~ / r[3-9][0-9][0-9] /) {
					a[$2]
					f++
				}
				next
			}
			$2 && a[$2]
		}
		/opengl version/ && (f || $2 !~ /mesa/) { $2 && b[$2] }
		/direct rendering/ { $2 && c[$2] }

		END {
			printf("%s\n%s\n%s\n", join(a,", "), join(b,", "), join(c,", "))
		}' ) )
		IFS="$ORIGINAL_IFS"

		# GLXR=$(glxinfo | gawk -F ': ' 'BEGIN {IGNORECASE=1} /opengl renderer/ && $2 !~ /mesa/ {seen[$2]++} END {for (i in seen) {printf("%s ",i)}}')
		#    GLXV=$(glxinfo | gawk -F ': ' 'BEGIN {IGNORECASE=1} /opengl version/ && $2 !~ /mesa/ {seen[$2]++} END {for (i in seen) {printf("%s ",i)}}')
	fi
}

## return screen resolution / tty resolution
get_graphics_res_data()
{
	local screen_resolution=''

	if [[ $B_X_RUNNING == 'true' ]];then
		# Added the two ?'s , because the resolution is now reported without spaces around the 'x', as in
		# 1400x1050 instead of 1400 x 1050. Change as of X.org version 1.3.0
		screen_resolution=$( xrandr | gawk '
		/\*/ { res[++m] = gensub(/^.* ([0-9]+) ?x ?([0-9]+)[_ ].* ([0-9\.]+)\*.*$/,"\\1x\\2@\\3hz","g",$0) }
		END {
			for (n in res) {
				if (res[n] ~ /^[[:digit:]]+x[[:digit:]]+/)
					line = line ? line ", " res[n] : res[n]
			}
			if (line)
				print(line)
		}' )
		if [[ -z $screen_resolution ]];then
			screen_resolution=$( xdpyinfo | gawk '/dimensions/ { print $2 }' )
		fi
	else
		screen_resolution=$( stty -F $( readlink /proc/$PPID/fd/0 ) size | gawk '{ print $2"x"$1 }' )
	fi
	echo "$screen_resolution"
}

## for possible future data, not currently used
get_graphics_agp_data()
{
	local agp_module=''

	## not used currently
	agp_module=$( gawk '/agp/ && !/agpgart/ && $3 > 0 { print(gensub(/(.*)_agp.*/,"\\1","g",$1)) }' /proc/modules )
}

## create array of x vendor/version data
get_graphics_x_data()
{
	local x_vendor='' x_version=''

	if [[ $B_X_RUNNING == 'true' ]];then
		# X vendor and version detection.
		x_vendor=$( xdpyinfo | gawk -F': +' '
		BEGIN { IGNORECASE=1 }
		/vendor string/ {
			gsub(/the|inc|foundation|project|corporation/, "", $2)
			gsub(/,/, " ", $2)
			gsub(/^ +| +$/, "", $2)
			gsub(/ [ \t]+/, " ", $2)
			print $2
		}' )

		# new method added since radeon and X.org and the disappearance of <X server name> version : ...etc
		# Later on, the normal textual version string returned, e.g. like: X.Org version: 6.8.2
		# A failover mechanism is in place. (if $x_version is empty, the release number is parsed instead)
		x_version=$( xdpyinfo | gawk '/version:/ { print $NF }' )
		if [[ -z $x_version ]];then
			x_version=$(xdpyinfo | gawk -F': +' '
			BEGIN { IGNORECASE=1 }
			/vendor release number/ {
				gsub(/0+$/, "", $2)
				gsub(/0+/, ".", $2)
				print $2
			}' )
		fi
		A_X_DATA[0]="$x_vendor"
		A_X_DATA[1]="$x_version"

		#X -version 2>&1 | gawk '/^X Window System Version/ { print $5 }'
		#This method could be used in the future to detect X when X is not running,
		#however currently inxi ignores X checks when X is not found.
	fi
}

# this gets just the raw data, total space/percent used and disk/name/per disk capacity
get_hdd_data_basic()
{
	local hdd_used=''

	hdd_used=$( df | gawk '
	p {
		if (/^\/dev\/(mapper\/|[hs]d[a-z][0-9]+)/) {
			if (NF == 1) {
				getline
				if (NF == 5) {
					c += $2
				}
				else {
					next
				}
			}
			else if (NF == 6) {
				c += $3
			}
		}
	}
	/^Filesystem/ { p++ }
	END {
		print c
	}' )

	# create the initial array strings:
	# disk-dev, capacity, name, usb or not
	# final item is the total of the disk
	IFS=$'\n'
	A_HDD_DATA=( $( gawk -v hddused="$hdd_used" '
	/[hs]d[a-z]$/ {
		driveSize = $(NF - 1)*1024/1000**3
		gsub(/,/, " ", driveSize)
		gsub(/^ +| +$/, "", driveSize)
		printf( $NF",%.1fGB,,\n", driveSize )
	}
	# See http://lanana.org/docs/device-list/devices-2.6+.txt for major numbers used below
	# $1 ~ /^(3|22|33|8)$/ && $2 % 16 == 0  {size+=$3}
	# special case from this data: 8     0  156290904 sda
	$1 ~ /^(3|22|33|8)$/ && $NF ~ /[hs]d[a-z]$/ && ( $2 % 16 == 0 || $2 % 16 == 8 )  {size+=$3}
	END {
		size = size*1024/1000**3                   # calculate size in GB size
		workingUsed = hddused*1024/1000**3         # calculate workingUsed in GB used
		if ( size > 0 && workingUsed > 0 ){
			diskUsed = workingUsed*100/size  # calculate used percentage
			diskUsed = sprintf( "%.1f", diskUsed )
			size = sprintf( "%.1f", size )
			print size"GB,"diskUsed"% used"
		}
		else {
			print "NA,-" # print an empty array, this will be further handled in the print out function
		}
	}'  /proc/partitions ) )
	IFS="$ORIGINAL_IFS"
}

## fills out the A_HDD_DATA array with disk names
get_hard_drive_data_advanced()
{
	local a_temp_working='' a_temp_scsi='' temp_holder='' temp_name='' i='' j=''
	local sd_ls_by_id=''

	## check for all ide type drives, non libata, only do it if hdx is in array
	if [[ -n $( egrep 'hd[a-z]' <<< ${A_HDD_DATA[@]} ) ]];then
		# remember, we're using the last array item to store the total size of disks
		for (( i=0; i < ${#A_HDD_DATA[@]} - 1; i++ ))
		do
			IFS=","
			a_temp_working=( ${A_HDD_DATA[i]} )
			IFS="$ORIGINAL_IFS"
			if [[ -n $( egrep '^hd[a-z]' <<< ${a_temp_working[0]} ) ]];then
				if [[ -e /proc/ide/${a_temp_working[0]}/model ]];then
					a_temp_working[2]="$( remove_erroneous_chars /proc/ide/${a_temp_working[0]}/model )"
				else
					a_temp_working[2]="Name n/a"
				fi
				# these loops are to easily extend the cpu array created in the awk script above with more fields per cpu.
				for (( j=0; j < ${#a_temp_working[@]}; j++ ))
				do
					if [[ $j -gt 0 ]];then
						A_HDD_DATA[i]="${A_HDD_DATA[i]},${a_temp_working[$j]}"
					else
						A_HDD_DATA[i]="${a_temp_working[$j]}"
					fi
				done
			fi
		done
	fi

	## then handle libata names
	# first get the ata device names, put them into an array
	if [[ -e /proc/scsi/sg/device_strs ]]; then
		IFS=$'\n'
		## prints out hdd device if field one is ATA type (sata compatibility mode) or prints out scsi device
		# note: pmap handles usb mounted devices, which have a null first field
		if [[ $B_TESTING_FLAG == 'true' ]];then
			a_temp_scsi=( $( gawk -F'\t' '
			BEGIN { IGNORECASE=1 }
			# if the item starts with empty, void field, assume it is flash drive
			/^ata|^scsi|^ |^corsair|^wdc|^kingston/    {
				gsub(/,/, " ", $(NF -1) )
				gsub(/^ +| +$/, "", $(NF -1) )
				print $(NF -1)
			}
			' /proc/scsi/sg/device_strs ) )
		else
			a_temp_scsi=( $( gawk  '
			BEGIN { IGNORECASE=1 }
			/host/ {
				getline a[$0]
				getline b[$0]
			}
			END {
				for (i in a) {
					if (b[i] ~ / *type: *direct-access.*/) {
						#c=gensub(/^ *vendor: (.+) +model: (.+) +rev: (.+)$/,"\\1 \\2 \\3","g",a[i])
						#c=gensub( /^ *vendor: (.+) +model: (.+) +rev:.*$/,"\\1 \\2","g",a[i] )
						# the vendor: string is useless, and is a bug, ATA is not a vendor for example
						c=gensub( /^ *vendor: (.+) +model: (.+) +rev:.*$/, "\\2", "g", a[i] )
						gsub(/,/, " ", c)
						gsub(/^ +| +$/, "", c)
						gsub(/ [ \t]+/, " ", c)
						#print a[i]
						# we actually want this data, so leaving this off for now
# 						if (c ~ /\<flash\>|\<pendrive\>|memory stick|memory card/) {
# 							continue
# 						}
						print c
					}
				}
			}' /proc/scsi/scsi) )
		fi
		IFS="$ORIGINAL_IFS"
	fi

	## then we'll loop through that array looking for matches. Note, with identical drives this will fail, sigh..
	## for future use, that should be tightened up, but for now it's fine.
	if [[ -n $( egrep 'sd[a-z]' <<< ${A_HDD_DATA[@]} ) ]];then
		for (( i=0; i < ${#A_HDD_DATA[@]} - 1; i++ ))
		do
			if [[ -n $( egrep '^sd[a-z]' <<< ${A_HDD_DATA[$i]} ) ]];then
				IFS=","
				a_temp_working=( ${A_HDD_DATA[$i]} )
				IFS="$ORIGINAL_IFS"
				if [[ ${#a_temp_scsi[@]} > 0 ]];then
					for (( j=0; j < ${#a_temp_scsi[@]}; j++ ))
					do
						## ok, ok, it's incomprehensible, search /dev/disk/by-id for a line that contains the
						# discovered disk name AND ends with the correct identifier, sdx
						# get rid of whitespace for some drive names and ids, and extra data after - in name
						temp_name=$( tr ' ' '_' <<< ${a_temp_scsi[$j]} | cut -d '-' -f 1 )

						sd_ls_by_id=$( ls -l /dev/disk/by-id | egrep -m1 ".*$temp_name.*${a_temp_working[0]}$" )
	# 					echo temp_name:$temp_name
						if [[ -n $sd_ls_by_id ]];then
							a_temp_working[2]=${a_temp_scsi[$j]}
							if [[ -n $( grep 'usb-' <<< $sd_ls_by_id ) ]];then
								a_temp_working[3]='usb'
							fi
							break
						else
							# special initial usb handling
	# 						if [[ -n $( ls -l /dev/disk/by-id | egrep -m1 ".*/USB.*${a_temp_working[0]}$" ) ]];then
	#
	# 						else
								a_temp_working[2]="Name n/a"
	# 						fi
						fi
					done
				else
					a_temp_working[2]="Name n/a"
				fi

				# these loops are to easily extend the cpu array created in the awk script above with more fields per cpu.
				for (( j=0; j < ${#a_temp_working[@]}; j++ ))
				do
					if [[ $j -gt 0 ]];then
						A_HDD_DATA[i]="${A_HDD_DATA[i]},${a_temp_working[$j]}"
					else
						A_HDD_DATA[i]="${a_temp_working[$j]}"
					fi
				done
			fi
		done
	fi
}

get_lspci_data()
{
	echo "$( lspci -v | gawk '{
		gsub(/\(prog-if[^)]*\)/,"")
		print
	}' )"
}

## return memory used/installed
get_memory_data()
{
	local memory=''

	memory=$( gawk '
	/^MemTotal:/ { tot = $2 }
	/^(MemFree|Buffers|Cached):/ { notused+=$2 }
	END {
		used = tot-notused
		printf("%.1f/%.1fMB\n", used/1024, tot/1024)
	}' /proc/meminfo )

	echo "$memory"
}

## create array of network cards
get_networking_data()
{
	IFS=$'\n'
	A_NETWORK_DATA=( $( echo "$lspci_data" | gawk '
	BEGIN { IGNORECASE=1 }
	/^[0-9a-f:.]+ (ethernet|network) (controller|bridge)/ || /^[0-9a-f:.]+ [^:]+: .*(ethernet|network).*$/ {
		nic=gensub(/^[0-9a-f:.]+ [^:]+: (.+)$/,"\\1","g",$0)
		gsub(/realtek semiconductor/, "Realtek", nic)
		gsub(/davicom semiconductor/, "Davicom", nic)
		# The doublequotes are necessary because of the pipes in the variable.
		gsub(/'"$BAN_LIST_NORMAL"'/, "", nic)
		gsub(/,/, " ", nic)
		gsub(/^ +| +$/, "", nic)
		gsub(/ [ \t]+/, " ", nic)

		eth[nic]++
		while (getline && !/^$/) {
			if (/I\/O/) {
				ports[nic]=ports[nic]$4" "
			}
		}
	}

	END {
		j=0
		for (i in eth) {
			usePorts=""
			if (eth[i]>1) {
				a[j]=eth[i]"x "i
				## note: this loses the plural ports case, is it needed anyway?
				if (ports[i] != "") {
					usePorts=ports[i]
				}
			}
			else {
				a[j]=i
				if (ports[i] != "") {
					usePorts=ports[i]
				}
			}
			# create array primary item for master array
			print a[j] "," usePorts
			j++
		}
	}') )
	IFS="$ORIGINAL_IFS"
}

get_partition_data()
{
	IFS=$'\n'
	# sample line: /dev/sda2     ext3     15G  8.9G  4.9G  65% /home
	# $NF = partition name; $(NF - 4) = partition size; $(NF - 3) = used, in gB; $(NF - 1) = percent used
	## note: by subtracting from the last field number NF, we avoid a subtle issue with LVM df output, where if
	## the first field is too long, it will occupy its own line, this way we are getting only the needed data
	A_PARTITION_DATA=( $( df -h -T | gawk '
	/\/$|\/boot$|\/var$|\/home$/ {
		print $NF "," $(NF - 4) "," $(NF - 3) "," $(NF - 1)
	}' ) )
	IFS="$ORIGINAL_IFS"
}

## return uptime string
get_uptime()
{
	## note: removing gsub(/ /,"",a); to get get space back in there, goes right before print a
	echo $( uptime | gawk '{
			a = gensub(/^.*up *([^,]*).*$/,"\\1","g",$0)
			print a
		}' )
}

#### -------------------------------------------------------------------
#### special data handling for specific options and conditions
#### -------------------------------------------------------------------

## multiply the core count by the data to be calculated, bmips, cache
# args: $1 - string to handle; $2 - cpu count
calculate_multicore_data()
{
	local string_number=$1 string_data=''

	if [[ -n $( egrep -i '( mb| kb)' <<< $1 ) ]];then
		string_data=" $( gawk '{print $2}' <<< $1 )" # add a space for output
		string_number=$( gawk '{print $1}' <<< $1 )
	fi
	# handle weird error cases where it's not a number
	if [[ -n $( egrep '^[0-9\.,]+$' <<< $string_number ) ]];then
		string_number=$( echo $string_number $2 | gawk '{total = $1*$2; print total}' )
	elif [[ $string_number == '' ]];then
		string_number='Not Available'
	else
		string_number="Error data:$string_number "
	fi
	echo "$string_number$string_data"
}

# prints out shortened list of flags, the main ones of interest
# args: $1 - string of cpu flags to process
process_cpu_flags()
{
	local cpu_flags="$1"

	# nx = AMD stack protection extensions
	# lm = Intel 64bit extensions
	# sse, sse2, pni = sse1,2,3 gfx extensions
	# svm = AMD pacifica virtualization extensions
	# vmx = Intel IVT (vanderpool) virtualization extensions
	cpu_flags=$( echo "$cpu_flags" | gawk '
	BEGIN {
		RS=" "
		ssel["sse"] = 1
		ssel["sse2"] = 2
		ssel["pni"] = 3
		sses[1] = "sse"
		sses[2] = "sse2"
		sses[3] = "sse3"
	}
	/^(nx|lm|svm|vmx)$/ {
			if (s) {
				s = s " " $0
			}
			else {
				s = $0
			}
	}
	/^(sse2?|pni)$/ {
		if (ssel[$0] > sse) {
			sse = ssel[$0]
		}
	}
	END {
		if (sse) {
			if (s) {
				s = sses[sse] " " s
			}
			else {
				s = sses[sse]
			}
		}
		print s
	}' )

	#grep -oE '\<(nx|lm|sse[0-9]?|pni|svm|vmx)\>' | tr '\n' ' '))
	if [[ -z $cpu_flags ]];then
		cpu_flags="-"
	fi
	echo "$cpu_flags"
}

#### -------------------------------------------------------------------
#### print and processing of output data
#### -------------------------------------------------------------------

print_audio_data()
{
	local i='' card_one='Card-1 ' audio_data='' a_audio_data='' port_data=''
	local a_audio_working=''
	# set A_AUDIO_DATA
	get_audio_data

	IFS=","
	a_audio_working=(${A_AUDIO_DATA[0]})
	IFS="$ORIGINAL_IFS"

	if [[ -n ${A_AUDIO_DATA[@]} ]];then
		if [[ ${#A_AUDIO_DATA[@]} -le 1 ]];then
			card_one='Card '
		fi

		if [[ -n ${a_audio_working[1]} ]];then
			port_data=" ${C1}at port${C2} ${a_audio_working[1]}"
		fi
		audio_data="${C1}$card_one${C2}${a_audio_working[0]}$port_data"
		audio_data=$( create_print_line "Sound:" "$audio_data" )
		print_screen_output "$audio_data"
		i=0 ## loop starts with 1 by auto-increment so it only shows cards > 1
		while [[ -n ${A_AUDIO_DATA[++i]} ]]
		do
			IFS=","
			a_audio_working=( ${A_AUDIO_DATA[i]} )
			IFS="$ORIGINAL_IFS"
			port_data=''
			if [[ -n ${a_audio_working[1]} ]];then
				port_data=" ${C1}at port${C2} ${a_audio_working[1]}"
			fi
			audio_data="${C1}Card-$(( $i + 1 )) ${C2}${a_audio_working[0]}$port_data"
			audio_data=$( create_print_line " " "$audio_data" )
			print_screen_output "$audio_data"
		done
	fi
}

print_cpu_data()
{
	local cpu_data='' i='' cpu_clock_speed='' cpu_multi_clock_data=''
	local bmip_data='' cpu_cache='' cpu_vendor='' cpu_flags=''

	##print_screen_output "A_CPU_DATA[0]=\"${A_CPU_DATA[0]}\""
	# Array A_CPU_DATA always has one element: max clockfreq found.
	# that's why its count is one more than you'd think from cores/cpus alone
	# weird hack, probably should be changed

	cpu_vendor=${a_cpu_working[5]}
	# Strange (and also some expected) behavior encountered.
	# If print_screen_output() uses $1 as the parameter to output to the screen,
	# then passing "<text1> ${ARR[@]} <text2>"
	# will output only <text1> and the first element of ARR. That "@" splits in elements and "*" _doesn't_,
	# is to be expected.
	# However, that text2 is consecutively truncated is somewhat strange, so take note.
	# This has been confirmed by #bash on freenode.
	# The above mentioned only emerges when using the debugging markers below
	## print_screen_output "a_cpu_working=\"***${a_cpu_working[@]} $hostName+++++++\"----------"

	if [[ -z ${a_cpu_working[2]} ]];then
		a_cpu_working[2]="unknown"
	fi

	cpu_data=$( create_print_line "CPU:" "${C1}${cpu_core_count_string}${C2} ${a_cpu_working[0]}" )
	if [[ $VERBOSITY_LEVEL -ge 3 ]];then
		# update for multicore, bogomips x core count.
		if [[ $B_EXTRA_DATA == 'true' ]];then
# 			if [[ $cpu_vendor != 'intel' ]];then
				bmip_data=$( calculate_multicore_data "${a_cpu_working[4]}" "$cpu_core_count"  )
# 			else
# 				bmip_data="${a_cpu_working[4]}"
# 			fi
			bmip_data=" ${C1}bmips${C2} $bmip_data"
		fi
		## note: this handles how intel reports L2, total instead of per core like AMD does
		if [[ $cpu_vendor != 'intel' ]];then
			cpu_cache=$( calculate_multicore_data "${a_cpu_working[2]}" "$cpu_core_count"  )
		else
			cpu_cache="${a_cpu_working[2]}"
		fi
		# only print shortened list
		if [[ $B_CPU_FLAGS_FULL != 'true' ]];then
			cpu_flags=$( process_cpu_flags "${a_cpu_working[3]}" )
			cpu_flags=" ${C1}flags${C2} ($cpu_flags)"
		fi
		cpu_data="$cpu_data${C2} ${C1}cache${C2} $cpu_cache$cpu_flags$bmip_data${CN}"
	fi

	if [[ $VERBOSITY_LEVEL -ge 5 && ${#A_CPU_DATA[@]} -gt 2 ]];then
		cpu_clock_speed='' # null < verbosity level 5
	else
		cpu_data="$cpu_data ${C1}clocked at${C2} ${a_cpu_working[1]} MHz${CN}"
	fi

	cpu_data="$cpu_data $cpu_clock_speed"
	print_screen_output "$cpu_data"

	if [[ $VERBOSITY_LEVEL -ge 5 && ${#A_CPU_DATA[@]} -gt 2 ]];then
		for (( i=0; i < ${#A_CPU_DATA[@]}-1; i++ ))
		do
			IFS=","
			a_cpu_working=(${A_CPU_DATA[i]})
			IFS="$ORIGINAL_IFS"
			cpu_multi_clock_data="$cpu_multi_clock_data ${C1}($(( i + 1 )))${C2} ${a_cpu_working[1]} MHz${CN}"
			if [[ $i -gt 10 ]];then
				break
			fi
		done
		if [[ -n $cpu_multi_clock_data ]];then
			cpu_multi_clock_data=$( create_print_line " " "${C1}Clock Speeds:${C2}$cpu_multi_clock_data" )
			print_screen_output "$cpu_multi_clock_data"
		fi
	fi
	if [[ $B_CPU_FLAGS_FULL == 'true' ]];then
		print_cpu_flags_full "${a_cpu_working[3]}"
	fi
}
# takes list of all flags, split them and prints x per line
# args: $1 - cpu flag string
print_cpu_flags_full()
{
	local cpu_flags_full="$1" cpu_flags_1='' cpu_flags_2='' cpu_flags_3='' flag_data=''
	local i=0 flag=''

	for flag in $cpu_flags_full
	do
		if [[ $i -ge 36 ]];then
			cpu_flags_3="$cpu_flags_3$flag "
		elif [[ $i -ge 18 ]];then
			cpu_flags_2="$cpu_flags_2$flag "
		elif [[ $i -ge 0 ]];then
			cpu_flags_1="$cpu_flags_1$flag "
		fi
		((i++))
	done
	if [[ -n $cpu_flags_1 ]];then
		flag_data=$( create_print_line " " "${C1}CPU Flags${C2} $cpu_flags_1" )
		print_screen_output "$flag_data"
	fi
	if [[ -n $cpu_flags_2 ]];then
		flag_data=$( create_print_line " " "$cpu_flags_2" )
		print_screen_output "$flag_data"
	fi
	if [[ -n $cpu_flags_3 ]];then
		flag_data=$( create_print_line " " "$cpu_flags_3" )
		print_screen_output "$flag_data"
	fi
}

print_gfx_data()
{
	local gfx_data='' i='' card_one='Card '
	local screen_resolution="$( get_graphics_res_data )"
	local b_is_mesa='false'

	# set A_GFX_CARD_DATA
	get_graphics_card_data
	# set A_X_DATA
	get_graphics_x_data
	local x_vendor=${A_X_DATA[0]}
	local x_version=${A_X_DATA[1]}
	# set A_GLX_DATA
	get_graphics_glx_data
	local glx_renderer="${A_GLX_DATA[0]}"
	local glx_version="${A_GLX_DATA[1]}"
	local glx_direct_render="${A_GLX_DATA[2]}"

	if [[ ${#A_GFX_CARD_DATA[@]} -gt 1 ]];then
		i=1
		while [[ -n ${A_GFX_CARD_DATA[i]} && $i -le 3 ]]
		do
			gfx_data=" ${C1}Card-$(($i+1))${C2} ${A_GFX_CARD_DATA[i]}"
			((i++))
		done
		card_one='Card-1 '
	fi
	gfx_data=$( create_print_line "Graphics:" "${C1}$card_one${C2}${A_GFX_CARD_DATA[0]}${gfx_data}" )

	if [[ $B_X_RUNNING == 'true' ]];then
		gfx_data="${gfx_data} ${CN}| ${C1}$x_vendor${C2} $x_version ${CN}| ${C1}Res${C2} ${screen_resolution}"
	else
		gfx_data="${gfx_data} ${C1} tty resolution ${CN}(${C2} ${screen_resolution} ${CN})"
	fi
	print_screen_output "$gfx_data"

	if [[ -z $glx_renderer || -z $glx_version ]];then
		b_is_mesa='true'
	fi

	## note: if glx render or version have no content, then mesa is true
	if [[ $B_X_RUNNING == 'true' && $b_is_mesa != 'true' ]];then
		gfx_data=$( create_print_line " " "${C1}GLX Renderer${C2} ${glx_renderer} ${CN}| ${C1}GLX Version${C2} ${glx_version}${CN}" )
		if [[ $B_HANDLE_CORRUPT_DATA == 'true' ]];then
			gfx_data="${gfx_data} ${C1}Direct rendering${C2} ${glx_direct_render}${CN}"
		fi
		print_screen_output "$gfx_data"
	fi
}

print_hard_disk_data()
{
	local hdd_data='' partition_data='' a_partition_working='' hdd_model='' a_hdd_working=''
	local dev_data='' size_data='' hdd_model_2='' hdd_data_2='' usb_data=''

	if [[ $VERBOSITY_LEVEL -ge 3 ]];then
	## note: the output part of this should be in the print hdd data function, not here
		get_hard_drive_data_advanced
		for (( i=0; i < ${#A_HDD_DATA[@]} - 1; i++ ))
		do
			# this adds the (x) numbering in front of each disk found, and creates the full disk string
			IFS=","
			a_hdd_working=( ${A_HDD_DATA[i]} )
			IFS="$ORIGINAL_IFS"
			if [[ $B_EXTRA_DATA == 'true' ]];then
				if [[ -n ${a_hdd_working[3]} ]];then
					usb_data="(${a_hdd_working[3]}) "
				else
					usb_data=''
				fi
				dev_data="/dev/${a_hdd_working[0]} - "
				size_data=" - ${a_hdd_working[1]}"
			fi
			# wrap to avoid long lines
			if [[ $i -gt 1 && $B_EXTRA_DATA == 'true' ]] || [[ $i -gt 3 ]];then
				hdd_model_2="${hdd_model_2}${hdd_model_2+${C1}($(($i+1)))${C2}}$usb_data$dev_data${a_hdd_working[2]}$size_data "
			else
				hdd_model="${hdd_model}${hdd_model+ ${C1}($(($i+1)))${C2}}$usb_data$dev_data${a_hdd_working[2]}$size_data"
			fi
		done
		if [[ -z $hdd_model ]];then
			hdd_model=' None Detected'
		fi
		if [[ -n $hdd_model_2 ]];then
			hdd_data=$( create_print_line "Disks:" "${C1}HDD${C2} ${C1}Total Size:${C2} ${hdd_capacity} (${hdd_used})${hdd_model}" )
			hdd_data_2=$( create_print_line " " "${hdd_model_2}${CN}" )
		else
			hdd_data=$( create_print_line "Disks:" "${C1}HDD${C2} ${C1}Total Size:${C2} ${hdd_capacity} (${hdd_used})${hdd_model}${CN}" )
		fi
	else
		hdd_data=$( create_print_line "Disks:" "${C1}HDD Total Size:${C2} ${hdd_capacity} (${hdd_used})${CN}" )
	fi
	print_screen_output "$hdd_data"
	if [[ -n $hdd_model_2 ]];then
		print_screen_output "$hdd_data_2"
	fi

	if [[ $VERBOSITY_LEVEL -ge 4 ]];then
		# set A_PARTITION_DATA
		get_partition_data

		for (( i=0; i < ${#A_PARTITION_DATA[@]}; i++ ))
		do
			IFS=","
			a_partition_working=(${A_PARTITION_DATA[i]})
			IFS="$ORIGINAL_IFS"
			partition_data="$partition_data ${C1}ID:${C2} ${a_partition_working[0]} ${C1}size:${C2} ${a_partition_working[1]} ${C1}used:${C2} ${a_partition_working[2]} (${a_partition_working[3]})"
		done
		hdd_data=$( create_print_line " " "${C1}Partition${C2}${partition_data}" )
		print_screen_output "$hdd_data"
	fi
}

print_intro_data()
{
	local intro_data='' host_name=$( hostname )

	local distro="$( get_distro_data )"

	if [[ $B_SHOW_HOST == 'true' ]];then
		intro_data=$( create_print_line "System:" "${C1}Host${C2} $host_name ${C1}running${C2} ${CN}" )
	else
		intro_data=$( create_print_line "System:" "${C1}running${C2} ${CN}" )
	fi
	intro_data="$intro_data ${C2}$current_kernel ${C1}Distro${C2} $distro ${CN}"
	print_screen_output "$intro_data"
}

print_networking_data()
{
	local i='' card_one='Card-1 ' network_data='' a_network_working='' port_data=''
	# set A_NETWORK_DATA
	get_networking_data

	IFS=","
	a_network_working=(${A_NETWORK_DATA[0]})
	IFS="$ORIGINAL_IFS"

	if [[ -n ${A_NETWORK_DATA[@]} ]];then
		if [[ ${#A_NETWORK_DATA[@]} -le 1 ]];then
			card_one='Card '
		fi

		if [[ -n ${a_network_working[1]} ]];then
			port_data=" ${C1}at port${C2} ${a_network_working[1]}"
		fi
		network_data="${C1}$card_one${C2}${a_network_working[0]}$port_data"
		network_data=$( create_print_line "Network:" "$network_data" )
		print_screen_output "$network_data"
		i=0 ## loop starts with 1 by auto-increment so it only shows cards > 1
		while [[ -n ${A_NETWORK_DATA[++i]} ]]
		do
			IFS=","
			a_network_working=( ${A_NETWORK_DATA[i]} )
			IFS="$ORIGINAL_IFS"
			port_data=''
			if [[ -n ${a_network_working[1]} ]];then
				port_data=" ${C1}at port${C2} ${a_network_working[1]}"
			fi
			network_data="${C1}Card-$(( $i + 1 )) ${C2}${a_network_working[0]}$port_data"
			network_data=$( create_print_line " " "$network_data" )
			print_screen_output "$network_data"
		done
	fi
}

print_short_data()
{
	local short_data='' i='' b_background_black='false'
	local memory=$( get_memory_data )
	local cpu_clock="${a_cpu_working[1]}" # old CPU3
	# this gets that weird min/max final array item
	local min_max_clock_nu=$(( ${#A_CPU_DATA[@]} - 1 ))
	local min_max_clock=${A_CPU_DATA[$min_max_clock_nu]}

	#set_color_scheme 12
	if [[ $B_RUNNING_IN_SHELL == 'false' ]];then
		for i in $C1 $C2 $CN
		do
			case "$i" in
				"$GREEN"|"$WHITE"|"$YELLOW"|"$CYAN")
					b_background_black='true'
					;;
			esac
		done
		if [[ $b_background_black == 'true' ]];then
			for i in C1 C2 CN
			do
				## these need to be in quotes, don't know why
				if [[ "${!i}" == "$NORMAL" ]];then
					declare $i="${!i}15,1"
				else
					declare $i="${!i},1"
				fi
			done
			#C1="${C1},1"; C2="${C2},1"; CN="${CN},1"
		fi
	fi
	short_data="${C1}CPU${CN}[${C2}${cpu_core_count_string} ${cpu_model} ${C1}clocked at${C2} ${min_max_clock}${CN}] ${C1}Kernel${CN}[${C2}${current_kernel}${CN}] ${C1}Up${CN}[${C2}${FL2}${FL1}${up_time}${FL1}${CN}] ${C1}Mem${CN}[${C2}${FL2}${FL1}${memory}${FL1}${CN}] ${C1}HDD${CN}[${C2}${FL2}${FL1}${hdd_capacity}($hdd_used)${FL1}${CN}] ${C1}Procs${CN}[${C2}${FL2}${FL1}${processes}${FL1}${CN}]"

	if [[ $SHOW_IRC -gt 0 ]];then
		short_data="${short_data} ${C1}Client${CN}[${C2}${IRC_CLIENT}${IRC_CLIENT_VERSION}${CN}]"
	fi
	short_data="${short_data} ${CN}:: ${C1}$SCRIPT_NAME ${C2}v:$SCRIPT_VERSION_NUMBER${CN}"
	if [[ $SCHEME -gt 0 ]];then
		short_data="${short_data} $NORMAL"
	fi
	print_screen_output "$short_data"
}

print_system_data()
{
	local system_data=''
	local runlvl="$( runlevel | gawk '{ print $2 }' )"
	local memory="$( get_memory_data )"

	# Some code could look superfluous but BitchX doesn't like lines not ending in a newline. F*&k that bitch!
	# long_last=$( echo -ne "${C1}Processes${C2} ${processes}${CN} | ${C1}Uptime${C2} ${up_time}${CN} | ${C1}Memory${C2} ${MEM}${CN}" )
	system_data=$( create_print_line "Info:" "${C1}Processes${C2} ${processes} ${CN}| ${C1}Uptime${C2} ${up_time} ${CN}| ${C1}Memory${C2} ${memory}${CN}" )

	# this only triggers if no X data is present
	if [[ $B_X_RUNNING != 'true' ]];then
		system_data="${system_data} ${CN}| ${C1}Runlevel${C2} ${runlvl}${CN}"
	fi

	if [[ $SHOW_IRC -gt 0 ]];then
		system_data="${system_data} ${CN}| ${C1}Client${C2} ${IRC_CLIENT}${IRC_CLIENT_VERSION}${CN}"
	fi
	system_data="${system_data} ${CN}| ${C1}$SCRIPT_NAME ${C2}v:$SCRIPT_VERSION_NUMBER${CN}"

	if [[ $SCHEME -gt 0 ]];then
		system_data="${system_data} ${NORMAL}"
	fi
	print_screen_output "$system_data"
}

## main function to print out, master for all sub print functions.
## note that it passes local variable values on to its children,
## and in some cases, their children, with lspci_data
print_it_out()
{
	## note: remember that in bash, child functions inherit local variables
	local current_kernel=$( uname -a | gawk '{print $1,$3,$(NF-1)}' )
	local processes="$(( $( ps aux | wc -l ) - 1 ))"
	# set A_CPU_CORE_DATA
	get_cpu_core_count
	local cpu_core_count_string="${A_CPU_CORE_DATA[1]}"
	local cpu_core_count=${A_CPU_CORE_DATA[0]}
	local lspci_data='' ## only for verbose needed
	local up_time="$( get_uptime )"
	## assemble data for output
	# load A_HDD_DATA
	get_hdd_data_basic
	## note: if hdd_model is declared prior to use, whatever string you want inserted will
	## be inserted first. In this case, it's desirable to print out (x) before each disk found.
	local a_hdd_data_count=$(( ${#A_HDD_DATA[@]} - 1 ))
	IFS=","
	local a_hdd_basic_working=( ${A_HDD_DATA[$a_hdd_data_count]} )
	IFS="$ORIGINAL_IFS"
	local hdd_capacity=${a_hdd_basic_working[0]}
	local hdd_used=${a_hdd_basic_working[1]}
	# load A_CPU_DATA
	get_cpu_data

	IFS=","
	local a_cpu_working=(${A_CPU_DATA[0]})
	IFS="$ORIGINAL_IFS"
	local cpu_model="${a_cpu_working[0]}"

	case "$VERBOSITY_LEVEL" in
		0)	print_short_data
			;;
		*)	lspci_data="$( get_lspci_data )"
			print_intro_data
			print_cpu_data
			print_gfx_data
			if [[ $B_SHOW_SOUND == 'true' ]];then
				print_audio_data
			fi
			if [[ $VERBOSITY_LEVEL -ge 2 ]];then
				print_networking_data
			fi

			print_hard_disk_data
			print_system_data
			;;
	esac
}

########################################################################
#### SCRIPT EXECUTION
########################################################################
set_calculated_variables
# Check for dependencies before running any commands in this script! So yes, here!!
check_script_depends

get_start_client

# note: this only works if it's run from inside konversation as a script builtin or something
# only do this if inxi has been started as a konversation script, otherwise bypass this
if [[ $KONVI -eq 1 ]];then
	DCPORT="$1"
	DCSERVER="$2"
	DCTARGET="$3"
	shift 3
	# The section below is on request of Argonel from the Konversation developer team:
	# it sources config files like $HOME/.kde/share/apps/konversation/scripts/inxi.conf
	IFS=":"
	for kde_config in $( kde-config --path data )
	do
		if [[ -r ${kde_config}${KONVI_CFG} ]];then
			source "${kde_config}${KONVI_CFG}"
			break
		fi
	done
	IFS="$ORIGINAL_IFS"
fi
## leave this for debugging dcop stuff if we get that working
# 	print_screen_output "DCPORT: $DCPORT"
# 	print_screen_output "DCSERVER: $DCSERVER"
# 	print_screen_output "DCTARGET: $DCTARGET"

# "$@" passes every parameter separately quoted, "$*" passes all parameters as one quoted parameter.
get_parameters "$@"

# If no colorscheme was set in the parameter handling routine, then set the default scheme
if [[ $COLOR_SCHEME_SET != 'true' ]];then
	set_color_scheme "$DEFAULT_SCHEME"
fi

B_ALL_UP='true'
script_debugger "B_ALL_UP=true : inxi up and running.."

# then create the output
print_it_out

## last steps
if [[ $B_RUNNING_IN_SHELL == 'true' && $SCHEME -gt 0 ]];then
	echo -n "[0m"
fi

# weechat's executor plugin forced me to do this, and rightfully so, because else the exit code
# from the last command is taken..
exit 0
## note: this EOF is needed for smxi handling, this is what triggers the full download ok
###**EOF**###
