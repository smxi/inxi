#!/usr/bin/env perl
## infobash: Copyright (C) 2005-2007  Michiel de Boer a.k.a. locsmif
## inxi: Copyright (C) 2008-2018 Harald Hope
##       Additional features (C) Scott Rogers - kde, cpu info
## Further fixes (listed as known): Horst Tritremmel <hjt at sidux.com>
## Steven Barrett (aka: damentz) - usb audio patch; swap percent used patch
## Jarett.Stevens - dmidecode -M patch for older systems with the /sys
##
## License: GNU GPL v3 or greater
##
## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.
##
## If you don't understand what Free Software is, please read (or reread)
## this page: http://www.gnu.org/philosophy/free-sw.html

use strict;
use warnings;
# use diagnostics;
use 5.008;

use Cwd qw(abs_path); # qw(abs_path);#abs_path realpath getcwd
# use Data::Dump qw(dump); # damn, not in core modules
use Data::Dumper qw(Dumper); # print_r
use File::Basename;
use File::Find;
# use Getopt::Long qw(GetOptionsFromArray); # :config no_ignore_case bundling_values
use Getopt::Long qw(GetOptions);
# Note: default auto_abbrev is enabled, that's fine
Getopt::Long::Configure ('bundling', 'no_ignore_case', 
'no_getopt_compat', 'no_auto_abbrev','pass_through');
# use Net::FTP; # load this where it's used in debugger only
# use Path::Class; # maybe use, maybe not, for ls /sys
use POSIX qw(uname strftime ttyname);
use Sys::Hostname;
use Time::HiRes qw(gettimeofday tv_interval);
# use feature qw(state);

## INXI INFO ##
my $self_name='pinxi';
my $self_version='2.9.00';
my $self_date='2018-02-28';
my $self_patch='308-p';
## END INXI INFO ##

### INITIALIZE VARIABLES ###

## Self data
my ($self_path, $user_config_dir, $user_config_file,$user_data_dir);

## Debuggers
my $debug=0;
my ($end,$start,$t1,$t2,$t3,$fh_l,$log_file); # log file handle, file
my $t0 = [gettimeofday]; # let's start it right away

## Hashes
my ( %alerts, %client, %colors, %dl, %files, %rows, %system_files, %use );

## arrays
# ps_aux is full output, ps_cmd is only the last 10 to last
my (@app,@dmesg_boot,@dmi,@gpudata,@ifs,@ifs_bsd,@pci,@ps_aux,@ps_cmd,@sysctl,
@sysctl_battery,@sysctl_sensors,@sysctl_machine,@usb);
my @test = (0,0,0,0,0);

#my $opt_parser = Getopt::Long::Parser->new;

## Booleans
my ($b_arm,$b_console_irc,$b_display,$b_dmi,$b_dmidecode_force,$b_gpudata,$b_irc,
$b_log,$b_log_colors,$b_log_full,$b_mem,$b_pci,$b_root,$b_running_in_display,$b_sysctl,
$b_usb_check);
my ($b_update,$b_weather) = (1,1);

## System
my ($bsd_type,$language,$os) = ('','','');
my ($cpu_sleep,$dl_timeout,$limit,$ps_count,$usb_level) = (0.35,4,10,5,0);
my @paths = qw(/sbin /bin /usr/sbin /usr/bin /usr/X11R6/bin /usr/local/sbin /usr/local/bin);
$ENV{'PATH'} = 'sbin:/bin:/usr/sbin:/usr/bin:/usr/X11R6/bin:/usr/local/sbin:/usr/local/bin';
my $sensors_cpu_nu = 0;

## Tools
my ($display,$ftp_alt,$tty_session);
my $display_opt = '';

## Output
my $extra = 0;# supported values: 0-3
my $filter_string = '<filter>';
my $line1 = "----------------------------------------------------------------------\n";
my $line2 = "======================================================================\n";
my $line3 = "----------------------------------------\n";
my $output_type = 'screen';
my $prefix = 0; # for the primiary row hash key prefix

# these will assign a separator to non irc states. Important! Using ':' can 
# trigger stupid emoticon. Note: SEP1/SEP2 from short form not used anymore.
# behaviors in output on IRC, so do not use those.
my %sep = ( 
's1-irc' => ':',
's1-console' => ':',
's2-irc' => '',
's2-console' => ':',
);

my %show = ('host' => 1);

my %size = (
'console' => 115,
# Default indentation level. NOTE: actual indent is 1 greater to allow for 
# spacing
'indent' => 11,
'indent-min' => 90,
'irc' => 100, # shorter because IRC clients have nick  lists etc
'max' => 0,
'no-display' => 130,
# these will be set dynamically in set_display_width()
'term' => 80,
'term-lines' => 100,
);

## debug temp tools
$client{'test-konvi'} = 0;

########################################################################
#### STARTUP
########################################################################

#### -------------------------------------------------------------------
#### MAIN
#### -------------------------------------------------------------------

sub main {
# 	print Dumper \@ARGV;
	eval $start if $b_log;
	initialize();
	## use for start client debugging
	# $debug = 10;
	# set_debugger(); # for debugging of konvi issues
	#my $ob_start = StartClient->new();
	#$ob_start->get_client_data();
	StartClient::get_client_data();
	#print_line("path: $ENV{'PATH'}");
	# print_line( Dumper \%client);
	get_options();
	set_debugger(); # right after so it's set
	check_tools();
	set_colors();
	set_sep();
	# print download_file('stdout','https://') . "\n";
	generate_lines();
	eval $end if $b_log;
	cleanup();
	# weechat's executor plugin forced me to do this, and rightfully so, 
	# because else the exit code from the last command is taken..
	exit 0;
}

#### -------------------------------------------------------------------
#### INITIALIZE
#### -------------------------------------------------------------------

sub initialize {
	set_os();
	# set_path();
	set_user_paths();
	set_basics();
	system_files('set');
	get_configs();
	# set_downloader();
	set_display_width('live');
}

sub check_tools {
	my ($action,$program,$message,@data,%commands,%hash);
	if ( $b_dmi ){
		$action = 'use';
		if ($program = check_program('dmidecode')) {
			my $result = system("$program -t chassis >/dev/null 2>&1");
			if (!$result){
				if ($b_root) {
					@data = grabber("$program --type chassis");
					if ( grep { $_ =~ /No SMBIOS/i } @data ){
						$action = 'smbios';
					}
				}
			}
			elsif ($result){
				$action = 'permissions';
			}
		}
		else {
			$action = 'missing';
		}
		%hash = (
		'dmidecode' => {
		'action' => $action,
		'missing' => 'Required program dmidecode not available',
		'permissions' => 'Unable to run dmidecode. Are you root?',
		'smbios' => 'No SMBIOS data for dmidecode to process',
		},
		);
		%alerts = (%alerts, %hash);
	}
	if ( $show{'graphic'} ){
		foreach ( qw(xrandr xdpyinfo glxinfo) ){
			$action = 'use';
			if (check_program($_)) {
				if (!$b_display && !defined $display){
					if (!defined $display){$action = 'in-console' }
				}
			}
			else {
				$action = 'missing';
				# --display out of x override happens before this, so we need to retain that switch
				$show{'display-data'} = ( !$b_display && $show{'display-data'} == 2 ) ? 1 : 0;
			}
			%hash = (
			$_ => {
			'action' => $action,
			'missing' => "Missing: $_ - continuing in non desktop mode. Check --recommends",
			'in-console' => 'See --display option to get advanced graphics data',
			},
			);
			%alerts = (%alerts, %hash);
		}
	}
	# note: gnu/linux has sysctl so it may be used that for something if present
	# there is lspci for bsds so doesn't hurt to check it
	if ($b_pci || $b_sysctl){
		if (!$bsd_type){
			if ($b_pci ){
				%hash = ('lspci' => '-n',);
				%commands = (%commands,%hash);
			}
		}
		else {
			if ($b_pci ){
				%hash = ('pciconf' => '-l',);
				%commands = (%commands,%hash);
			}
			if ($b_sysctl ){
				# note: there is a case of kernel.osrelease but it's a linux distro
				%hash = ('sysctl' => 'kern.osrelease',);
				%commands = (%commands,%hash);
			}
		}
		foreach ( keys %commands ){
			$action = 'use';
			if ($program = check_program($_)) {
				# > 0 means error in shell
				#my $cmd = "$program $commands{$_} >/dev/null";
				#print "$cmd\n";
				$action = 'permissions' if system("$program $commands{$_} >/dev/null 2>&1");
			}
			else {
				$action = 'missing';
			}
			%hash = (
			$_ => {
			'action' => $action,
			'missing' => "Missing system tool: $_. Output will be incomplete",
			'permissions' => "Unable to run $_. Root required?",
			},
			);
			%alerts = (%alerts, %hash);
		}
	}
	%commands = ();
	if ( $show{'sensor'} ){
		%commands = ('sensors' => 'linux',);
	}
	# note: lsusb ships in FreeBSD ports sysutils/usbutils
	if ( $usb_level ){
		%hash = ('lsusb' => 'all',);
		%commands = (%commands,%hash);
		%hash = ('usbdevs' => 'bsd',);
		%commands = (%commands,%hash);
	}
	if ($show{'ip'} || ($bsd_type && $show{'network-advanced'})){
		%hash = (
		'ip' => 'linux',
		'ifconfig' => 'all',
		);
		%commands = (%commands,%hash);
	}
	foreach ( keys %commands ){
		$action = 'use';
		$message = 'Present and working';
		if ( ($commands{$_} eq 'linux' && $os ne 'linux' ) || ($commands{$_} eq 'bsd' && $os eq 'linux' ) ){
			$message = "No " . ucfirst($os) . " support. Is a comparable $_ tool available?";
			$action = 'platform';
		}
		elsif (!check_program($_)){
			$message = "Required tool $_ not installed. Check --recommends";
			$action = 'missing';
		}
		%hash = (
		$_ => {
		'action' => $action,
		'missing' => $message,
		'platform' => $message,
		},
		);
		%alerts = (%alerts, %hash);
	}
	# print Dumper \%alerts;
}
sub set_basics {
	### LOCALIZATION - DO NOT CHANGE! ###
	# set to default LANG to avoid locales errors with , or .
	# Make sure every program speaks English.
	$ENV{'LANG'}='C';
	$ENV{'LC_ALL'}='C';
	# remember, perl uses the opposite t/f return as shell!!!
	$b_irc = ( system('tty>/dev/null') ) ? 1 : 0;
	# print "birc: $b_irc\n";
	$b_display = ( $ENV{'DISPLAY'} ) ? 1 : 0;
	$b_root = ( $ENV{'HOME'} eq '/root' ) ? 1 : 0;
	$dl{'dl'} = 'curl';
	$dl{'curl'} = 1;
	$dl{'tiny'} = 1; # note: tiny is actually tested for in set_downloader
	$dl{'wget'} = 1;
	$dl{'fetch'} = 1;
	$client{'console-irc'} = 0;
	$client{'dcop'} = (check_program('dcop')) ? 1 : 0;
	$client{'qdbus'} = (check_program('qdbus')) ? 1 : 0;
	$client{'konvi'} = 0;
	$client{'name'} = '';
	$client{'name-print'} = '';
	$client{'version'} = '';
	$colors{'default'} = 2;
	$show{'display-data'} = ( $b_display ) ? 1 : 0;
}

# args: $1 - default OR override default cols max integer count. $_[0]
# is the display width override.
sub set_display_width {
	my ($width) = @_;
	if ( $width eq 'live' ){
		## sometimes tput will trigger an error (mageia) if irc client
		if ( ! $b_irc ){
			if ( check_program('tput') ) {
				# trips error if use qx()...
				chomp($size{'term'}=qx{tput cols});
				chomp($size{'term-lines'}=qx{tput lines});
				$size{'term-cols'} = $size{'term'};
			}
			# print "tc: $size{'term'} cmc: $size{'console'}\n";
			# double check, just in case it's missing functionality or whatever
			if ( $size{'term'} == 0 || $size{'term'} !~ /\d/ ){ 
				$size{'term'}=80;
				# we'll be using this for terminal dimensions later so don't set default.
				# $size{'term-lines'}=100;
			}
		}
		# this lets you set different size for in or out of display server
		# if ( ! $b_running_in_display && $configs{'COLS_MAX_NO_DISPLAY'} != 0 ){
		# 	$size{'console'}=$configs{'COLS_MAX_NO_DISPLAY'};
		# }
		# term_cols is set in top globals, using tput cols
		# print "tc: $size{'term'} cmc: $size{'console'}\n";
		if ( $size{'term'} < $size{'console'} ){
			$size{'console'}=$size{'term'};
		}
		# adjust, some terminals will wrap if output cols == term cols
		$size{'console'}=( $size{'console'} - 2 );
		# echo cmc: $size{'console'}
		# comes after source for user set stuff
		if ( ! $b_irc ){
			$size{'max'}=$size{'console'};
		}
		else {
			$size{'max'}=$size{'irc'};
		}
	}
	else {
		$size{'max'}=$width;
	}
	# print "tc: $size{'term'} cmc: $size{'console'} cm: $size{'max'}\n";
}

sub set_os {
	my @uname = uname();
	$os = lc($uname[0]);
	$b_arm = 1 if $uname[-1] =~ /arm/i;
	if ( $os =~ /(bsd|dragonfly|darwin)/ ){
		if ( $os =~ /openbsd/ ){
			$os = 'openbsd';
		}
		elsif ($os =~ /darwin/){
			$os = 'darwin';
		}
		if ($os =~ /kfreebsd/){
			$bsd_type = 'debian-bsd';
		}
		else {
			$bsd_type = 'bsd';
		}
	}
}
# not used, leaving for now in case something unaccounted happens.
# this data is now hard set top of program
sub set_path {
	my $added_paths = '';
	# Extra path variable to make execute failures less likely, merged below
	my @path = split ':', $ENV{'PATH'};
	#print "PATH=$ENV{'PATH'}\n";
	# Create a difference of $PATH and $extra_paths and add that to $PATH:
	foreach (@paths) {
		if ( ! grep (/$_/, @path) ){
			$added_paths .= ":$_";
			# print "$added_paths\n";
		}
	}
	$ENV{'PATH'} .= $added_paths;
	# print "PATH=$ENV{'PATH'}\n";
	##/bin/sh -c 'echo "PATH in subshell=\"$PATH\""'
}

sub set_sep {
	if ( $b_irc ){
		# too hard to read if no colors, so force that for users on irc
		if ($colors{'scheme'} == 0 ){
			$sep{'s1'} = $sep{'s1-console'};
			$sep{'s2'} = $sep{'s2-console'};
		}
		else {
			$sep{'s1'} = $sep{'s1-irc'};
			$sep{'s2'} = $sep{'s2-irc'};
		}
	}
	else {
		$sep{'s1'} = $sep{'s1-console'};
		$sep{'s2'} = $sep{'s2-console'};
	}
}

sub set_user_paths {
	my ( $b_conf, $b_data );
	# this needs to be set here because various options call the parent 
	# initialize function directly.
	$self_path = $0;
	$self_path =~ s/[^\/]+$//;
	
	if ( defined $ENV{'XDG_CONFIG_HOME'} && $ENV{'XDG_CONFIG_HOME'} ){
		$user_config_dir=$ENV{'XDG_CONFIG_HOME'};
		$b_conf=1;
	}
	elsif ( -d "$ENV{'HOME'}/.config" ){
		$user_config_dir="$ENV{'HOME'}/.config";
		$b_conf=1;
	}
	else {
		$user_config_dir="$ENV{'HOME'}/.$self_name";
	}
	if ( defined $ENV{'XDG_DATA_HOME'} && $ENV{'XDG_DATA_HOME'} ){
		$user_data_dir="$ENV{'XDG_DATA_HOME'}/$self_name";
		$b_data=1;
	}
	elsif ( -d "$ENV{'HOME'}/.local/share" ){
		$user_data_dir="$ENV{'HOME'}/.local/share/$self_name";
		$b_data=1;
	}
	else {
		$user_data_dir="$ENV{'HOME'}/.$self_name";
	}
	# note, this used to be created/checked in specific instance, but we'll just do it
	# universally so it's done at script start.
	if ( ! -d $user_data_dir ){
		mkdir $user_data_dir;
		system "echo", "Made: $user_data_dir";
	}
	if ( $b_conf && -f "$ENV{'HOME'}/.$self_name/$self_name.conf" ){
		#system 'mv', "-f $ENV{'HOME'}/.$self_name/$self_name.conf", $user_config_dir;
		# print "WOULD: Moved $self_name.conf from $ENV{'HOME'}/.$self_name to $user_config_dir\n";
	}
	if ( $b_data && -d "$ENV{'HOME'}/.$self_name" ){
		#system 'mv', '-f', "$ENV{'HOME'}/.$self_name/*", $user_data_dir;
		#system 'rm', '-Rf', "$ENV{'HOME'}/.$self_name";
		# print "WOULD: Moved data dir $ENV{'HOME'}/.$self_name to $user_data_dir\n";
	}
	$log_file="$user_data_dir/$self_name.log";
	#system 'echo', "$ENV{'HOME'}/.$self_name/* $user_data_dir";
	# print "scd: $user_config_dir sdd: $user_data_dir \n";
}
# args: 1: set|hash key to return either null or path
sub system_files {
	my ($file) = @_;
	if ( $file eq 'set'){
		%files = (
		'asound-cards' => '/proc/asound/cards',
		'asound-modules' => '/proc/asound/modules',
		'asound-version' => '/proc/asound/version',
		'cpuinfo' => '/proc/cpuinfo',
		'dmesg-boot' => '/var/run/dmesg.boot',
		'lsb-release' => '/etc/lsb-release',
		'mdstat' => '/proc/mdstat',
		'meminfo' => '/proc/meminfo',
		'modules' => '/proc/modules',
		'mounts' => '/proc/mounts',
		'os-release' => '/etc/os-release',
		'partitions' => '/proc/partitions',
		'scsi' => '/proc/scsi/scsi',
		'version' => '/proc/version',
		'xorg-log' => '/var/log/Xorg.0.log'
		);
		foreach ( keys %files ){
			$system_files{$_} = ( -e $files{$_} ) ? $files{$_} : '';
		}
		if ( ! $system_files{'xorg-log'} && check_program('xset') ){
			my $data = qx(xset q 2>/dev/null);
			foreach ( split /\n/, $data){
				if ($_ =~ /Log file/i){
					$system_files{'xorg-log'} = get_piece($_,3);
					last;
				}
			}
		}
	}
	else {
		return $system_files{$file};
	}
}
########################################################################
#### UTILITIES
########################################################################

#### -------------------------------------------------------------------
#### COLORS
#### -------------------------------------------------------------------

## arg: 1 - the type of action, either integer, count, or full
sub get_color_scheme {
	my ($type) = @_;
	eval $start if $b_log;
	my @color_schemes = (
	[qw(EMPTY EMPTY EMPTY )],
	[qw(NORMAL NORMAL NORMAL )],
	# for dark OR light backgrounds
	[qw(BLUE NORMAL NORMAL)],
	[qw(BLUE RED NORMAL )],
	[qw(CYAN BLUE NORMAL )],
	[qw(DCYAN NORMAL NORMAL)],
	[qw(DCYAN BLUE NORMAL )],
	[qw(DGREEN NORMAL NORMAL )],
	[qw(DYELLOW NORMAL NORMAL )],
	[qw(GREEN DGREEN NORMAL )],
	[qw(GREEN NORMAL NORMAL )],
	[qw(MAGENTA NORMAL NORMAL)],
	[qw(RED NORMAL NORMAL)],
	# for light backgrounds
	[qw(BLACK DGREY NORMAL)],
	[qw(DBLUE DGREY NORMAL )],
	[qw(DBLUE DMAGENTA NORMAL)],
	[qw(DBLUE DRED NORMAL )],
	[qw(DBLUE BLACK NORMAL)],
	[qw(DGREEN DYELLOW NORMAL )],
	[qw(DYELLOW BLACK NORMAL)],
	[qw(DMAGENTA BLACK NORMAL)],
	[qw(DCYAN DBLUE NORMAL)],
	# for dark backgrounds
	[qw(WHITE GREY NORMAL)],
	[qw(GREY WHITE NORMAL)],
	[qw(CYAN GREY NORMAL )],
	[qw(GREEN WHITE NORMAL )],
	[qw(GREEN YELLOW NORMAL )],
	[qw(YELLOW WHITE NORMAL )],
	[qw(MAGENTA CYAN NORMAL )],
	[qw(MAGENTA YELLOW NORMAL)],
	[qw(RED CYAN NORMAL)],
	[qw(RED WHITE NORMAL )],
	[qw(BLUE WHITE NORMAL)],
	# miscellaneous
	[qw(RED BLUE NORMAL )],
	[qw(RED DBLUE NORMAL)],
	[qw(BLACK BLUE NORMAL)],
	[qw(BLACK DBLUE NORMAL)],
	[qw(NORMAL BLUE NORMAL)],
	[qw(BLUE MAGENTA NORMAL)],
	[qw(DBLUE MAGENTA NORMAL)],
	[qw(BLACK MAGENTA NORMAL)],
	[qw(MAGENTA BLUE NORMAL)],
	[qw(MAGENTA DBLUE NORMAL)],
	);
	if ($type eq 'count' ){
		return scalar @color_schemes;
	}
	if ($type eq 'full' ){
		return @color_schemes;
	}
	else {
		return @{$color_schemes[$type]};
		# print Dumper $color_schemes[$scheme_nu];
	}
	eval $end if $b_log;
}

sub set_color_scheme {
	eval $start if $b_log;
	my ($scheme) = @_;
	$colors{'scheme'} = $scheme;
	my $index = ( $b_irc ) ? 1 : 0; # defaults to non irc
	
	# NOTE: qw(...) kills the escape, it is NOT the same as using 
	# Literal "..", ".." despite docs saying it is.
	my %color_palette = (
	'EMPTY' => [ '', '' ],
	'DGREY' => [ "\e[1;30m", "\x0314" ],
	'BLACK' => [ "\e[0;30m", "\x0301" ],
	'RED' => [ "\e[1;31m", "\x0304" ],
	'DRED' => [ "\e[0;31m", "\x0305" ],
	'GREEN' => [ "\e[1;32m", "\x0309" ],
	'DGREEN' => [ "\e[0;32m", "\x0303" ],
	'YELLOW' => [ "\e[1;33m", "\x0308" ],
	'DYELLOW' => [ "\e[0;33m", "\x0307" ],
	'BLUE' => [ "\e[1;34m", "\x0312" ],
	'DBLUE' => [ "\e[0;34m", "\x0302" ],
	'MAGENTA' => [ "\e[1;35m", "\x0313" ],
	'DMAGENTA' => [ "\e[0;35m", "\x0306" ],
	'CYAN' => [ "\e[1;36m", "\x0311" ],
	'DCYAN' => [ "\e[0;36m", "\x0310" ],
	'WHITE' => [ "\e[1;37m", "\x0300" ],
	'GREY' => [ "\e[0;37m", "\x0315" ],
	'NORMAL' => [ "\e[0m", "\x03" ],
	);
	my @scheme = get_color_scheme($colors{'scheme'});
	$colors{'c1'} = $color_palette{$scheme[0]}[$index];
	$colors{'c2'} = $color_palette{$scheme[1]}[$index];
	$colors{'cn'} = $color_palette{$scheme[2]}[$index];
	# print Dumper \@scheme;
	# print "$colors{'c1'}here$colors{'c2'} we are!$colors{'cn'}\n";
	eval $end if $b_log;
}

sub set_colors {
	eval $start if $b_log;
	# it's already been set with -c 0-43
	if ( exists $colors{'c1'} ){
		return 1;
	}
	# This let's user pick their color scheme. For IRC, only shows the color schemes, 
	# no interactive. The override value only will be placed in user config files. 
	# /etc/inxi.conf can also override
	if (exists $colors{'selector'}){
		my $ob_selector = SelectColors->new($colors{'selector'});
		$ob_selector->select_schema();
		return 1;
	}
	# set the default, then override as required
	my $color_scheme = $colors{'default'};
	# these are set in user configs
	if (defined $colors{'global'}){
		$color_scheme = $colors{'global'};
	}
	else {
		if ( $b_irc ){
			if (defined $colors{'irc-virt-term'} && $b_display && $client{'console-irc'}){
				$color_scheme = $colors{'irc-virt-term'};
			}
			elsif (defined $colors{'irc-console'} && !$b_display){
				$color_scheme = $colors{'irc-console'};
			}
			elsif ( defined $colors{'irc-gui'}) {
				$color_scheme = $colors{'irc-gui'};
			}
		}
		else {
			if (defined $colors{'console'} && !$b_display){
				$color_scheme = $colors{'console'};
			}
			elsif (defined $colors{'virt-term'}){
				$color_scheme = $colors{'virt-term'};
			}
		}
	}
	set_color_scheme($color_scheme);
	eval $end if $b_log;
}

#### -------------------------------------------------------------------
#### CONFIGS
#### -------------------------------------------------------------------

sub check_config_file {
	$user_config_file = "$user_config_dir/$self_name.conf";
	if ( ! -f $user_config_file ){
		open( my $fh, '>', $user_config_file ) or error_handler('create', $user_config_file, $!);
	}
}

sub get_configs {
	my (@configs) = @_;
	my ($key, $val,@config_files);
	if (!@configs){
		@config_files = (
		qq(/etc/$self_name.conf), 
		qq($user_config_dir/$self_name.conf)
		);
	}
	else {
		@config_files = (@configs);
	}
	# Config files should be passed in an array as a param to this function.
	# Default intended use: global @CONFIGS;
	foreach (@config_files) {
		next unless open (my $fh, '<', "$_");
		while (<$fh>) {
			chomp;
			s/#.*//;
			s/^\s+//;
			s/\s+$//;
			s/'|"//g;
			s/true/1/; # switch to 1/0 perl boolean
			s/false/0/; # switch to 1/0 perl boolean
			next unless length;
			($key, $val) = split(/\s*=\s*/, $_, 2);
			get_config_item($key,$val);
			# print "f: $file key: $key val: $val\n";
		}
		close $fh;
	}
}

# args: 0: key; 1: value
sub get_config_item {
	my ($key,$val) = @_;
	if ($key eq 'B_ALLOW_UPDATE') {$b_update = $val}
	elsif ($key eq 'B_ALLOW_WEATHER') {$b_weather = $val}
	elsif ($key eq 'CPU_SLEEP') {$cpu_sleep = $val}
	elsif ($key eq 'DL_TIMEOUT') {$dl_timeout = $val}
	elsif ($key eq 'DOWNLOADER') {
	if ($val =~ /^(curl|fetch|ftp|perl|wget)$/){
		# this dumps all the other data and resets %dl for only the
		# desired downloader.
		$val = set_perl_downloader($val);
		%dl = ('dl' => $val, $val => 1);
	}}
	elsif ($key eq 'FILTER_STRING') {$filter_string = $val}
	elsif ($key eq 'LANGUAGE') {$language = $val}
	elsif ($key eq 'LIMIT') {$limit = $val}
	elsif ($key eq 'OUTPUT_TYPE') {$output_type = $val if $val =~ /^csv|json|screen|xml/}
	elsif ($key eq 'PS_COUNT') {$ps_count = $val }
	elsif ($key eq 'SENSORS_CPU_NO') {$sensors_cpu_nu = $val}
	# layout
	elsif ($key eq 'CONSOLE_COLOR_SCHEME') {$colors{'console'} = $val}
	elsif ($key eq 'GLOBAL_COLOR_SCHEME') {$colors{'global'} = $val}
	elsif ($key eq 'IRC_COLOR_SCHEME') {$colors{'irc-gui'} = $val}
	elsif ($key eq 'IRC_CONS_COLOR_SCHEME') {$colors{'irc-console'} = $val}
	elsif ($key eq 'IRC_X_TERM_COLOR_SCHEME') {$colors{'irc-virt-term'} = $val}
	elsif ($key eq 'VIRT_TERM_COLOR_SCHEME') {$colors{'virt-term'} = $val}
	# note: not using the old short SEP1/SEP2
	elsif ($key eq 'SEP1_IRC') {$sep{'s1-irc'} = $val}
	elsif ($key eq 'SEP1_CONSOLE') {$sep{'s1-console'} = $val}
	elsif ($key eq 'SEP[23]_IRC') {$sep{'s2-irc'} = $val}
	elsif ($key eq 'SEP[23]_CONSOLE') {$sep{'s2-console'} = $val}
	
	# size
	elsif ($key eq 'COLS_MAX_CONSOLE') {$size{'console'} = $val}
	elsif ($key eq 'COLS_MAX_IRC') {$size{'irc'} = $val}
	elsif ($key eq 'COLS_MAX_NO_DISPLAY') {$size{'no-display'} = $val}
	#  print "mc: key: $key val: $val\n";
	# print Dumper (keys %size) . "\n";
}

## SelectColors
{
package SelectColors;

# use warnings;
# use strict;
# use diagnostics;
# use 5.008;

my (@data,@rows,%configs,%status);
my ($type,$w_fh);
my $safe_color_count = 12; # null/normal + default color group
my $count = 0;

# args: 1 - type
sub new {
	my $class = shift;
	($type) = @_;
	my $self = {};
	return bless $self, $class;
}
sub select_schema {
	eval $start if $b_log;
	assign_selectors();
	main::set_color_scheme(0);
	set_status();
	start_selector();
	create_color_selections();
	if (! $b_irc ){
		main::check_config_file();
		get_selection();
	}
	else {
		print_irc_message();
	}
	eval $end if $b_log;
}

sub set_status {
	$status{'console'} = (defined $colors{'console'}) ? "Set: $colors{'console'}" : 'Unset';
	$status{'virt-term'} = (defined $colors{'virt-term'}) ? "Set: $colors{'virt-term'}" : 'Unset';
	$status{'irc-console'} = (defined $colors{'irc-console'}) ? "Set: $colors{'irc-console'}" : 'Unset';
	$status{'irc-gui'} = (defined $colors{'irc-gui'}) ? "Set: $colors{'irc-gui'}" : 'Unset';
	$status{'irc-virt-term'} = (defined $colors{'irc-virt-term'}) ? "Set: $colors{'irc-virt-term'}" : 'Unset';
	$status{'global'} = (defined $colors{'global'}) ? "Set: $colors{'global'}" : 'Unset';
}

sub assign_selectors {
	if ($type == 94){
		$configs{'variable'} = 'CONSOLE_COLOR_SCHEME';
		$configs{'selection'} = 'console';
	}
	elsif ($type == 95){
		$configs{'variable'} = 'VIRT_TERM_COLOR_SCHEME';
		$configs{'selection'} = 'virt-term';
	}
	elsif ($type == 96){
		$configs{'variable'} = 'IRC_COLOR_SCHEME';
		$configs{'selection'} = 'irc-gui';
	}
	elsif ($type == 97){
		$configs{'variable'} = 'IRC_X_TERM_COLOR_SCHEME';
		$configs{'selection'} = 'irc-virt-term';
	}
	elsif ($type == 98){
		$configs{'variable'} = 'IRC_CONS_COLOR_SCHEME';
		$configs{'selection'} = 'irc-console';
	}
	elsif ($type == 99){
		$configs{'variable'} = 'GLOBAL_COLOR_SCHEME';
		$configs{'selection'} = 'global';
	}
}
sub start_selector {
	my $whoami = getpwuid($<) || "unknown???";
	if ( ! $b_irc ){
		@data = (
		[ 0, '', '', "Welcome to $self_name! Please select the default 
		$configs{'selection'} color scheme."],
		);
	}
	@rows = (
	[ 0, '', '', "Because there is no way to know your $configs{'selection'}
	foreground/background colors, you can set your color preferences from 
	color scheme option list below:"],
	[ 0, '', '', "0 is no colors; 1 is neutral."],
	[ 0, '', '', "After these, there are 4 sets:"],
	[ 0, '', '', "1-dark^or^light^backgrounds; 2-light^backgrounds; 
	3-dark^backgrounds; 4-miscellaneous"],
	[ 0, '', '', ""],
	);
	push @data, @rows;
	if ( ! $b_irc ){
		@rows = (
		[ 0, '', '', "Please note that this will set the $configs{'selection'} 
		preferences only for user: $whoami"],
		);
		push @data, @rows;
	}
	@rows = (
	[ 0, '', '', "$line1"],
	);
	push @data, @rows;
	main::print_basic(@data); 
	@data = ();
}
sub create_color_selections {
	my $spacer = '^^'; # printer removes double spaces, but replaces ^ with ' '
	$count = ( main::get_color_scheme('count') - 1 );
	for my $i (0 .. $count){
		if ($i > 9){
			$spacer = '^';
		}
		if ($configs{'selection'} =~ /^global|irc-gui|irc-console|irc-virt-term$/ && $i > $safe_color_count ){
			last;
		}
		main::set_color_scheme($i);
		@rows = (
		[0, '', '', "$i)$spacer$colors{'c1'}Card:$colors{'c2'}^nVidia^GT218 
		$colors{'c1'}Display^Server$colors{'c2'}^x11^(X.Org^1.7.7)$colors{'cn'}"],
		);
		push @data, @rows;
	}
	main::print_basic(@data); 
	@data = ();
	main::set_color_scheme(0);
}
sub get_selection {
	my $number = $count + 1;
	@data = (
	[0, '', '', ($number++) . ")^Remove all color settings. Restore $self_name default."],
	[0, '', '', ($number++) . ")^Continue, no changes or config file setting."],
	[0, '', '', ($number++) . ")^Exit, use another terminal, or set manually."],
	[0, '', '', "$line1"],
	[0, '', '', "Simply type the number for the color scheme that looks best to your 
	eyes for your $configs{'selection'} settings and hit <ENTER>. NOTE: You can bring this 
	option list up by starting $self_name with option: -c plus one of these numbers:"],
	[0, '', '', "94^-^console,^not^in^desktop^-^$status{'console'}"],
	[0, '', '', "95^-^terminal,^desktop^-^$status{'virt-term'}"],
	[0, '', '', "96^-^irc,^gui,^desktop^-^$status{'irc-gui'}"],
	[0, '', '', "97^-^irc,^desktop,^in^terminal^-^$status{'irc-virt-term'}"],
	[0, '', '', "98^-^irc,^not^in^desktop^-^$status{'irc-console'}"],
	[0, '', '', "99^-^global^-^$status{'global'}"],
	[0, '', '',  ""],
	[0, '', '', "Your selection(s) will be stored here: $user_config_file"],
	[0, '', '', "Global overrides all individual color schemes. Individual 
	schemes remove the global setting."],
	[0, '', '', "$line1"],
	);
	main::print_basic(@data); 
	@data = ();
	my $response = <STDIN>;
	chomp $response;
	if ($response =~ /[^0-9]/ || $response > ($count + 3)){
		@data = (
		[0, '', '', "Error - Invalid Selection. You entered this: $response. Hit <ENTER> to continue."],
		[0, '', '',  "$line1"],
		);
		main::print_basic(@data); 
		my $response = <STDIN>;
		start_selector();
		create_color_selections();
		get_selection();
	}
	else {
		process_selection($response);
	}
}
sub process_selection {
	my $response = shift;
	if ($response == ($count + 3) ){
		@data = ([0, '', '', "Ok, exiting $self_name now. You can set the colors later."],);
		main::print_basic(@data); 
		exit 1;
	}
	elsif ($response == ($count + 2)){
		@data = ([0, '', '', "Ok, continuing $self_name unchanged. You can set the colors 
		anytime by starting with: -c 95 to 99"],);
		main::print_basic(@data); 
		if ( defined $colors{'console'} && !$b_display ){
			main::set_color_scheme($colors{'console'});
		}
		if ( defined $colors{'virt-term'} ){
			main::set_color_scheme($colors{'virt-term'});
		}
		else {
			main::set_color_scheme($colors{'default'});
		}
	}
	elsif ($response == ($count + 1)){
		@data = ([0, '', '', "Removing all color settings from config file now..."],);
		main::print_basic(@data); 
		delete_all_config_colors();
		main::set_color_scheme($colors{'default'});
	}
	else {
		main::set_color_scheme($response);
		@data = ([0, '', '', "Updating config file for $configs{'selection'} color scheme now..."],);
		main::print_basic(@data); 
		if ($configs{'selection'} eq 'global'){
			delete_all_config_colors();
		}
		set_config_color_scheme($response);
	}
}
sub delete_all_config_colors {
	my @file_lines = main::reader( $user_config_file );
	open( $w_fh, '>', $user_config_file ) or error_handler('open', $user_config_file, $!);
	foreach ( @file_lines ) { 
		if ( $_ !~ /^(CONSOLE_COLOR_SCHEME|GLOBAL_COLOR_SCHEME|IRC_COLOR_SCHEME|IRC_CONS_COLOR_SCHEME|IRC_X_TERM_COLOR_SCHEME|VIRT_TERM_COLOR_SCHEME)/){
			print {$w_fh} "$_"; 
		}
	} 
	close $w_fh;
}
sub set_config_color_scheme {
	my $value = shift;
	my @file_lines = main::reader( $user_config_file );
	my $b_found = 0;
	open( $w_fh, '>', $user_config_file ) or error_handler('open', $user_config_file, $!);
	foreach ( @file_lines ) { 
		if ( $_ =~ /^$configs{'variable'}/ ){
			$_ = "$configs{'variable'}=$value\n";
			$b_found = 1;
		}
		print $w_fh "$_";
	}
	if (! $b_found ){
		print $w_fh "$configs{'variable'}=$value\n";
	}
	close $w_fh;
}

sub print_irc_message {
	@data = (
	[ 0, '', '', "$line1"],
	[ 0, '', '', "After finding the scheme number you like, simply run this again
	in a terminal to set the configuration data file for your irc client. You can 
	set color schemes for the following: start inxi with -c plus:"],
	[ 0, '', '', "94 (console,^not^in^desktop^-^$status{'console'})"],
	[ 0, '', '', "95 (terminal, desktop^-^$status{'virt-term'})"],
	[ 0, '', '', "96 (irc,^gui,^desktop^-^$status{'irc-gui'})"],
	[ 0, '', '', "97 (irc,^desktop,^in terminal^-^$status{'irc-virt-term'})"],
	[ 0, '', '', "98 (irc,^not^in^desktop^-^$status{'irc-console'})"],
	[ 0, '', '', "99 (global^-^$status{'global'})"]
	);
	main::print_basic(@data); 
	exit 1;
}

}

#### -------------------------------------------------------------------
#### DEBUGGERS
#### -------------------------------------------------------------------


# called in the initial -@ 10 script args setting so we can get logging 
# as soon as possible # will have max 3 files, inxi.log, inxi.1.log, 
# inxi.2.log
sub begin_logging {
	return 1 if $fh_l; # if we want to start logging for testing before options
	my $log_file_2="$user_data_dir/$self_name.1.log";
	my $log_file_3="$user_data_dir/$self_name.2.log";
	my $data = '';
	$end='main::log_data("fe", (caller(1))[3], "");';
	$start='main::log_data("fs", (caller(1))[3], @_);';
	#require Time::HiRes;
	#import Time::HiRes;
	$t3 = tv_interval ($t0, [gettimeofday]);
	my $now = strftime "%Y-%m-%d %H:%M:%S", localtime;
	# do the rotation if logfile exists
	if ( -f $log_file ){
		# copy if present second to third
		if ( -f $log_file_2 ){
			rename $log_file_2, $log_file_3 or error_handler('rename', "$log_file_2 -> $log_file_3", "$!");
		}
		# then copy initial to second
		rename $log_file, $log_file_2 or error_handler('rename', "$log_file -> $log_file_2", "$!");
	}
	# now create the logfile
	# print "Opening log file for reading: $log_file\n";
	open $fh_l, '>', $log_file or error_handler(4, $log_file, "$!");
	# and echo the start data
	$data = $line2;
	$data = $data . "START $self_name LOGGING:\n";
	$data = $data . "$now\n";
	$data = $data . "Elapsed since start: $t3\n";
	$data = $data .  $line2;
	
	print $fh_l $data;
}

# NOTE: no logging available until get_parameters is run, since that's what 
# sets logging # in order to trigger earlier logging manually set $b_log
# to true in top variables.
# arg: $one alone: logs data; $two with or without $three logs func start/end.
# arg: $one type (fs/fe/cat/raw) or logged data; 
# [$two is function name; [$three - function args]]
sub log_data {
	return if ! $b_log;
	my ($one, $two, @args) = @_;
	my $args = '';
	my $data = '';
	my $spacer = '   ';
	# print "1: $one 2: $two 3: $three\n";
	if ($one eq 'fs') {
		if (defined $args[0]){
			$args = "\n${spacer}Args: " . join '; ', @args;
		}
		else {
			$args = "\n${spacer}Args: None";
		}
		# $t1 = [gettimeofday];
		$t3 = tv_interval ($t0, [gettimeofday]);
		$data = "Start: Function: $two$args\n${spacer}Elapsed: $t3\n";
		$spacer='';
	}
	elsif ( $one eq 'fe') {
		$t3 = tv_interval ($t0, [gettimeofday]);
		$data = "${spacer}Elapsed: $t3\nEnd: Function: $two\n";
		$spacer='';
	}
	elsif ( $one eq 'cat') {
		if ( $b_log_full ){
			for my $file ($two){
				my $contents = do { local( @ARGV, $/ ) = $file; <> }; # or: qx(cat $file)
				$data = "$data${line3}Full file data: $file\n\n$contents\n$line3\n";
			}
			$spacer='';
		}
	}
	elsif ( $one eq 'raw') {
		if ( $b_log_full ){
			$data = "\n${line3}Raw System Data:\n\n$two\n$line3";
			$spacer='';
		}
	}
	else {
		$data = "$one\n";
	}
	# print "d: $data";
	if ($data){
		print $fh_l "$spacer$data";
	}
}

sub set_debugger {
	if ( $debug < 10 || $debug > 12){
		$end = '';
		$start = '';
		if ( $debug >= 20 ){
			error_handler('not-in-irc', 'debug data generator') if $b_irc;
			my $option = ( $debug > 21 ) ? 'main-full' : 'main';
			my $ob_sys = SystemDebugger->new($option);
			$ob_sys->run_debugger();
			$ob_sys->upload_file($ftp_alt) if $debug > 20;
			exit 0;
		}
	}
	elsif ($debug >= 10 && $debug <= 12){
		$b_log = 1;
		if ($debug == 11){
			$b_log_full = 1;
		}
		elsif ($debug == 12){
			$b_log_colors = 1;
		}
		begin_logging();
	}
}

## SystemDebugger
{
package SystemDebugger;

# use warnings;
# use strict;
# use diagnostics;
# use 5.008;
# use Net::FTP; # never load until needed

# use File::Find q(find);
#no warnings 'File::Find';
# use File::Spec::Functions;
#use File::Copy;
#use POSIX qw(strftime);

my $option = 'main';
my $upload = '';
my $data_dir = '';
my $debug_dir = '';
my $debug_gz = '';
my @content = (); 
my $b_debug = 0;
my $b_delete_dir = 1;
# args: 1 - type
# args: 2 - upload
sub new {
	my $class = shift;
	($option) = @_;
	my $self = {};
	# print "$f\n";
	# print "$option\n";
	return bless $self, $class;
}

sub run_debugger {
	require File::Copy;
	import File::Copy;
	require File::Spec::Functions;
	import File::Spec::Functions;
	
	print "Starting $self_name debugging data collector...\n";
	create_debug_directory();
	print "Note: for dmidecode data you must be root.\n" if !$b_root;
	print $line3;
	if (!$b_debug){
		audio_data();
		disk_data();
		display_data();
		network_data();
		perl_modules();
		system_data();
	}
	system_files();
	print $line3;
	if (!$b_debug){
		if ( -d '/sys' && main::count_dir_files('/sys') ){
			sys_tree();
			sys_traverse_data();
		}
		else {
			print "Skipping /sys data collection. /sys not present, or empty.\n";
		}
		print $line3;
	}
	run_self();
	print $line3;
	compress_dir();
}

sub create_debug_directory {
	my $host = main::get_hostname();
	$host =~ s/ /-/g;
	$host ||= 'no-host';
	my $bsd_string = '';
	my $root_string = '';
	# note: Time::Piece was introduced in perl 5.9.5
	my ($sec,$min,$hour,$mday,$mon,$year) = localtime;
	$year = $year+1900;
	$mon += 1;
	if (length($sec)  == 1) {$sec = "0$sec";}
	if (length($min)  == 1) {$min = "0$min";}
	if (length($hour) == 1) {$hour = "0$hour";}
	if (length($mon)  == 1) {$mon = "0$mon";}
	if (length($mday) == 1) {$mday = "0$mday";}
	
	my $today = "$year-$mon-${mday}_$hour$min$sec";
	# my $date = strftime "-%Y-%m-%d_", localtime;
	if ($b_root){
		$root_string = '-root';
	}
	if ( $bsd_type ){
		$bsd_string = "-$bsd_type-$os";
	}
	$debug_dir = "$self_name$bsd_string-$host-$today$root_string";
	$debug_gz = "$debug_dir.tar.gz";
	$data_dir = "$user_data_dir/$debug_dir";
	if ( -d $data_dir ){
		unlink $data_dir or main::error_handler('remove', "$data_dir", "$!");
	}
	mkdir $data_dir or main::error_handler('mkdir', "$data_dir", "$!");
	if ( -e "$user_data_dir/$debug_gz" ){
		#rmdir "$user_data_dir$debug_gz" or main::error_handler('remove', "$user_data_dir/$debug_gz", "$!");
		print "Failed removing leftover directory:\n$user_data_dir$debug_gz error: $?" if system('rm','-rf',"$user_data_dir$debug_gz");
	}
	print "Data going into: $data_dir\n";
}
sub compress_dir {
	print "Creating tar.gz compressed file of this material...\n";
	print "File: $debug_gz\n";
	system("cd $user_data_dir; tar -czf $debug_gz $debug_dir");
	print "Removing $data_dir...\n";
	#rmdir $data_dir or print "failed removing: $data_dir error: $!\n";
	return 1 if !$b_delete_dir;
	if (system('rm','-rf',$data_dir) ){
		print "Failed removing: $data_dir\nError: $?\n";
	}
	else {
		print "Directory removed.\n";
	}
}
# NOTE: incomplete, don't know how to ever find out 
# what sound server is actually running, and is in control
sub audio_data {
	my (%data,@files,@files2);
	print "Collecting audio data...\n";
	my @cmds = (
	['aplay', '-l'], # alsa
	['pactl', 'list'], # pulseaudio
	);
	run_commands(\@cmds,'audio');
	@files = main::globber('/proc/asound/card*/codec*');
	if (@files){
		my $asound = qx(head -n 1 /proc/asound/card*/codec* 2>&1);
		$data{'proc-asound-codecs'} = $asound;
	}
	else {
		$data{'proc-asound-codecs'} = undef;
	}
	write_data(\%data,'audio');
	@files = (
	'/proc/asound/cards',
	'/proc/asound/version',
	);
	copy_files(\@files,'audio');
}
## NOTE: >/dev/null 2>&1 is sh, and &>/dev/null is bash, fix this
# ls -w 1 /sysrs > tester 2>&1
sub disk_data {
	my (%data,@files,@files2);
	print "Collecting dev, label, disk, uuid data, df...\n";
	@files = (
	'/etc/fstab',
	'/etc/mtab',
	'/proc/mdstat',
	'/proc/mounts',
	'/proc/partitions',
	'/proc/scsi/scsi',
	'/proc/sys/dev/cdrom/info',
	);
	if (-d '/proc/ide/'){
		my @ides = main::globber('/proc/ide/*/*');
		@files = (@files, @ides) if @ides;
	}
	else {
		push (@files, '/proc-ide-directory');
	}
	copy_files(\@files, 'disk');
	my @cmds = (
	['btrfs', 'filesystem show'],
	['btrfs', 'filesystem show --mounted'],
	# ['btrfs', 'filesystem show --all-devices'],
	['df', '-h -T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs '],
	['df', '-T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs'],
	['df', '-T -P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 --exclude-type=devfs --exclude-type=linprocfs --exclude-type=sysfs --exclude-type=fdescfs --total'],
	['df', '-h -T'],
	['df', '-h'],
	['df', '-k -T'],
	['df', '-k'],
	['df', '-P --exclude-type=aufs --exclude-type=squashfs --exclude-type=unionfs --exclude-type=devtmpfs --exclude-type=tmpfs --exclude-type=iso9660 '],
	['df', '-P'],
	['gpart', 'list'],
	['gpart', 'show'],
	['gpart', 'status'],
	['ls', '-l /dev'],
	['ls', '-l /dev/disk'],
	['ls', '-l /dev/disk/by-id'],
	['ls', '-l /dev/disk/by-label'],
	['ls', '-l /dev/disk/by-uuid'],
	# http://comments.gmane.org/gmane.linux.file-systems.zfs.user/2032
	['ls', '-l /dev/disk/by-wwn'],
	['ls', '-l /dev/disk/by-path'],
	['ls', '-l /dev/mapper'],
	['mount', ''],
	['nvme', 'present'],
	['readlink', '/dev/root'],
	['swapon', '-s'],
	['zfs', 'list'],
	['zpool', 'list'],
	['zpool', 'list -v'],
	);
	run_commands(\@cmds,'disk');
	@cmds = (
	['atacontrol', 'list'],
	['camcontrol', 'devlist'],
	['swapctl', '-l -k'],
	);
	run_commands(\@cmds,'disk-bsd');
}
sub display_data {
	my (%data,@files,@files2);
	my $working = '';
	if ( ! $b_display ){
		print "Warning: only some of the data collection can occur if you are not in X\n";
		main::toucher("$data_dir/display-data-warning-user-not-in-x");
	}
	if ( $b_root ){
		print "Warning: only some of the data collection can occur if you are running as Root user\n";
		main::toucher("$data_dir/display-data-warning-root-user");
	}
	print "Collecting Xorg log and xorg.conf files...\n";
	if ( -d "/etc/X11/xorg.conf.d/" ){
		@files = main::globber("/etc/X11/xorg.conf.d/*");
	}
	else {
		@files = ('/xorg-conf-d');
	}
	push (@files, $files{'xorg-log'});
	push (@files, '/etc/X11/xorg.conf');
	copy_files(\@files,'display-xorg');
	print "Collecting X, xprop, glxinfo, xrandr, xdpyinfo data, wayland, weston...\n";
	%data = (
	'desktop-session' => $ENV{'DESKTOP_SESSION'},
	'gdmsession' => $ENV{'GDMSESSION'},
	'gnome-desktop-session-id' => $ENV{'GNOME_DESKTOP_SESSION_ID'},
	'kde3-full-session' => $ENV{'KDE_FULL_SESSION'},
	'xdg-current-desktop' => $ENV{'XDG_CURRENT_DESKTOP'},
	'kde-gte-4-session-version' => $ENV{'KDE_SESSION_VERSION'},
	'xdg-session-desktop' => $ENV{'XDG_SESSION_DESKTOP'},
	# wayland data collectors:
	'xdg-session-type' => $ENV{'XDG_SESSION_TYPE'},
	'wayland-display' =>  $ENV{'WAYLAND_DISPLAY'},
	'gdk-backend' => $ENV{'GDK_BACKEND'},
	'qt-qpa-platform' => $ENV{'QT_QPA_PLATFORM'},
	'clutter-backend' => $ENV{'CLUTTER_BACKEND'},
	'sdl-videodriver' => $ENV{'SDL_VIDEODRIVER'},
	# program display values
	'size-indent' => $size{'indent'},
	'size-indent-min' => $size{'indent-min'},
	'size-cols-max' => $size{'max'},
	);
	write_data(\%data,'display');
	my @cmds = (
	# kde 5/plasma desktop 5, this is maybe an extra package and won't be used
	['about-distro',''],
	['aticonfig','--adapter=all --od-gettemperature'],
	['glxinfo',''],
	['glxinfo','-B'],
	['kded','--version'],
	['kded4','--version'],
	['kded5','--version'],
	['kded6','--version'],
	['kf4-config','--version'],
	['kf5-config','--version'],
	['kf6-config','--version'],
	['kwin_x11','--version'],
	['loginctl','--no-pager list-sessions'],
	['nvidia-settings','-c :0.0 -q all'],
	['nvidia-smi','-q'],
	['nvidia-smi','-q -x'],
	['plasmashell','--version'],
	['weston-info',''],
	['weston','--version'],
	['xdpyinfo',''],
	['Xorg','-version'],
	['xprop','-root'],
	['xrandr',''],
	);
	run_commands(\@cmds,'display');
}
sub network_data {
	print "Collecting networking data...\n";
# 	no warnings 'uninitialized';
	my @cmds = (
	['ifconfig',''],
	['ip','addr'],
	);
	run_commands(\@cmds,'network');
}
sub perl_modules {
	print "Collecting Perl module data (this can take a while)...\n";
	my @modules = ();
	my ($dirname,$holder,$mods,$value) = ('','','','');
	my $filename = 'perl-modules.txt';
	my @inc;
	foreach (sort @INC){
		# some BSD installs have '.' n @INC path
		if (-d $_ && $_ ne '.'){
			$_ =~ s/\/$//; # just in case, trim off trailing slash
			$value .= "EXISTS: $_\n";
			push @inc, $_;
		} 
		else {
			$value .= "ABSENT: $_\n";
		}
	}
	main::writer("$data_dir/perl-inc-data.txt",$value);
	File::Find::find { wanted => sub { 
		push @modules, File::Spec->canonpath($_) if /\.pm\z/  
	}, no_chdir => 1 }, @inc;
	@modules = sort(@modules);
	foreach (@modules){
		my $dir = $_;
		$dir =~ s/[^\/]+$//;
		if (!$holder || $holder ne $dir ){
			$holder = $dir;
			$value = "DIR: $dir\n";
			$_ =~ s/^$dir//;
			$value .= " $_\n";
		}
		else {
			$value = $_;
			$value =~ s/^$dir//;
			$value = " $value\n";
		}
		$mods .= $value;
	}
	open (my $fh, '>', "$data_dir/$filename");
	print $fh $mods;
	close $fh;
}
sub system_data {
	print "Collecting system data...\n";
	my %data = (
	'cc' => $ENV{'CC'},
	'xdg-config-home' => $ENV{'XDG_CONFIG_HOME'},
	'xdg-config-dirs' => $ENV{'XDG_CONFIG_DIRS'},
	'xdg-data-home' => $ENV{'XDG_DATA_HOME'},
	'xdg-data-dirs' => $ENV{'XDG_DATA_DIRS'},
	);
	my @files = main::globber('/usr/bin/gcc*');
	if (@files){
		$data{'gcc-versions'} = join "\n",@files;
	}
	else {
		$data{'gcc-versions'} = undef;
	}
	@files = main::globber('/sys/*');
	if (@files){
		$data{'sys-tree-ls-1-basic'} = join "\n", @files;
	}
	else {
		$data{'sys-tree-ls-1-basic'} = undef;
	}
	write_data(\%data,'system');
	# bsd tools http://cb.vu/unixtoolbox.xhtml
	my @cmds = (
	# general
	['sysctl', '-b kern.geom.conftxt'],
	['sysctl', '-b kern.geom.confxml'],
	['usbdevs','-v'],
	# freebsd
	['pciconf','-l -cv'],
	['pciconf','-vl'],
	['pciconf','-l'],
	# openbsd
	['pcidump',''],
	['pcidump','-v'],
	# netbsd
	['kldstat',''],
	['pcictl','list'],
	['pcictl','list -ns'],
	);
	run_commands(\@cmds,'system-bsd');
	# diskinfo -v <disk>
	# fdisk <disk>
	@cmds = (
	['clang','--version'],
	['dmidecode',''],
	['dmesg',''],
	['gcc','--version'],
	['hciconfig','-a'],
	['initctl','list'],
	['lscpu',''],
	['lspci','-k'],
	['lspci','-knn'],
	['lspci','-knnv'],# returns ports
	['lspci','-n'],
	['lspci','-nn'],
	['lspci','-nnk'],
	['lspci','-mm'],
	['lspci','-mmk'],
	['lspci','-mmkv'],
	['lspci','-mmnn'],
	['lspci','-v'],
	['lspci',''],
	['lsusb',''],
	['lsusb','-v'],
	['ps','aux'],
	['ps','-e'],
	['ps','-p 1'],
	['runlevel',''],
	['rc-status','-a'],
	['rc-status','-l'],
	['rc-status','-r'],
	['sensors',''],
	# leaving this commented out to remind that some systems do not
	# support strings --version, but will just simply hang at that command
	# which you can duplicate by simply typing: strings then hitting enter.
	# ['strings','--version'],
	['strings','present'],
	['sysctl','-a'],
	['systemctl','list-units'],
	['systemctl','list-units --type=target'],
	['systemd-detect-virt',''],
	);
	run_commands(\@cmds,'system');
}
sub system_files {
	print "Collecting system files data...\n";
	my (%data,@files,@files2);
	@files = RepoData::get($data_dir);
	copy_files(\@files, 'repo');
	# chdir "/etc";
	@files = main::globber("/etc/*[-_]{[rR]elease,[vV]ersion}");
	push (@files, '/etc/issue');
	push (@files, '/etc/lsb-release');
	push (@files, '/etc/os-release');
	copy_files(\@files,'system-distro');
	@files = (
	'/proc/1/comm',
	'/proc/cpuinfo',
	'/proc/meminfo',
	'/proc/modules',
	'/proc/net/arp',
	'/proc/version',
	);
	@files2=main::globber('/sys/class/power_supply/*/uevent');
	if (@files2){
		@files = (@files,@files2);
	}
	else {
		push (@files, '/sys-class-power-supply-empty');
	}
	copy_files(\@files, 'system');
	@files = (
	'/etc/make.conf',
	'/etc/src.conf',
	'/var/run/dmesg.boot',
	);
	copy_files(\@files,'system-bsd');
}

sub copy_files {
	my ($files_ref, $type) = @_;
	my ($absent,$error,$good,$name,$unreadable);
	foreach (@$files_ref) {
		$name = $_;
		$name =~ s/^\///;
		$name =~ s/\//-/g;
		$name = "$data_dir/$type-file-$name";
		$good = $name . '.txt';
		$absent = $name . '-absent';
		$error = $name . '-error';
		$unreadable = $name . '-unreadable';
		if (-e $_ ) {
			if (-r $_){
				copy($_,"$good") or main::toucher($error);
			}
			else {
				main::toucher($unreadable);
			}
		}
		else {
			main::toucher($absent);
		}
	}
}

sub run_commands {
	my ($cmds,$type) = @_;
	my $holder = '';
	my ($name,$cmd,$args);
	foreach (@$cmds){
		my @rows = @$_;
		if (my $program = main::check_program($rows[0])){
			if ($rows[1] eq 'present'){
				$name = "$data_dir/$type-cmd-$rows[0]-present";
				main::toucher($name);
			}
			else {
				$args = $rows[1];
				$args =~ s/\s|--|\/|=/-/g; # for:
				$args =~ s/--/-/g;# strip out -- that result from the above
				$args =~ s/^-//g;
				$args = "-$args" if $args;
				$name = "$data_dir/$type-cmd-$rows[0]$args.txt";
				$cmd = "$program $rows[1] >$name 2>&1";
				system($cmd);
			}
		}
		else {
			if ($holder ne $rows[0]){
				$name = "$data_dir/$type-cmd-$rows[0]-absent";
				main::toucher($name);
				$holder = $rows[0];
			}
		}
	}
}
sub write_data {
	my ($data_ref, $type) = @_;
	my ($empty,$error,$fh,$good,$name,$undefined,$value);
	foreach (keys %$data_ref) {
		$value = $$data_ref{$_};
		$name = "$data_dir/$type-data-$_";
		$good = $name . '.txt';
		$empty = $name . '-empty';
		$error = $name . '-error';
		$undefined = $name . '-undefined';
		if (defined $value) {
			if ($value || $value eq '0'){
				open($fh, '>', $good) or main::toucher($error);
				print $fh "$value";
			}
			else {
				main::toucher($empty);
			}
		}
		else {
			main::toucher($undefined);
		}
	}
}

sub run_self {
	print "Creating $self_name output file now. This can take a few seconds...\n";
	print "Starting $self_name from: $self_path\n";
	my $i = ($option eq 'main-full')? ' -i' : '';
	my $cmd = "$self_path/$self_name -FRfrploudmxxx$i -c 0 --usb --slots --debug 10 -y 120 > $data_dir/$self_name-FRfrploudmxxxyusbslots120.txt 2>&1";
	system($cmd);
	copy($log_file, "$data_dir") or main::error_handler('copy-failed', "$log_file", "$!");
	system("$self_path/$self_name --recommends -y 120 > $data_dir/$self_name-recommends-120.txt 2>&1");
}

sub sys_tree {
	print "Constructing /sys tree data...\n";
	if ( main::check_program('tree') ){
		my $dirname = '/sys';
		my $cmd;
		system("tree -a -L 10 /sys > $data_dir/sys-data-tree-full-10.txt");
		opendir my($dh), $dirname or main::error_handler('open-dir',"$dirname", "$!");
		my @files = readdir $dh;
		closedir $dh;
		foreach (@files){
			next if /^\./;
			$cmd = "tree -a -L 10 $dirname/$_ > $data_dir/sys-data-tree-$_-10.txt";
			#print "$cmd\n";
			system($cmd);
		}
	}
	# for now, we want all of these as well for better debugging
	#else {
		sys_ls(1);
		sys_ls(2);
		sys_ls(3);
		sys_ls(4);
	#}
}
sub sys_ls {
	my ( $depth) = @_;
	my $cmd = do {
		if ( $depth == 1 ){ 'ls -l /sys/ 2>/dev/null' }
		elsif ( $depth == 2 ){ 'ls -l /sys/*/ 2>/dev/null' }
		elsif ( $depth == 3 ){ 'ls -l /sys/*/*/ 2>/dev/null' }
		elsif ( $depth == 4 ){ 'ls -l /sys/*/*/*/ 2>/dev/null' }
		elsif ( $depth == 5 ){ 'ls -l /sys/*/*/*/*/ 2>/dev/null' }
		elsif ( $depth == 5 ){ 'ls -l /sys/*/*/*/*/ 2>/dev/null' }
	};
	my @working = ();
	my $output = '';
	my ($type);
	my $result = qx($cmd);
	open my $ch, '<', \$result or main::error_handler('open-data',"$cmd", "$!");
	while ( my $line = <$ch> ){
		chomp($line);
		$line =~ s/^\s+|\s+$//g;
		@working = split /\s+/, $line;
		$working[0] ||= '';
		if ( scalar @working > 7 ){
			if ($working[0] =~ /^d/ ){
				$type = "d - ";
			}
			elsif ($working[0] =~ /^l/){
				$type = "l - ";
			}
			else {
				$type = "f - ";
			}
			$working[9] ||= '';
			$working[10] ||= '';
			$output = $output . "  $type$working[8] $working[9] $working[10]\n";
		}
		elsif ( $working[0] !~ /^total/ ){
			$output = $output . $line . "\n";
		}
	}
	close $ch;
	my $file = "$data_dir/sys-data-ls-$depth.txt";
	open my $fh, '>', $file or main::error_handler('create',"$file", "$!");
	print $fh $output;
	close $fh;
	# print "$output\n";
}

sub sys_traverse_data {
	print "Parsing /sys files...\n";
	# get rid pointless error:Can't cd to (/sys/kernel/) debug: Permission denied
	no warnings 'File::Find';
	File::Find::find( \&wanted, "/sys");
	process_data();
}
sub wanted {
	return if -d; # not directory
	return unless -e; # Must exist
	return unless -r; # Must be readable
	return unless -f; # Must be file
	# note: a new file in 4.11 /sys can hang this, it is /parameter/ then
	# a few variables. Since inxi does not need to see that file, we will
	# not use it. Also do not need . files or __ starting files
	# print $File::Find::name . "\n";
	# block maybe: cfgroup\/
	return if $File::Find::name =~ /\/(\.[a-z]|kernel\/|parameters\/|debug\/)/;
	# comment this one out if you experience hangs or if 
	# we discover syntax of foreign language characters
	# Must be ascii like. This is questionable and might require further
	# investigation, it is removing some characters that we might want
	return unless -T; 
	# print $File::Find::name . "\n";
	push (@content, $File::Find::name);
	return;
}
sub process_data {
	my ($data,$fh,$result,$row,$sep);
	my $filename = "sys-data-parse.txt";
	# no sorts, we want the order it comes in
	# @content = sort @content; 
	foreach (@content){
		$data='';
		$sep='';
		open($fh, '<', $_);
		while ($row = <$fh>) {
			chomp $row;
			$data .= $sep . '"' . $row . '"';
			$sep=', ';
		}
		$result .= "$_:[$data]\n";
		# print "$_:[$data]\n"
	}
	# print scalar @content . "\n";
	open ($fh, '>', "$data_dir/$filename");
	print $fh $result;
	close $fh;
	# print $fh "$result";
}
# args: 1 - path to file to be uploaded
# args: 2 - optional: alternate ftp upload url
# NOTE: must be in format: ftp.site.com/incoming
sub upload_file {
	require Net::FTP;
	import Net::FTP;
	my ($self, $ftp_url) = @_;
	my ($ftp, $domain, $host, $user, $pass, $dir, $error);
	$ftp_url ||= main::get_defaults('ftp-upload');
	$ftp_url =~ s/\/$//g; # trim off trailing slash if present
	my @url = split(/\//, $ftp_url);
	my $file_path = "$user_data_dir/$debug_gz";
	$host = $url[0];
	$dir = $url[1];
	$domain = $host;
	$domain =~ s/^ftp\.//;
	$user = "anonymous";
	$pass = "anonymous\@$domain";
	
	print $line3;
	print "Uploading to: $ftp_url\n";
	# print "$host $domain $dir $user $pass\n";
	print "File to be uploaded: $file_path\n";
	
	if ($host && ( $file_path && -e $file_path ) ){
		# NOTE: important: must explicitly set to passive true/1
		$ftp = Net::FTP->new($host, Debug => 0, Passive => 1);
		$ftp->login($user, $pass) || main::error_handler('ftp-login', $ftp->message);
		$ftp->binary();
		$ftp->cwd($dir);
		print "Connected to FTP server.\n";
		$ftp->put($file_path) || main::error_handler('ftp-upload', $ftp->message);
		$ftp->quit;
		print "Uploaded file successfully!\n";
		print $ftp->message;
	}
	else {
		main::error_handler('ftp-bad-path', "$file_path");
	}
}
}

#### -------------------------------------------------------------------
#### DOWNLOADER
#### -------------------------------------------------------------------

sub download_file {
	my ($type, $url, $file) = @_;
	my ($cmd,$args,$timeout);
	my $result = 1;
	$dl{'no-ssl-opt'} ||= '';
	$dl{'spider'} ||= '';
	$file ||= ''; # to avoid debug error
	if ( ! $dl{'dl'} ){
		return 0;
	}
	if ($dl{'timeout'}){
		$timeout = "$dl{'timeout'}$dl_timeout";
	}
	
	# print "$dl{'no-ssl-opt'}\n";
	# print "$dl{'dl'}\n";
	# tiny supports spider sort of
	if ($dl{'dl'} eq 'tiny' ){
		print_line("Using tiny: type: $type \nurl: $url \nfile: $file\n") if $test[1];
		$result = get_file($type, $url, $file);
	}
	else {
		if ($type eq 'stdout'){
			$args = $dl{'stdout'};
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $args $url $dl{'null'}";
			print_line("$cmd\n") if $test[1];
			$result = qx($cmd);
		}
		elsif ($type eq 'file') {
			$args = $dl{'file'};
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $args $file $url $dl{'null'}";
			print_line("$cmd\n") if $test[1];
			system($cmd);
			$result = $?;
		}
		elsif ( $dl{'dl'} eq 'wget' && $type eq 'spider'){
			$cmd = "$dl{'dl'} $dl{'no-ssl-opt'} $timeout $dl{'spider'} $url";
			print_line("$cmd\n") if $test[1];
			system($cmd);
			$result = $?;
		}
	}
	return $result;
}

sub get_file {
	my ($type, $url, $file) = @_;
	my $response = HTTP::Tiny->new->get($url);
	my $return = 1;
	my $debug = 0;
	my $fh;
	
	if ( ! $response->{success} ){
		print "Failed to connect to server/file!\n";
		$return = 0;
	}
	else {
		if ( $debug ){
			print "$response->{success}\n";
			print "$response->{status} $response->{reason}\n";
			while (my ($key, $value) = each %{$response->{headers}}) {
				for (ref $value eq "ARRAY" ? @$value : $value) {
					print "$key: $_\n";
				}
			}
		}
		if ( $type eq "stdout" || $type eq "ua-stdout" ){
			$return = $response->{content};
		}
		elsif ($type eq "spider"){
			# do nothing, just use the return value
		}
		elsif ($type eq "file"){
			open($fh, ">", $file);
			print $fh $response->{content}; # or die "can't write to file!\n";
			close $fh;
		}
	}
	return $return;
}

sub set_downloader {
	eval $start if $b_log;
	$dl{'no-ssl'} = '';
	$dl{'null'} = '';
	$dl{'spider'} = '';
	# we only want to use HTTP::Tiny if it's present in user system.
	# It is NOT part of core modules.
	if ($dl{'tiny'}){
		eval "require HTTP::Tiny"; # if not found, return has error messages etc
		#print $@ . "\n";
		if ( $@ ) {
			$dl{'tiny'} = 0;
		}
		else {
			import HTTP::Tiny;
		}
	}
	#print $dl{'tiny'} . "\n";
	if ($dl{'tiny'}){
		$dl{'dl'} = 'tiny';
		$dl{'file'} = '';
		$dl{'stdout'} = '';
		$dl{'timeout'} = '';
	}
	elsif ( $dl{'curl'} && check_program('curl')  ){
		$dl{'dl'} = 'curl';
		$dl{'file'} = '  -L -s -o ';
		$dl{'no-ssl'} = ' --insecure';
		$dl{'stdout'} = ' -L -s ';
		$dl{'timeout'} = ' -y ';
	}
	elsif ($dl{'wget'} && check_program('wget') ){
		$dl{'dl'} = 'wget';
		$dl{'file'} = ' -q -O ';
		$dl{'no-ssl'} = ' --no-check-certificate';
		$dl{'spider'} = ' -q --spider';
		$dl{'stdout'} = '  -q -O -';
		$dl{'timeout'} = ' -T ';
	}
	elsif ($dl{'fetch'} && check_program('fetch')){
		$dl{'dl'} = 'fetch';
		$dl{'file'} = ' -q -o ';
		$dl{'no-ssl'} = ' --no-verify-peer';
		$dl{'stdout'} = ' -q -o -';
		$dl{'timeout'} = ' -T ';
	}
	elsif ( $bsd_type eq 'openbsd' && check_program('ftp') ){
		$dl{'dl'} = 'ftp';
		$dl{'file'} = ' -o ';
		$dl{'null'} = ' 2>/dev/null';
		$dl{'stdout'} = ' -q -O - ';
		$dl{'timeout'} = '';
	}
	else {
		$dl{'dl'} = '';
	}
	# no-ssl-opt is set to 1 with --alt 34, so it is true, then assign
	$dl{'no-ssl-opt'} = $dl{'no-ssl'} if $dl{'no-ssl-opt'};
	eval $end if $b_log;
}

sub set_perl_downloader {
	my ($downloader) = @_;
	$downloader =~ s/perl/tiny/;
	return $downloader;
}

#### -------------------------------------------------------------------
#### ERROR HANDLER
#### -------------------------------------------------------------------

sub error_handler {
	my ( $err, $one, $two) = @_;
	my $errno = 0;
	my $b_help = 0;
	my $message = do {
		if ( $err eq 'empty' ) { 'empty value' }
		## Basic rules
		elsif ( $err eq 'not-in-irc' ) { 
			$errno=1; "You can't run option $one in an IRC client!" }
		## Internal/external options
		elsif ( $err eq 'bad-arg' ) { 
			$errno=10; $b_help=1; "Unsupported value: $two for option: $one" }
		elsif ( $err eq 'bad-arg-int' ) { 
			$errno=11; "Bad internal argument: $one" }
		elsif ( $err eq 'distro-block' ) { 
			$errno=20; "Option: $one has been disabled by the $self_name distribution maintainer." }
		elsif ( $err eq 'unknown-option' ) { 
			$errno=21; $b_help=1; "Unsupported option: $one" }
		## Data
		elsif ( $err eq 'open-data' ) { 
			$errno=32; "Error opening data for reading: $one \nError: $two" }
		elsif ( $err eq 'download-error' ) { 
			$errno=32; "Error downloading file with $dl{'dl'}: $one \nError: $two" }
		## Files:
		elsif ( $err eq 'copy-failed' ) { 
			$errno=30; "Error copying file: $one \nError: $two" }
		elsif ( $err eq 'create' ) { 
			$errno=32; "Error creating file: $one \nError: $two" }
		elsif ( $err eq 'downloader-error' ) { 
			$errno=30; "Error downloading file: $one \nfor download source: $two" }
		elsif ( $err eq 'file-corrupt' ) { 
			$errno=31; "Downloaded file is corrupted: $one" }
		elsif ( $err eq 'mkdir' ) { 
			$errno=32; "Error creating directory: $one \nError: $two" }
		elsif ( $err eq 'open' ) { 
			$errno=32; "Error opening file: $one \nError: $two" }
		elsif ( $err eq 'open-dir' ) { 
			$errno=32; "Error opening directory: $one \nError: $two" }
		elsif ( $err eq 'not-writable' ) { 
			$errno=33; "The file: $one is not writable!" }
		elsif ( $err eq 'open-dir-failed' ) { 
			$errno=33; "The directory: $one failed to open with error: $two" }
		elsif ( $err eq 'remove' ) { 
			$errno=33; "Failed to remove file: $one Error: $two" }
		elsif ( $err eq 'rename' ) { 
			$errno=34; "There was an error moving files: $one\nError: $two" }
		elsif ( $err eq 'write' ) { 
			$errno=35; "Failed writing file: $one - Error: $two!" }
		## FTP
		elsif ( $err eq 'ftp-bad-path' ) { 
			$errno=50; "Unable to locate for FTP upload file:\n$one" }
		elsif ( $err eq 'ftp-login' ) { 
			$errno=50; "There was an error with login to ftp server: $one" }
		elsif ( $err eq 'ftp-login' ) { 
			$errno=51; "There was an error with upload to ftp server: $one" }
		## DEFAULT
		else {
			$errno=255; "Error handler ERROR!! Unsupported options: $err!"}
	};
	print_line("Error $errno: $message\n");
	if ($b_help){
		print_line("Check -h for correct parameters.\n");
	}
	exit 0;
}

#### -------------------------------------------------------------------
#### RECOMMENDS
#### -------------------------------------------------------------------

## CheckRecommends
{
package CheckRecommends;
sub run {
	main::error_handler('not-in-irc', 'recommends') if $b_irc;
	my (@data,@rows);
	my $line = make_line();
	my $pm = get_pm();
	@data = basic_data($line);
	push @rows,@data;
	if (!$bsd_type){
		@data = check_items('required system directories',$line,$pm);
		push @rows,@data;
	}
	@data = check_items('recommended system programs',$line,$pm);
	push @rows,@data;
	@data = check_items('recommended display information programs',$line,$pm);
	push @rows,@data;
	@data = check_items('recommended downloader programs',$line,$pm);
	push @rows,@data;
	@data = check_items('recommended directories',$line,'');
	push @rows,@data;
	@data = check_items('recommended files',$line,'');
	push @rows,@data;
	@data = (
	['0', '', '', "$line"],
	['0', '', '', "Ok, all done with the checks. Have a nice day."],
	['0', '', '', " "],
	);
	push @rows,@data;
	#print Data::Dumper::Dumper \@rows;
	main::print_basic(@rows); 
	exit 1;
}

sub basic_data {
	my ($line) = @_;
	my (@data,@rows);
	my $client = $client{'name-print'};
	$client .= ' ' . $client{'version'} if $client{'version'};
	my $default_shell = 'N/A';
	if ($ENV{'SHELL'}){
		$default_shell = $ENV{'SHELL'};
		$default_shell =~ s/.*\///;
	}
	@rows = (
	['0', '', '', "$self_name will now begin checking for the programs it needs 
	to operate."],
	['0', '', '', "" ],
	['0', '', '', "Check $self_name --help or the man page (man $self_name) 
	to see what options are available." ],
	['0', '', '', "$line" ],
	['0', '', '', "Test: core tools:" ],
	['0', '', '', "" ],
	['0', '', '', "Perl version: ^$]" ],
	['0', '', '', "Current shell: " . $client ],
	['0', '', '', "Default shell: " . $default_shell ],
	);
	return @rows;
}
sub check_items {
	my ($type,$line,$pm) = @_;
	my (@data,%info,@missing,$row,@rows,$result,@unreadable);
	my ($b_dir,$b_file,$b_program,$item);
	my ($about,$extra,$extra2,$extra3,$extra4,$info_os,$install) = ('','','','','','info','');
	if ($type eq 'required system directories'){
		@data = qw(/proc /sys);
		$b_dir = 1;
		$item = 'Directory';
	}
	elsif ($type eq 'recommended system programs'){
		if ($bsd_type){
			@data = qw(dig dmidecode file gpart ifconfig lsusb sudo 
			smartctl sysctl tree uptime usbdevs);
			$info_os = 'info-bsd';
		}
		else {
			@data = qw(dig dmidecode file hddtemp ifconfig ip lsusb modinfo 
			runlevel sensors strings sudo tree uptime);
		}
		$b_program = 1;
		$item = 'Program';
	}
	elsif ($type eq 'recommended display information programs'){
		if ($bsd_type){
			@data = qw(glxinfo xdpyinfo xprop xrandr);
			$info_os = 'info-bsd';
		}
		else {
			@data = qw(glxinfo xdpyinfo xprop xrandr);
		}
		$b_program = 1;
		$item = 'Program';
	}
	elsif ($type eq 'recommended downloader programs'){
		if ($bsd_type){
			@data = qw(curl dig fetch ftp wget);
			$info_os = 'info-bsd';
		}
		else {
			@data = qw(curl dig wget);
		}
		$b_program = 1;
		$extra = ' (You only need one of these)';
		$extra2 = "Perl HTTP::Tiny is the default downloader tool. 
		See --help --alt 40-44 options for how to override default downloader(s) in case of issues. ";
		$extra3 = "If dig is installed, it is the default for WAN IP data. 
		Strongly recommended. Dig is fast and accurate.";
		$extra4 = ". However, you really only need dig in most cases so don't worry, Perl is the default anyway and you obviously have that installed";
		$item = 'Program';
	}
	elsif ($type eq 'recommended directories'){
		if ($bsd_type){
			@data = qw(/dev);
		}
		else {
			@data = qw(/dev /dev/disk/by-label /dev/disk/by-uuid /sys/class/dmi/id);
		}
		$b_dir = 1;
		$item = 'Directory';
	}
	elsif ($type eq 'recommended files'){
		if ($bsd_type){
			@data = qw(/var/run/dmesg.boot /var/log/Xorg.0.log);
		}
		else {
			@data = qw(/etc/lsb-release /etc/os-release /proc/asound/cards 
			/proc/asound/version /proc/cpuinfo /proc/mdstat /proc/meminfo /proc/modules 
			/proc/mounts /proc/scsi/scsi /var/log/Xorg.0.log );
		}
		$b_file = 1;
		$item = 'File';
		$extra2 = "Note that not all of these are used by every system, 
		so if one is missing it's usually not a big deal.";
	}
	@rows = (
	['0', '', '', "$line" ],
	['0', '', '', "Test: $type$extra:" ],
	['0', '', '', " " ],
	);
	if ($extra2){
		$rows[scalar @rows] = (['0', '', '', $extra2]);
		$rows[scalar @rows] = (['0', '', '', ' ']);
	}
	if ($extra3){
		$rows[scalar @rows] = (['0', '', '', $extra3]);
		$rows[scalar @rows] = (['0', '', '', ' ']);
	}
	foreach (@data){
		$install = '';
		$about = '';
		%info = item_data($_);
		$about = $info{$info_os};
		if ( ( $b_dir && -d $_ ) || ( $b_file && -r $_ ) || ($b_program && main::check_program($_) )  ){
			$result = 'Present';
		}
		elsif ($b_file && -f $_){
			$result = 'Unreadable';
			push @unreadable, "$_";
		}
		else {
			$result = 'Missing';
			$install = " ~ Install package: $info{$pm}" if ($b_program && $pm);
			push @missing, "$_$install";
		}
		$row = make_row($_,$about,$result);
		$rows[scalar @rows] = (['0', '', '', $row]);
	}
	$rows[scalar @rows] = (['0', '', '', " "]);
	if (@missing){
		$rows[scalar @rows] = (['0', '', '', "The following $type are missing$extra4:"]);
		foreach (@missing) {
			$rows[scalar @rows] = (['0', '', '', "$item: $_"]);
		}
	}
	if (@unreadable){
		$rows[scalar @rows] = (['0', '', '', "The following $type are not readable: "]);
		foreach (@unreadable) {
			$rows[scalar @rows] = (['0', '', '', "$item: $_"]);
		}
	}
	if (!@missing && !@unreadable){
		$rows[scalar @rows] = (['0', '', '', "All $type are present"]);
	}
	return @rows;
}
sub item_data {
	my ($type) = @_;
	my %data = (
	# directory data
	'/sys/class/dmi/id' => ({
	'info' => '-M system, motherboard, bios',
	}),
	'/dev' => ({
	'info' => '-l,-u,-o,-p,-P,-D disk partition data',
	}),
	'/dev/disk/by-label' => ({
	'info' => '-l,-o,-p,-P partition labels',
	}),
	'/dev/disk/by-uuid' => ({
	'info' => '-u,-o,-p,-P partition uuid',
	}),
	'/proc' => ({
	'info' => '',
	}),
	'/sys' => ({
	'info' => '',
	}),
	# file data
	'/etc/lsb-release' => ({
	'info' => '-S distro version data (older version)',
	}),
	'/etc/os-release' => ({
	'info' => '-S distro version data (newer version)',
	}),
	'/proc/asound/cards' => ({
	'info' => '-A sound card data',
	}),
	'/proc/asound/version' => ({
	'info' => '-A ALSA data',
	}),
	'/proc/cpuinfo' => ({
	'info' => '-C cpu data',
	}),
	'/proc/mdstat' => ({
	'info' => '-R mdraid data (if you use dm-raid)',
	}),
	'/proc/meminfo' => ({
	'info' => '-I,-tm, -m memory data',
	}),
	'/proc/modules' => ({
	'info' => '-G module data (sometimes)',
	}),
	'/proc/mounts' => ({
	'info' => '-P,-p partition advanced data',
	}),
	'/proc/scsi/scsi' => ({
	'info' => '-D Advanced hard disk data (used rarely)',
	}),
	'/var/log/Xorg.0.log' => ({
	'info' => '-G graphics driver load status',
	}),
	'/var/run/dmesg.boot' => ({
	'info' => '-D,-d disk data',
	}),
	# system tools
	# apt-dpkg,apt-get; pm-arch,pacman; rpm-redhat,suse
	'curl' => ({
	'info' => '-i (if no dig); -w,-W; -U',
	'info-bsd' => '-i (if no dig); -w,-W; -U',
	'apt' => 'curl',
	'pacman' => 'curl',
	'rpm' => 'curl',
	}),
	'dig' => ({
	'info' => '-i wlan IP',
	'info-bsd' => '-i wlan IP',
	'apt' => 'dnsutils',
	'pacman' => 'dnsutils',
	'rpm' => 'bind-utils',
	}),
	'dmidecode' => ({
	'info' => '-M if no sys machine data; -m',
	'info-bsd' => '-M if null sysctl; -m; -B if null sysctl',
	'apt' => 'dmidecode',
	'pacman' => 'dmidecode',
	'rpm' => 'dmidecode',
	}),
	'fetch' => ({
	'info' => '',
	'info-bsd' => '-i (if no dig); -w,-W; -U',
	'apt' => '',
	'pacman' => '',
	'rpm' => '',
	}),
	'file' => ({
	'info' => '-o unmounted file system',
	'info-bsd' => '-o unmounted file system',
	'apt' => 'file',
	'pacman' => 'file',
	'rpm' => 'file',
	}),
	'ftp' => ({
	'info' => '',
	'info-bsd' => '-i (if no dig); -w,-W; -U',
	'apt' => '',
	'pacman' => '',
	'rpm' => '',
	}),
	'gpart' => ({
	'info' => '',
	'info-bsd' => '-p,-P file system, size',
	'apt' => '',
	'pacman' => '',
	'rpm' => '',
	}),
	'hciconfig' => ({
	'info' => 'Experimental',
	'info-bsd' => '',
	'apt' => 'bluez',
	'pacman' => 'bluez-utils',
	'rpm' => 'bluez-utils',
	}),
	'hddtemp' => ({
	'info' => '-Dx show hdd temp',
	'info-bsd' => '-Dx show hdd temp',
	'apt' => 'hddtemp',
	'pacman' => 'hddtemp',
	'rpm' => 'hddtemp',
	}),
	'ifconfig' => ({
	'info' => '-i ip LAN (deprecated)',
	'info-bsd' => '-i ip LAN',
	'apt' => 'net-tools',
	'pacman' => 'net-tools',
	'rpm' => 'net-tools',
	}),
	'ip' => ({
	'info' => '-i ip LAN',
	'info-bsd' => '',
	'apt' => 'iproute',
	'pacman' => 'iproute2',
	'rpm' => 'iproute',
	}),
	'lsusb' => ({
	'info' => '-A usb audio; -N usb networking; --usb',
	'info-bsd' => '-A; -N; --usb. Alternate to usbdevs',
	'apt' => 'usbutils',
	'pacman' => 'usbutils',
	'rpm' => 'usbutils',
	}),
	'modinfo' => ({
	'info' => 'Ax; -Nx module version',
	'info-bsd' => '',
	'apt' => 'module-init-tools',
	'pacman' => 'module-init-tools',
	'rpm' => 'module-init-tools',
	}),
	'runlevel' => ({
	'info' => '-I fallback to Perl',
	'info-bsd' => '',
	'apt' => 'systemd or sysvinit',
	'pacman' => 'systemd',
	'rpm' => 'systemd or sysvinit',
	}),
	'sensors' => ({
	'info' => '-s sensors output',
	'info-bsd' => '',
	'apt' => 'lm-sensors',
	'pacman' => 'lm-sensors',
	'rpm' => 'lm-sensors',
	}),
	'smartctl' => ({
	'info' => '-Dx show hdd temp',
	'info-bsd' => '-Dx show hdd temp',
	'apt' => '',
	'pacman' => '',
	'rpm' => '',
	}),
	'strings' => ({
	'info' => '-I sysvinit version',
	'info-bsd' => '',
	'apt' => 'binutils',
	'pacman' => '?',
	'rpm' => '?',
	}),
	'sysctl' => ({
	'info' => '',
	'info-bsd' => '-C; -I; -m; -tm',
	'apt' => '?',
	'pacman' => '?',
	'rpm' => '?',
	}),
	'sudo' => ({
	'info' => '-Dx hddtemp-user; -o file-user',
	'info-bsd' => '-Dx hddtemp-user; -o file-user',
	'apt' => 'sudo',
	'pacman' => 'sudo',
	'rpm' => 'sudo',
	}),
	'tree' => ({
	'info' => '--debugger 20,21 /sys tree',
	'info-bsd' => '--debugger 20,21 /sys tree',
	'apt' => 'tree',
	'pacman' => 'tree',
	'rpm' => 'tree',
	}),
	'uptime' => ({
	'info' => '-I uptime',
	'info-bsd' => '-I uptime',
	'apt' => 'procps',
	'pacman' => 'procps',
	'rpm' => 'procps',
	}),
	'usbdevs' => ({
	'info' => '',
	'info-bsd' => '-A; -N; --usb;',
	'apt' => 'usbutils',
	'pacman' => 'usbutils',
	'rpm' => 'usbutils',
	}),
	'wget' => ({
	'info' => '-i (if no dig); -w,-W; -U',
	'info-bsd' => '-i (if no dig); -w,-W; -U',
	'apt' => 'wget',
	'pacman' => 'wget',
	'rpm' => 'wget',
	}),
	# display tools
	'glxinfo' => ({
	'info' => '-G glx info',
	'info-bsd' => '-G glx info',
	'apt' => 'mesa-utils',
	'pacman' => 'mesa-demos',
	'rpm' => 'glx-utils (openSUSE 12.3 and later Mesa-demo-x)',
	}),
	'xdpyinfo' => ({
	'info' => '-G multi screen resolution',
	'info-bsd' => '-G multi screen resolution',
	'apt' => 'X11-utils',
	'pacman' => 'xorg-xdpyinfo',
	'rpm' => 'xorg-x11-utils',
	}),
	'xprop' => ({
	'info' => '-S desktop data',
	'info-bsd' => '-S desktop data',
	'apt' => 'X11-utils',
	'pacman' => 'xorg-xprop',
	'rpm' => 'x11-utils',
	}),
	'xrandr' => ({
	'info' => '-G single screen resolution',
	'info-bsd' => '-G single screen resolution',
	'apt' => 'x11-xserver-utils',
	'pacman' => 'xrandr',
	'rpm' => 'x11-server-utils',
	}),
	);
	my $ref = $data{$type};
	my %values = %$ref;
	return %values;
}
sub get_pm {
	my ($pm) = ('');
	if (main::check_program('dpkg')){
		$pm = 'apt';
	}
	elsif (main::check_program('pacman')){
		$pm = 'pacman';
	}
	elsif (main::check_program('rpm')){
		$pm = 'rpm';
	}
	return $pm;
}
# note: end will vary, but should always be treated as longest value possible.
# expected values: Present/Missing
sub make_row {
	my ($start,$middle,$end) = @_;
	my ($dots,$line,$sep) = ('','',': ');
	foreach (0 .. ($size{'max'} - 16 - length("$start$middle"))){
		$dots .= '.';
	}
	$line = "$start$sep$middle$dots $end";
	return $line;
}
sub make_line {
	my $line = '';
	foreach (0 .. $size{'max'} - 2 ){
		$line .= '-';
	}
	return $line;
}
}

#### -------------------------------------------------------------------
#### TOOLS
#### -------------------------------------------------------------------

# Duplicates the functionality of awk to allow for one liner
# type data parsing. note: -1 corresponds to awk NF
# args 1: array of data; 2: search term; 3: field result; 4: separator
# correpsonds to: awk -F='separator' '/search/ {print $2}' <<< @data
# array is sent by reference so it must be dereferenced
# NOTE: if you just want the first row, pass it \S as search string
# NOTE: if $num is undefined, it will skip the second step
sub awk {
	eval $start if $b_log;
	my ($ref,$search,$num,$sep) = @_;
	my ($result);
	return if ! @$ref || ! $search;
	foreach (@$ref){
		if (/$search/i){
			$result = $_;
			$result =~ s/^\s+|\s+$//g;
			last;
		}
	}
	if ($result && defined $num){
		$sep ||= '\s+';
		$num-- if $num > 0; # retain the negative values as is
		$result = (split /$sep/, $result)[$num];
		$result =~ s/^\s+|,|\s+$//g if $result;
	}
	eval $end if $b_log;
	return $result;
}
# arg: 1 - string or path to search gneerated @paths data for.
# note: a few nano seconds are saved by using raw $_[0] for program
sub check_program {
	(grep { return "$_/$_[0]" if -e "$_/$_[0]"} @paths)[0];
}

sub cleanup {
	# maybe add in future: , $fh_c, $fh_j, $fh_x
	foreach my $fh ($fh_l){
		if ($fh){
			close $fh;
		}
	}
}

# returns count of files in directory, if 0, dir is empty
sub count_dir_files {
	return unless -d $_[0];
	opendir my $dh, $_[0] or error_handler('open-dir-failed', "$_[0]", $!); 
	my $count = grep { ! /^\.{1,2}/ } readdir $dh; # strips out . and ..
	return $count;
}

# arg 1: type to return
sub get_defaults {
	my ($type) = @_;
	my %defaults = (
	'ftp-upload' => 'ftp.techpatterns.com/incoming',
	# 'inxi-branch-1' => 'https://github.com/smxi/inxi/raw/one/',
	# 'inxi-branch-2' => 'https://github.com/smxi/inxi/raw/two/',
	'inxi-main' => 'https://github.com/smxi/inxi/raw/master/',
	'inxi-pinxi' => 'https://github.com/smxi/inxi/raw/inxi-perl/',
	'inxi-man' => "https://github.com/smxi/inxi/raw/master/$self_name.1.gz",
	);
	if ( exists $defaults{$type}){
		return $defaults{$type};
	}
	else {
		error_handler('bad-arg-int', $type);
	}
}

# args: 1 - the string to get piece of
# 2 - the position in string, starting at 1 for 0 index.
# 3 - the separator, default is ' '
sub get_piece {
	eval $start if $b_log;
	my ($string, $num, $sep) = @_;
	$num--;
	$sep ||= '\s+';
	$string =~ s/^\s+|\s+$//g;
	my @temp = split(/$sep/, $string);
	eval $end if $b_log;
	if ( exists $temp[$num] ){
		$temp[$num] =~ s/,//g;
		return $temp[$num];
	}
}

# arg: 1 - command to turn into an array; 2 - optional: splitter
# 3 - optionsl, strip and clean data
# similar to reader() except this creates an array of data 
# by lines from the command arg
sub grabber {
	eval $start if $b_log;
	my ($cmd,$split,$strip) = @_;
	$split ||= "\n";
	my @rows = split /$split/, qx($cmd);
	if ($strip && @rows){
		@rows = grep {/^\s*[^#]/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	eval $end if $b_log;
	return @rows;
}

# args: 1 - string value to glob
sub globber {
	eval $start if $b_log;
	my @files = <$_[0]>;
	eval $end if $b_log;
	return @files;
}
# gets array ref, which may be undefined, plus join string
# this helps avoid debugger print errors when we are printing arrays
# which we don't know are defined or not null.
# args: 1 - array ref; 2 - join string; 3 - default value, optional
sub joiner {
	my ($ref,$join,$default) = @_;
	my @arr = @$ref;
	$default ||= '';
	my $string = (@arr && defined $arr[0]) ? join "$join",  @arr: $default;
	return $string;
}

# returns array of:
# 0 - match string; 1 - search number; 2 - version string; 3 - Print name
# 4 - console 0/1; 5 - 0/1 exit version loop at first iteration
# arg: 1 - program lower case name
sub program_values {
	my ($app) = @_;
	my (@client_data);
	my %data = (
	# clients
	'bitchx' => ['bitchx',2,'','BitchX',1,0],# special
	'finch' => ['finch',2,'-v','Finch',1,1],
	'gaim' => ['[0-9.]+',2,'-v','Gaim',0,1],
	'ircii' => ['[0-9.]+',3,'-v','ircII',1,1],
	'irssi' => ['irssi',2,'-v','Irssi',1,1],
	'irssi-text' => ['irssi',2,'-v','Irssi',1,1],
	'konversation' => ['konversation',2,'-v','Konversation',0,0],
	'kopete' => ['Kopete',2,'-v','Kopete',0,0],
	'kvirc' => ['[0-9.]+',2,'-v','KVIrc',0,0], # special
	'pidgin' => ['[0-9.]+',2,'-v','Pidgin',0,1],
	'quassel' => ['',1,'-v','Quassel [M]',0,0], # special
	'quasselclient' => ['',1,'-v','Quassel',0,0],# special
	'quasselcore' => ['',1,'-v','Quassel (core)',0,0],# special
	'gribble' => ['^Supybot',2,'--version','Gribble',1,0],# special
	'limnoria' => ['^Supybot',2,'--version','Limnoria',1,0],# special
	'supybot' => ['^Supybot',2,'--version','Supybot',1,0],# special
	'weechat' => ['[0-9.]+',1,'-v','WeeChat',1,0],
	'weechat-curses' => ['[0-9.]+',1,'-v','WeeChat',1,0],
	'xchat-gnome' => ['[0-9.]+',2,'-v','X-Chat-Gnome',1,1],
	'xchat' => ['[0-9.]+',2,'-v','X-Chat',1,1],
	# desktops 
	'afterstep' => ['^afterstep',3,'--version','AfterStep',0,1],
	'awesome' => ['^awesome',2,'--version','Awesome',0,1],
	'blackbox' => ['^Blackbox',2,'--version','Blackbox',0,1],
	'budgie' => ['^budgie-desktop',2,'--version','Budgie',0,1],
	'cinnamon' => ['^cinnamon',2,'--version','^Cinnamon',0,1],
	'dwm' => ['^dwm',1,'-v','dwm',0,1],
	'fluxbox' => ['^fluxbox',2,'--version','Fluxbox',0,1],
	'fvwm' => ['^fvwm',2,'--version','FVWM',0,1],
	# command: fvwm
	'fvwm-crystal' => ['^fvwm',2,'--version','FVWM-Crystal',0,1], 
	'gnome-about' => ['gnome',3,'--version','Gnome',0,1],
	'gnome-shell' => ['gnome',3,'--version','Gnome',0,1],
	'herbstluftwm' => ['^herbstluftwm',-1,'--version','herbstluftwm',0,1],
	'jwm' => ['^jwm',2,'--version','JWM',0,1],
	'i3' => ['^i3',2,'--version','i3',0,1],
	'icewm' => ['^icewm',2,'--version','IceWM',0,1],
	'kded3' => ['^KDE Development Platform:',4,'--version','KDE',0,1],
	# command: lxqt-about
	'lxqt' => ['^lxqt-about',2,'--version','LXQT',0,1],
	'mate' => ['^MATE[[:space:]]DESKTOP',-1,'--version','MATE',0,1],
	'openbox' => ['^openboxt',2,'--version','Openbox',0,1],
	'pekwm' => ['^pekwm',3,'--version','pekwm',0,1],
	'plasmashell' => ['^plasmashell',2,'--version','KDE Plasma',0,1],
	'qtdiag' => ['^qt',2,'--version','Qt',0,1],
	'sawfish' => ['^sawfish',3,'--version','Sawfish',0,1],
	'scrotwm' => ['^welcome.*scrotwm',4,'-v','Scrotwm',0,1],
	'spectrwm' => ['^spectrwm.*welcome.*spectrwm',5,'-v','Spectrwm',0,1],
	'unity' => ['^unity',2,'--version','Unity',0,1],
	'wm2' => ['^wm2',-1,'--version','WM2',0,1],
	'wmaker' => ['^Window[[:space:]]*Maker',-1,'--version','WindowMaker',0,1],
	'wmii' => ['^wmii',1,'--version','wmii',0,1], # note: in debian, wmii is wmii3
	'wmii2' => ['^wmii2',1,'--version','wmii2',0,1],
	'xfce4-panel' => ['^xfce4-panel',2,'--version','Xfce',0,1],
	'xfce5-panel' => ['^xfce5-panel',2,'--version','Xfce',0,1],
	'xfdesktop' => ['xfdesktop[[:space:]]version',5,'--version','Xfce',0,1],
	# command: xfdesktop
	'xfdesktop-toolkit' => ['Built[[:space:]]with[[:space:]]GTK',4,'--version','Gtk',0,1],
	
	# shells
	'bash' => ['^GNU[[:space:]]bash,[[:space:]]version',4,'--version','Bash',1,0],
	'csh' => ['^tcsh',2,'--version','csh',1,0],
	'dash' => ['dash',3,'--version','Dash',1,0], # no version, uses dpkg query, sigh
	'ksh' => ['version',5,'-v','csh',1,0], # ksh is too weird to try to handle with version
	'tcsh' => ['^tcsh',2,'--version','tcsh',1,0],
	'zsh' => ['^zsh',2,'--version','zsh',1,0],
	# tools
	'clang' => ['clang',4,'--version','Clang',1,0],
	'gcc' => ['^gcc',3,'--version','GCC',1,0],
	'gcc-apple' => ['Apple[[:space:]]LLVM',2,'--version','csh',1,0],
	);
	if ( defined $data{$app} ){
		my $ref = $data{$app};
		@client_data = @$ref;
	}
	#my $debug = main::Dumper \@client_data;
	# main::log_data("Client Data: " . main::Dumper \@client_data);
	return @client_data;
}
# args: 1 - desktop/app command for --version; 2 - search string; 
# 3 - space print number; 4 - [optional] version arg: -v, version, etc
sub program_version {
	eval $start if $b_log;
	my ($app, $search, $num,$version,$exit) = @_;
	my ($cmd,$line,$output);
	my $version_nu = '';
	my $count = 0;
	$exit ||= 100; # basically don't exit ever
	$version ||= '--version';
	
	# adjust to array index, not human readable
	$num-- if $num > 0;
	
	# dump these once the dm stuff is done, we'll pass this data
	# we're not trying to get ksh any more, it's too difficult
	#if ( $app =~ /^ksh/) {
	#	$version = '-v';
	#}
	# konvi in particular doesn't like using $ENV{'PATH'} as set, so we need
	# to always assign the full path if it hasn't already been done
	if ( $app !~ /^\//){
		$app = check_program($app);
	}
	# note, some wm/apps send version info to stderr instead of stdout
	if ( $app =~ /\/(dwm|ksh|kvirc|scrotwm)$/ ) {
		$cmd = "$app $version 2>&1";
	}
# 	elsif ( $app eq 'csh' ){
# 		$app = 'tcsh';
# 	}
	# quick debian/buntu hack until I find a universal way to get version for these
	elsif ( $app eq 'dash' ){
		$cmd = "dpkg -l $app 2>/dev/null";
	}
	else {
		$cmd = "$app $version 2>/dev/null";
	}
	log_data("version: $version num: $num search: $search command: $cmd") if $b_log;
	$output = qx($cmd);
	# print "$cmd : $output\n";
	# sample: dwm-5.8.2, .. etc, why no space? who knows. Also get rid of v in number string
	# xfce, and other, output has , in it, so dump all commas and parentheses
	if ($output){
		open my $ch, '<', \$output or error_handler('open-data',"$cmd", "$!");
		while (<$ch>){
			#chomp;
			last if $count > $exit;
			if ( $_ =~ /$search/i ) {
				$_ = trimmer($_);
				# print "$_ ::$num\n";
				$version_nu = (split /\s+/, $_)[$num];
				$version_nu =~ s/(|\([^)]+\)|,|dwm-|wmii2-|wmii-|v|V|\|)//g;
				# print "$version_nu\n";
				last;
			}
			$count++;
		}
		close $ch if $ch;
	}
	log_data("Program version: $version_nu") if $b_log;
	eval $end if $b_log;
	return $version_nu;
}
# print program_version('bash', 'bash', 4) . "\n";

# arg: 1 - full file path, returns array of file lines.
# 2 - optionsl, strip and clean data
# note: chomp has to chomp the entire action, not just <$fh>
sub reader {
	eval $start if $b_log;
	my ($file,$strip) = @_;
	open( my $fh, '<', $file ) or error_handler('open', $file, $!);
	chomp(my @rows = <$fh>);
	if ($strip && @rows){
		@rows = grep {/^\s*[^#]/} @rows;
		@rows = map {s/^\s+|\s+$//g; $_} @rows if @rows;
	}
	eval $end if $b_log;
	return @rows;
}
# args: 1 - the file to create if not exists
sub toucher {
	my $file = shift;
	if ( ! -e $file ){
		open( my $fh, '>', $file ) or error_handler('create', $file, $!);
	}
}

# calling it trimmer to avoid conflicts with existing trim stuff
# arg: 1 - string to be right left trimmed. Also slices off \n so no chomp needed
# this thing is super fast, no need to log its times etc, 0.0001 seconds or less
sub trimmer {
	#eval $start if $b_log;
	my ($str) = @_;
	$str =~ s/^\s+|\s+$|\n$//g; 
	#eval $end if $b_log;
	return $str;
}
# args: 1 - hash
# send array, assign to hash, return array, uniq values only.
sub uniq {
	my %seen;
	grep !$seen{$_}++, @_;
}
# arg: 1 file full  path to write to; 2 - arrayof data to write. 
# note: turning off strict refs so we can pass it a scalar or an array reference.
sub writer {
	my ($path, $ref_content) = @_;
	my ($content);
	no strict 'refs';
	# print Dumper $ref_content, "\n";
	if (ref $ref_content eq 'ARRAY'){
		$content = join "\n", @$ref_content or die "failed with error $!";
	}
	else {
		$content = scalar $ref_content;
	}
	open(my $fh, '>', $path) or error_handler('open',"$path", "$!");
	print $fh $content;
	close $fh;
}

#### -------------------------------------------------------------------
#### UPDATER
##### -------------------------------------------------------------------

# args: 1 - download url, not including file name; 2 - string to print out
# 3 - update type option
# note that 1 must end in / to properly construct the url path
sub update_me {
	eval $start if $b_log;
	my ( $self_download, $download_id ) = @_;
	my $downloader_error=1;
	my $file_contents='';
	my $output = '';
	my $b_man = 0;
	$self_path =~ s/\/$//; # dirname sometimes ends with /, sometimes not
	$self_download =~ s/\/$//; # dirname sometimes ends with /, sometimes not
	my $full_self_path = "$self_path/$self_name";
	
	if ( $b_irc ){
		error_handler('not-in-irc', "-U/--update" )
	}
	if ( ! -w $full_self_path ){
		error_handler('not-writable', "$self_name", '');
	}
	$output .= "Starting $self_name self updater.\n";
	$output .= "Using $dl{'dl'} as downloader.\n";
	$output .= "Currently running $self_name version number: $self_version\n";
	$output .= "Current version patch number: $self_patch\n";
	$output .= "Current version release date: $self_date\n";
	$output .= "Updating $self_name in $self_path using $download_id as download source...\n";
	print $output;
	$output = '';
	$self_download = "$self_download/$self_name";
	$file_contents=download_file('stdout', $self_download);
	
	# then do the actual download
	if (  $file_contents ){
		# make sure the whole file got downloaded and is in the variable
		if ( $file_contents =~ /###\*\*EOF\*\*###/ ){
			open(my $fh, '>', $full_self_path);
			print $fh $file_contents or error_handler('write', "$full_self_path", "$!" );
			close $fh;
			qx( chmod +x '$self_path/$self_name' );
			set_version_data();
			$output .= "Successfully updated to $download_id version: $self_version\n";
			$output .= "New $download_id version patch number: $self_patch\n";
			$output .= "New $download_id version release date: $self_date\n";
			$output .= "To run the new version, just start $self_name again.\n";
			$output .= "$line3\n";
			$output .= "Starting download of man page file now.\n";
			print $output;
			$output = '';
			if ($b_man && $download_id eq 'main branch' ){
				update_man();
			}
			else {
				print "Skipping man download because branch version is being used.\n";
			}
			exit 1;
		}
		else {
			error_handler('file-corrupt', "$self_name");
		}
	}
	# now run the error handlers on any downloader failure
	else {
		error_handler('download-error', $self_download, $download_id);
	}
	eval $end if $b_log;
}

sub update_man {
	my $man_file_url=get_defaults('inxi-man'); 
	my $man_file_location=set_man_location();
	my $man_file_path="$man_file_location/$self_name.1.gz" ;
	my $output = '';
	
	my $downloader_man_error=1;
	if ( ! -d $man_file_location ){
		print "The required man directory was not detected on your system.\n";
		print "Unable to continue: $man_file_location\n";
		return 0;
	}
	if ( -w $man_file_location ){
		print "Cannot write to $man_file_location! Are you root?\n";
		print "Unable to continue: $man_file_location\n";
		return 0;
	}
	if ( -f "/usr/share/man/man8/inxi.8.gz" ){
		print "Updating man page location to man1.\n";
		rename "/usr/share/man/man8/inxi.8.gz", "$man_file_location/inxi.1.gz";
		if ( check_program('mandb') ){
			system( 'mandb' );
		}
	}
	if ( $dl{'dl'} =~ /tiny|wget/){
		print "Checking Man page download URL...\n";
		download_file('spider', $man_file_url);
		$downloader_man_error = $?;
	}
	if ( $downloader_man_error == 1 ){
		if ( $dl{'dl'} =~ /tiny|wget/){
			print "Man file download URL verified: $man_file_url\n";
		}
		print "Downloading Man page file now.\n";
		download_file('file', $man_file_url,  $man_file_path );
		$downloader_man_error = $?;
		if ( $downloader_man_error == 0 ){
			print "Oh no! Something went wrong downloading the Man gz file at: $man_file_url\n";
			print "Check the error messages for what happened. Error: $downloader_man_error\n";
		}
		else {
			print "Download/install of man page successful. Check to make sure it works: man inxi\n";
		}
	}
	else {
		print "Man file download URL failed, unable to continue: $man_file_url\n";
	}
}

sub set_man_location {
	my $location='';
	my $default_location='/usr/share/man/man1';
	my $man_paths=qx(man --path 2>/dev/null);
	my $man_local='/usr/local/share/man';
	my $b_use_local=0;
	if ( $man_paths && $man_paths =~ /$man_local/ ){
		$b_use_local=1;
	}
	# for distro installs
	if ( -f "$default_location/inxi.1.gz" ){
		$location=$default_location;
	}
	else {
		if ( $b_use_local ){
			if ( ! -d "$man_local/man1" ){
				mkdir "$man_local/man1";
			}
			$location="$man_local/man1";
		}
	}
	if ( ! $location ){
		$location=$default_location;
	}
	return $location;
}

# update for updater output version info
# note, this is only now used for self updater function so it can get
# the values from the UPDATED file, NOT the running program!
sub set_version_data {
	open (my $fh, '<', "$self_path/$self_name");
	while( my $row = <$fh>){
		chomp $row;
		$row =~ s/'//g;
		if ($row =~ /^my \$self_name/ ){
			$self_name = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_version/ ){
			$self_version = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_date/ ){
			$self_date = (split /=/, $row)[1];
		}
		elsif ($row =~ /^my \$self_patch/ ){
			$self_patch = (split /=/, $row)[1];
		}
		elsif ($row =~ /^## END INXI INFO/){
			last;
		}
	}
	close $fh;
}

########################################################################
#### OPTIONS HANDLER
########################################################################

sub get_options{
	eval $start if $b_log;
	my (@args) = @_;
	$show{'short'} = 1;
	my ($b_downloader,$b_recommends,$b_updater,$b_version,$help_type,
	$self_download, $download_id);
	GetOptions (
	'A|audio' => sub {
		$show{'short'} = 0;
		$show{'audio'} = 1;},
	'b|basic' => sub {
		$show{'short'} = 0;
		$show{'battery'} = 1;
		$show{'cpu-basic'} = 1;
		$show{'raid-basic'} = 1;
		$show{'disk-total'} = 1;
		$show{'graphic'} = 1;
		$show{'info'} = 1;
		$show{'machine'} = 1;
		$show{'network'} = 1;
		$show{'system'} = 1;},
	'B|battery' => sub {
		$show{'short'} = 0;
		$show{'battery'} = 1;
		$show{'battery-forced'} = 1; },
	'c|color:i' => sub {
		my ($opt,$arg) = @_;
		if ( $arg >= 0 && $arg <= get_color_scheme('count') ){
			set_color_scheme($arg);
		}
		elsif ( $arg >= 94 && $arg <= 99 ){
			$colors{'selector'} = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'C|cpu' => sub {
		$show{'short'} = 0;
		$show{'cpu'} = 1; },
	'd|disk-full|optical' => sub {
		$show{'short'} = 0;
		$show{'disk'} = 1;
		$show{'optical'} = 1; },
	'D' => sub {
		$show{'short'} = 0;
		$show{'disk'} = 1; },
	'f|flags|flag' => sub {
		$show{'short'} = 0;
		$show{'cpu'} = 1;
		$show{'cpu-flag'} = 1; },
	'F|full' => sub {
		$show{'short'} = 0;
		$show{'audio'} = 1;
		$show{'battery'} = 1;
		$show{'cpu'} = 1;
		$show{'disk'} = 1;
		$show{'graphic'} = 1;
		$show{'info'} = 1;
		$show{'machine'} = 1;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1;
		$show{'partition'} = 1;
		$show{'raid'} = 1;
		$show{'sensor'} = 1;
		$show{'system'} = 1; },
	'G|graphics|graphic' => sub {
		$show{'short'} = 0;
		$show{'graphic'} = 1; },
	'i|ip' => sub {
		$show{'short'} = 0;
		$show{'ip'} = 1;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1;
		$b_downloader = 1 if ! check_program('dig');},
	'I|info' => sub {
		$show{'short'} = 0;
		$show{'info'} = 1; },
	'l|labels|label' => sub {
		$show{'short'} = 0;
		$show{'label'} = 1;
		$show{'partition'} = 1; },
	'limit:i' => sub {
		my ($opt,$arg) = @_;
		if ($arg != 0){
			$limit = $arg;
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'm|memory' => sub {
		$show{'short'} = 0;
		$show{'ram'} = 1; },
	'M|machine' => sub {
		$show{'short'} = 0;
		$show{'machine'} = 1; },
	'n|network-advanced' => sub {
		$show{'short'} = 0;
		$show{'network'} = 1;
		$show{'network-advanced'} = 1; },
	'N|network' => sub {
		$show{'short'} = 0;
		$show{'network'} = 1; },
	'o|unmounted' => sub {
		$show{'short'} = 0;
		$show{'unmounted'} = 1; },
	'p|partition-full' => sub {
		$show{'short'} = 0;
		$show{'partition'} = 1;
		$show{'partition-full'} = 1; },
	'P|partitions|partition' => sub {
		$show{'short'} = 0;
		$show{'partition'} = 1; },
	'r|repos|repo' => sub {
		$show{'short'} = 0;
		$show{'repo'} = 1; },
	'R|raid' => sub {
		$show{'short'} = 0;
		$show{'raid'} = 1;
		$show{'raid-forced'} = 1; },
	's|sensors|sensor' => sub {
		$show{'short'} = 0;
		$show{'sensor'} = 1; },
	'sleep:s' => sub {
		my ($opt,$arg) = @_;
		if ($arg >= 0){
			$cpu_sleep = $arg;
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'slots|slot' => sub {
		$show{'short'} = 0;
		$show{'slot'} = 1; },
	'S|system' => sub {
		$show{'short'} = 0;
		$show{'system'} = 1; },
	't|processes|process:s' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		my $num = $arg;
		$num =~ s/^[cm]+// if $num;
		if ( $arg =~ /^([cm]+)([0-9]+)?$/ && (!$num || $num =~ /^\d+/) ){
			$show{'process'} = 1;
			if ($arg =~ /c/){
				$show{'ps-cpu'} = 1;
			}
			if ($arg =~ /m/){
				$show{'ps-mem'} = 1;
			}
			$ps_count = $num if $num;
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'usb' => sub {
		$show{'short'} = 0;
		$show{'usb'} = 1; },
	'u|uuid' => sub {
		$show{'short'} = 0;
		$show{'partition'} = 1;
		$show{'uuid'} = 1; },
	'v|verbosity:i' => sub {
		my ($opt,$arg) = @_;
		$show{'short'} = 0;
		if ( $arg =~ /^[0-8]$/ ){
			if ($arg == 0 ){
				$show{'short'} = 1;
			}
			if ($arg >= 1 ){
				$show{'cpu-basic'} = 1;
				$show{'disk-total'} = 1;
				$show{'graphic'} = 1;
				$show{'info'} = 1;
				$show{'system'} = 1;
			}
			if ($arg >= 2 ){
				$show{'battery'} = 1;
				$show{'disk-basic'} = 1;
				$show{'raid-basic'} = 1;
				$show{'machine'} = 1;
				$show{'network'} = 1;
			}
			if ($arg >= 3 ){
				$show{'network-advanced'} = 1;
				$show{'cpu'} = 1;
				$extra = 1;
			}
			if ($arg >= 4 ){
				$show{'disk'} = 1;
				$show{'partition'} = 1;
			}
			if ($arg >= 5 ){
				$show{'audio'} = 1;
				$show{'ram'} = 1;
				$show{'label'} = 1;
				$show{'optical-basic'} = 1;
				$show{'ram'} = 1;
				$show{'raid'} = 1;
				$show{'sensor'} = 1;
				$show{'uuid'} = 1;
			}
			if ($arg >= 6 ){
				$show{'optical'} = 1;
				$show{'partition-full'} = 1;
				$show{'unmounted'} = 1;
				$extra = 2;
			}
			if ($arg >= 7 ){
				$b_downloader = 1 if ! check_program('dig');
				$show{'ip'} = 1;
				$show{'raid-forced'} = 1;
				$extra = 3;
			}
			if ($arg >= 8 ){
				$b_downloader = 1;
				$show{'usb'} = 1;
				$show{'slot'} = 1;
				$show{'process'} = 1;
				$show{'ps-cpu'} = 1;
				$show{'ps-mem'} = 1;
				$show{'repo'} = 1;
				$show{'weather'} = 1;
			}
		}
		else {
			error_handler('bad-arg',$opt,$arg);
		} },
	'w|weather' => sub {
		my ($opt) = @_;
		$show{'short'} = 0;
		$b_downloader = 1;
		if ( $b_weather ){
			$show{'weather'} = 1;
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'W|weather-location:s' => sub {
		my ($opt,$arg) = @_;
		$arg ||= '';
		$arg =~ s/\s//g;
		$show{'short'} = 0;
		$b_downloader = 1;
		if ( $b_weather ){
			if ($arg){
				$show{'weather'} = 1;
				$show{'weather-location'} = $arg;
			}
			else {
				error_handler('bad-arg',$opt,$arg);
			}
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'x|extra:i' => sub {
		my ($opt,$arg) = @_;
		if ($arg > 0){
			$extra = $arg;
		}
		else {
			$extra++;
		} },
	'y|width:i' => sub {
		my ($opt, $arg) = @_;
		if ( $arg =~ /\d/ && $arg >= 80 ){
			set_display_width($arg);
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'z|filter' => sub {
		$show{'filter'} = 1; },
	'Z|filter-override' => sub {
		$show{'filter-override'} = 1; },
	## Start non data options
	'alt:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg == 30) {$b_irc = 0}
		elsif ($arg == 31) {$show{'host'} = 0}
		elsif ($arg == 32) {$show{'host'} = 1}
		elsif ($arg == 33) {$b_dmidecode_force=1}
		elsif ($arg == 34) {$dl{'no-ssl-opt'}=1}
		elsif ($arg == 40) {
			$dl{'tiny'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 41) {
			$dl{'curl'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 42) {
			$dl{'fetch'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 43) {
			$dl{'wget'} = 0;
			$b_downloader = 1;}
		elsif ($arg == 44) {
			$dl{'curl'} = 0;
			$dl{'fetch'} = 0;
			$dl{'wget'} = 0;
			$b_downloader = 1;}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'dbg:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg > 0) {$test[$arg] = 1}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'debug:i' => sub { 
		my ($opt,$arg) = @_;
		if ($arg =~ /^[1-3]|[1-2][0-2]$/){
			$debug=$arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'display:s' => sub { 
		my ($opt,$arg) = @_;
		if ($arg =~ /^:?([0-9]+)?$/){
			$display=$arg;
			$display ||= ':0';
			$display = ":$display" if $display !~ /^:/;
			$b_display = 1;
			$show{'display-data'} = 2;
			$display_opt = "-display $display";
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'downloader:s' => sub { 
		my ($opt,$arg) = @_;
		$arg = lc($arg);
		if ($arg =~ /^(curl|fetch|ftp|perl|wget)$/){
			# this dumps all the other data and resets %dl for only the
			# desired downloader.
			$arg = set_perl_downloader($arg);
			%dl = ('dl' => $arg, $arg => 1);
			$b_downloader = 1;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		} },
	'ftp:s'  => sub { 
		my ($opt,$arg) = @_;
		# pattern: ftp.x.x/x
		if ($arg =~ /^ftp\..+\..+\/[^\/]+$/ ){
			$ftp_alt = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'h|help|?' => sub {
		$help_type = 'standard'; },
	'H|help-full' => sub {
		$help_type = 'full'; },
	'output:s' => sub {
		my ($opt,$arg) = @_;
		if ($arg =~ /^csv|json|screen|xml$/){
			$output_type = $arg;
		}
		else {
			error_handler('bad-arg', $opt, $arg);
		}},
	'recommends' => sub {
		$b_recommends = 1; },
	'U|update:s' => sub { # 1,2,3 OR http://myserver/path/inxi
		my ($opt,$arg) = @_;
		$b_downloader = 1;
		if ( $b_update ){
			$b_updater = 1;
			if ( $arg =~ /^\d$/){
				$download_id = "branch $arg";
				$self_download = get_defaults("inxi-branch-$arg");
			}
			elsif ( $arg =~ /^http/){
				$download_id = 'alt server';
				$self_download = $arg;
			}
			else {
				$download_id = 'pinxi branch';
				$self_download = get_defaults('inxi-pinxi');
			}
# 			else {
# 				$download_id = 'main branch';
# 				$self_download = get_defaults('inxi-main');
# 			}
			if (!$self_download){
				error_handler('bad-arg', $opt, $arg);
			}
		}
		else {
			error_handler('distro-block', $opt);
		} },
	'V|version' => sub { 
		$b_version = 1 },
	'<>' => sub {
		my ($opt) = @_;
		error_handler('unknown-option', "$opt", "" ); }
	) ; #or error_handler('unknown-option', "@ARGV", '');
	## run all these after so that we can change widths, downloaders, etc
	eval $end if $b_log;
	CheckRecommends::run() if $b_recommends;
	set_downloader() if $b_downloader;
	show_version() if $b_version;
	show_options($help_type) if $help_type;
	update_me( $self_download, $download_id ) if $b_updater;
	if ( $show{'ram'} || $show{'slot'} || 
	     ( ( $bsd_type || $b_dmidecode_force ) && ($show{'machine'} || $show{'battery'}) ) ){
		$b_dmi = 1;
	}
	if ($show{'audio'} || $show{'graphic'} || $show{'network'} ){
		$b_pci = 1;
	}
	if ($show{'usb'} || $show{'audio'}  || $show{'network'} ){
		$usb_level = ($show{'usb'}) ? 2 : 1;
	}
	if ($bsd_type && ($show{'short'} || $show{'cpu'} || $show{'cpu-basic'} || $show{'machine'} || 
	 $show{'info'} || $show{'process'} || $show{'ram'} ) ){
		$b_sysctl = 1;
	}
	if ($show{'filter-override'}){
		$show{'filter'} = 0;
	}
	# override for things like -b or -v2 to -v3
	$show{'cpu-basic'} = 0 if $show{'cpu'};
	$show{'optical-basic'} = 0 if $show{'optical'};
	if ($show{'disk'} || $show{'optical'} ){
		$show{'disk-basic'} = 0;
		$show{'disk-total'} = 0;
	}
} 

sub show_options {
	error_handler('not-in-irc', 'help') if $b_irc;
	my ($type) = @_;
	my (@row,@rows,@data);
	my $line = '';
	my $color_scheme_count=12; # $(( ${#A_COLOR_SCHEMES[@]} - 1 ));
	my $partition_string='partition';
	my $partition_string_u='Partition';
	if ( $bsd_type ){
		$partition_string='slice';
		$partition_string_u='Slice';
	}
	# fit the line to the screen!
	for my $i ( 0 .. ( ( $size{'max'} / 2 ) - 2 ) ){
		$line = $line . '- ';
	}
	@rows = (
	['0', '', '', "$self_name supports the following options. You can combine 
	them, or list them one by one. Examples: $self_name^-v4^-c6 OR 
	$self_name^-bDc^6. If you start $self_name with no arguments, it will show 
	the short form." ],
	[0, '', '', '' ],
	['0', '', '', "The following options if used without -F, -b, or -v will show 
	just option line(s): A, B, C, D, G, I, M, N, P, R, S, f, i, m, n, o, p, l, 
	u, r, s, t - you can use these alone or together to show just the line(s) 
	you want to see. If you use them with -v^[level], -b or -F, it will show the 
	full output for that line along with the output for the chosen verbosity level." ],
	['0', '', '', $line ],
	['0', '', '', "Output Control Options:" ],
	['1', '-A', '--audio', "Audio/sound card information." ],
	['1', '-b', '--basic', "Basic output, short form. Like $self_name^-v^2, only minus hard 
	disk names." ],
	['1', '-B', '--battery', "Battery info, shows charge, condition, plus extra information 
	(if battery present)." ],
	['1', '-c', '--color', "Color schemes. Scheme number is required. Color selectors run a 
	color selector option prior to $self_name starting which lets you set the 
	config file value for the selection." ],
	['1', '', '', "Supported color schemes: 0-$color_scheme_count 
	Example:^$self_name^-c^11" ],
	['1', '', '', "Color selectors for each type display (NOTE: irc and global only 
	show safe color set):" ],
	['2', '94', '', "Console, out of X" ],
	['2', '95', '', "Terminal, running in X - like xTerm" ],
	['2', '96', '', "Gui IRC, running in X - like Xchat, Quassel, Konversation etc." ],
	['2', '97', '', "Console IRC running in X - like irssi in xTerm" ],
	['2', '98', '', "Console IRC not in  X" ],
	['2', '99', '', "Global - Overrides/removes all settings. Setting specific 
	removes global." ],
	['1', '-C', '--cpu', "CPU output, including per CPU clockspeed and max CPU speed 
	(if available)." ],
	['1', '-d', '--disk-full, --optical', "Adds optical drive data (and floppy disks, if present). Same as -Dd. 
	See also -x and -xx." ],
	['1', '-D', '--disk', "Full hard Disk info, not only model, ie: /dev/sda ST380817AS 
	80.0GB. See also -x and -xx. Disk total used percentage includes swap 
	partition size(s)." ],
	['1', '-f', '--flags', "All cpu flags, triggers -C. Not shown with -F to avoid spamming. 
	ARM cpus show 'features'." ],
	['1', '-F', '--full', "Full output for $self_name. Includes all Upper Case line letters, 
	plus -s and -n. Does not show extra verbose options like 
	-d -f -l -m -o -p -r -t -u -x" ],
	['1', '-G', '--graphics', "Graphic card information (card, display server type/version, 
	resolution, renderer, OpenGL version)." ],
	['1', '-i', '--ip', "Wan IP address, and shows local interfaces (requires ifconfig 
	network tool). Same as -Nni. Not shown with -F for user security reasons, 
	you shouldn't paste your local/wan IP." ],
	['1', '-I', '--info', "Information: processes, uptime, memory, irc client (or shell type),
	$self_name version." ],
	['1', '-l', '--label', "$partition_string_u labels. Default: short $partition_string -P. 
	For full -p output, use: -pl (or -plu)." ],
	['1', '-m', '--memory', "Memory (RAM) data. Physical system memory array(s), capacity, 
	how many devices (slots) supported, and individual memory devices 
	(sticks of memory etc). For devices, shows device locator, size, speed, 
	type (like: DDR3). If neither -I nor -tm are selected, also shows 
	ram used/total. Also see -x, -xx, -xxx" ],
	['1', '-M', '--machine', "Machine data. Device type (desktop, server, laptop, VM etc.), 
	Motherboard, Bios, and if present, System Builder (Like Lenovo). 
	Shows UEFI/BIOS/UEFI [Legacy]. Older systems/kernels without the 
	required /sys data can use dmidecode instead, run as root. 
	Dmidecode can be forced with -! 33" ],
	['1', '-n', '--network-advanced', "Advanced Network card information. Same as -Nn. Shows interface, 
	speed, mac id, state, etc." ],
	['1', '-N', '--network', "Network card information. With -x, shows PCI BusID, Port number." ],
	['1', '-o', '--unmounted', "Unmounted $partition_string information (includes UUID and 
	LABEL if available). Shows file system type if you have file installed, 
	if you are root OR if you have added to /etc/sudoers (sudo v. 1.7 or 
	newer) Example:^<username>^ALL^=^NOPASSWD:^/usr/bin/file^" ],
	['1', '-p', '--partitions-full', "Full $partition_string information (-P plus all other 
	detected ${partition_string}s)." ],
	['1', '-P', '--partitions', "Basic $partition_string information (shows what -v^4 would 
	show, but without extra data). Shows, if detected: 
	/ /boot /home /opt /tmp /usr /var /var/log /var/tmp . 
	Use -p to see all mounted ${partition_string}s." ],
	['1', '-r', '--repos', "Distro repository data. Supported repo types: APK; APT; PACMAN; 
	PISI; PORTAGE; PORTS (BSDs); SLACKPKG; URPMQ; YUM; ZYPP." ],
	['1', '-R', '--raid', "RAID data. Shows RAID devices, states, levels, and components, 
	and extra data with -x/-xx. md-raid: If device is resyncing, shows resync 
	progress line as well." ],
	['1', '-s', '--sensors', "Sensors output (if sensors installed/configured): mobo/cpu/gpu temp; 
	detected fan speeds. Gpu temp only for Fglrx/Nvidia drivers. Nvidia shows 
	screen number for > 1 screens." ],
	['1', '', '--slots', "Show PCI slots, type, speed, status." ],
	['1', '-S', '--system', "System information: host name, kernel, desktop environment 
	(if in X), distro" ],
	['1', '-t', '--processes', "Processes. Requires extra options: c^(cpu) m^(memory) cm^(cpu+memory). 
	If followed by numbers 1-X, shows that number of processes for each type 
	(default:^$ps_count; if in irc, max:^5): -t^cm10" ],
	['1', '', '', "Make sure to have no space between letters and numbers 
	(-t^cm10 - right, -t^cm^10 - wrong)." ],
	['1', '', '--usb', "Show USB data; Hubs and Devices attached." ],
	['1', '-u', '--uuid', "$partition_string_u UUIDs. Default: short $partition_string -P. 
	For full -p output, use: -pu (or -plu)." ],
	['1', '-v', '--verbosity', "Script verbosity levels. Verbosity level number is required. 
	Should not be used with -b or -F" ],
	['1', '', '', "Supported levels: 0-7 Example: $self_name^-v^4" ],
	['2', '0', '', "Short output, same as: $self_name" ],
	['2', '1', '', "Basic verbose, -S + basic CPU + -G + basic Disk + -I." ],
	['2', '2', '', "Networking card (-N), Machine (-M) data, if present, Battery (-B), 
	basic hard disk data (names only), and, if present, basic raid (devices only, 
	and if inactive, notes that). similar to: $self_name^-b" ],
	['2', '3', '', "Advanced CPU (-C), battery, network (-n) data, and switches on 
	-x advanced data option." ],
	['2', '4', '', "$partition_string_u size/filled data (-P) for (if present): /, 
	/home, /var/, /boot. Shows full disk data (-D)." ],
	['2', '5', '', "Audio card (-A); sensors^(-s), memory/ram^(-m), 
	$partition_string label^(-l) and UUID^(-u), short form of optical drives, 
	standard raid data (-R)." ],
	['2', '6', '', "Full $partition_string (-p), unmounted $partition_string (-o), 
	optical drive (-d), full raid; triggers -xx." ],
	['2', '7', '', "Network IP data (-i); triggers -xxx."],
	['2', '8', '', "Everything available. -r, -tcm, --slots, --usb, and anything else added."],
	);
	push @data, @rows;
	# if distro maintainers don't want the weather feature disable it
	if ( $b_weather ){
		@rows = (
		['1', '-w', '--weather', "Local weather data/time. To check an alternate location, 
		see: -W^<location>. For extra weather data options see -x, -xx, and -xxx."],
		['1', '-W', '--weather-location', "<location> Supported options for <location>: postal code; 
		city, state/country; latitude, longitude. Only use if you want the weather 
		somewhere other than the machine running $self_name. Use only ascii 
		characters, replace spaces in city/state/country names with '+'. 
		Example:^$self_name^-W^new+york,ny"]
		);
		push @data, @rows;
	}
	@rows = (
	['1', '-x', '-extra', "Adds the following extra data (only works with verbose or line 
	output, not short form):" ],
	['2', '-B', '', "Vendor/model, status (if available)" ],
	['2', '-C', '', "CPU Flags, Bogomips on Cpu;CPU microarchitecture / revision if 
	found, like: (Sandy Bridge rev.2)" ],
	['2', '-d', '', "Extra optical drive data; adds rev version to optical drive." ],
	['2', '-D', '', "Hdd temp with disk data if you have hddtemp installed, if you are 
	root OR if you have added to /etc/sudoers (sudo v. 1.7 or newer) 
	Example:^<username>^ALL^=^NOPASSWD:^/usr/sbin/hddtemp" ],
	['2', '-G', '', "Direct rendering status for Graphics (in X)." ],
	['2', '-G', '', "(for single gpu, nvidia driver) screen number gpu is running on." ],
	['2', '-i', '', "For IPv6, show additional IP v6 scope addresses: Global, Site, 
	Temporary, Unknown. See --limit for large counts of IP addresses." ],
	['2', '-I', '', "System GCC, default. With -xx, also show other installed 
	GCC versions. If running in console, not in IRC client, shows shell 
	version number, if detected. Init/RC Type and runlevel (if available)." ],
	['2', '-m', '', "Manufacteror and Part number; Max memory module size (if available)." ],
	['2', '-N -A', '', "Version/port(s)/driver version (if available) for Network/Audio;" ],
	['2', '-N -A -G', '', "Network, audio, graphics, shows PCI Bus ID/Usb ID 
	number of card." ],
	['2', '-R', '', "md-raid: Shows component raid id. Adds second RAID Info line: 
	raid level; report on drives (like 5/5); blocks; chunk size; bitmap (if present). 
	Resync line, shows blocks synced/total blocks. zfs-raid:	Shows raid array 
	full size; available size; portion allocated to RAID" ],
	['2', '-S', '', "Desktop toolkit if available (GNOME/XFCE/KDE only); Kernel 
	gcc version" ],
	['2', '-t', '', "Memory use output to cpu (-xt c), and cpu use to memory (-xt m)." ],
	['2', '--usb', '', "For Devices, show USB speed." ],
	);
	push @data, @rows;
	if ( $b_weather eq 1 ){
		@rows = (['2', '-w -W', '', "Wind speed and time zone (-w only)." ]);
		push @data, @rows;
	}
	@rows = (
	['1', '-xx', '--extra 2', "Show extra, extra data (only works with verbose or line output, 
	not short form):" ],
	['2', '-A', '', "Chip vendor:product ID for each audio device." ],
	['2', '-B', '', "serial number, voltage (if available)." ],
	['2', '-C', '', "Minimum CPU speed, if available." ],
	['2', '-D', '', "Disk serial number; Firmware rev. if available." ],
	['2', '-G', '', "Chip vendor:product ID for each video card; (mir/wayland only) 
	compositor (alpha test); OpenGL compatibility version, if free drivers and 
	available." ],
	['2', '-I', '', "Other detected installed gcc versions (if present). System 
	default runlevel. Adds parent program (or tty) for shell info if not in IRC
	(like Konsole or Gterm). Adds Init/RC (if found) version number." ],
	['2', '-m', '', "Manufacterer, part number; Single/double bank (if found)." ],
	['2', '-M', '', "Chassis information, bios rom size (dmidecode only), if data for 
	either is available." ],
	['2', '-N', '', "Chip vendor:product ID for each nic." ],
	['2', '-R', '', "md-raid: Superblock (if present); algorythm, U data. Adds 
	system info line (kernel support,read ahead, raid events). If present, 
	adds unused device line. Resync line, shows progress bar." ],
	['2', '-S', '', "Display manager (dm) in desktop output, if in X 
	(like kdm, gdm3, lightdm)." ],
	['2', '--slots', '', "Show slot length." ],
	['2', '--usb', '', "Show vendor:chip id." ],
	);
	push @data, @rows;
	if ( $b_weather ){
		@rows = (['2', '-w -W', '', "Humidity, barometric pressure." ]);
		push @data, @rows;
	}
	@rows = (
	['1', '-xxx', '--extra 3', "Show extra, extra, extra data (only works with verbose or 
	line output, not short form):" ],
	['2', '-B', '', "chemistry, cycles, location (if available)." ],
	['2', '-m', '', "Width of memory bus, data and total (if present and greater 
	than data); Detail, if present, for Type; module voltage, if available; Serial number." ],
	['2', '-S', '', "Panel/shell information in desktop output, if in X 
	(like gnome-shell, cinnamon, mate-panel); if available, dm version number." ]
	);
	push @data, @rows;
	if ( $b_weather ){
		@rows = (['2', '-w -W', '', "Location (uses -z/irc filter), weather 
		observation time, wind chill, heat index, dew point (shows extra lines 
		for data where relevant)." ] );
		push @data, @rows;
	}
	@rows = (
	['1', '-y', '--width', "Required extra option: integer, 80 or greater. Set the output 
	line width max. Overrides IRC/Terminal settings or actual widths. Example:^inxi^-y^130" ],
	['1', '-z', '--filter', "Security filters for IP/Mac addresses, location, user home 
	directory name. Default on for irc clients." ],
	['1', '-Z', '--filter-override', "Absolute override for output filters. Useful for debugging 
	networking issues in irc for example." ],
	[0, '', '', "$line" ],
	[0, '', '', "Additional Options:" ],
	['1', '-h', '--help', "This help menu." ],
	['1', '-H', '--help-full', "This help menu, plus developer options. Do not use dev options in 
	normal operation!" ],
	['1', '', '--recommends', "Checks $self_name application dependencies + recommends, 
	and directories, then shows what package(s) you need to install to add support 
	for that feature. " ]
	);
	push @data, @rows;
	if ( $b_update ){
		@rows = (
		['1', '-U', '--update', "Auto-update script. Will also install/update man page. 
		Note: if you installed as root, you must be root to update, otherwise user 
		is fine. Man page installs require root user mode. No arguments downloads from main 
		$self_name git repo." ],
		['1', '', '', "Use alternate sources for updating $self_name" ],
		
		['2', '1', '', "Get the git branch one version." ],
		['2', '2', '', "Get the git branch two version." ],
		['2', '<http>', '', "Get a version of $self_name from your own server if you want, 
		put the full download path, like: $self_name -U https://myserver.com/inxi" ]
		);
		push @data, @rows;
	}
	@rows = (
	['1', '-V', '--version', "$self_name version information. Prints information 
	then exits." ],
	[0, '', '', "$line" ],
	[0, '', '', "Debugging Options:" ],
	['1', '', '--debug', "Triggers debugging modes." ],
	['2', '1-3', '', "On screen $self_name debugger output" ],
	['2', '10', '', "Basic $self_name logging." ],
	['2', '11', '', "Full file/system info logging" ],
	['2', '12', '', "Plus Color logging." ],
	['1', '', ,'', "The following create a tar.gz file of system data, plus collecting 
	the $self_name output to file. To automatically upload debugger data tar.gz file 
	to ftp.techpatterns.com: $self_name^--debug^21" ],
	['2', '20', '', "Full system data collection: /sys; xorg conf and 
	log data, xrandr, xprop, xdpyinfo, glxinfo etc.; data from dev, disks, 
	${partition_string}s, etc." ],
	['2', '21', '', "Upload debugger dataset to $self_name debugger server 
	automatically." ],
	['1', '', '--ftp', "Use with --debugger 21 to trigger an alternate FTP server for upload. 
	Format:^[ftp.xx.xx/yy]. Must include a remote directory to upload to: 
	Example:^$self_name^--debug^21^--ftp^ftp.myserver.com/incoming" ],
	[0, '', '', "$line" ],
	[0, '', '', "Advanced Options:" ],
	[1, '', '--alt', "Trigger for various advanced options:" ],
	# ['2', '0', '', "Overrides defective or corrupted data." ],
	['2', '31', '', "Turns off hostname in output. Useful if showing output from 
	servers etc." ],
	['2', '32', '', "Turns on hostname in output." ],
	['2', '33', '', "Forces use of dmidecode data instead of /sys where 
	relevant (-M)." ],
	['2', '34', '', "Skips SSL certificate checks for all downloader activies 
	(wget/fetch/curl only)." ],
	['2', '40', '', "Bypass Perl as a downloader option." ],
	['2', '41', '', "Bypass Curl as a downloader option." ],
	['2', '42', '', "Bypass Fetch as a downloader option." ],
	['2', '43', '', "Bypass Wget as a downloader option." ],
	['2', '44', '', "Bypass Curl, Fetch, and Wget as a downloader options. Forces 
	Perl if HTTP::Tiny present." ],
	['1', '', '--display', "Will try to get display data out of X. Default gets it from display 0. 
	If you use this format: --display 1 it would get it from display 1 instead, or any 
	display you specify" ],
	['1', '', '--downloader', "Force $self_name to use [curl|fetch|perl|wget] for downloads." ],
	['1', '', '--limit', "[-1 - x] -1 removes limit. Raise or lower max output limit of IP addresses for -i." ],
	['1', '', '--output', "Change data output type. Options: [csv|json|screen|xml]" ],
	['1', '', '--sleep', "[0-x.x] - Usually in decimals. Change CPU sleep time for -C (current: $cpu_sleep). Sleep is used to let system catch up and show a more accurate CPU use. Example:^$self_name^-Cxxx^--sleep^0.15" ],
	['0', '', '', $line ],
	);
	push @data, @rows;
	if ( $type eq 'full' ){
		@rows = (
		[0, '', '', "Developer and Testing Options (Advanced):" ],
		['1', '', '--dbg', "Switches on specific debuggers. Refer to inxi-values.txt documentation for active switches." ],
		['0', '', '', $line ]
		);
		push @data, @rows;
	}
	print_basic(@data); 
	exit 1;
}

########################################################################
#### STARTUP DATA
########################################################################

# StartClient
{
package StartClient;

# use warnings;
# use strict;

my $ppid = '';
my $pppid = '';

# NOTE: there's no reason to crete an object, we can just access
# the features statically. 
# args: none
# sub new {
# 	my $class = shift;
# 	my $self = {};
# 	# print "$f\n";
# 	# print "$type\n";
# 	return bless $self, $class;
# }

sub get_client_data {
	eval $start if $b_log;
	$ppid = getppid();
	main::set_ps_aux() if ! @ps_aux;
	if (!$b_irc){
		main::get_shell_data($ppid);
	}
	else {
		$show{'filter'} = 1; 
		get_client_name();
		if ($client{'konvi'} == 1 || $client{'konvi'} == 3){
			set_konvi_data();
		}
	}
	eval $end if $b_log;
}

sub get_client_name {
	eval $start if $b_log;
	my $client_name = '';
	
	# print "$ppid\n";
	if ($ppid && -e "/proc/$ppid/exe" ){
		$client_name = lc(readlink "/proc/$ppid/exe");
		$client_name =~ s/^.*\///;
		if ($client_name =~ /^bash|dash|sh|python.*|perl.*$/){
			$pppid = (main::grabber("ps -p $ppid -o ppid"))[1];
			#my @temp = (main::grabber("ps -p $ppid -o ppid 2>/dev/null"))[1];
			$pppid =~ s/^\s+|\s+$//g;
			$client_name =~ s/[0-9\.]+$//; # clean things like python2.7
			if ($pppid && -f "/proc/$pppid/exe" ){
				$client_name = lc(readlink "/proc/$pppid/exe");
				$client_name =~ s/^.*\///;
				$client{'native'} = 0;
			}
		}
		$client{'name'} = $client_name;
		get_client_version();
		# print "c:$client_name p:$pppid\n";
	}
	else {
		if (! check_modern_konvi() ){
			$ppid = getppid();
			$client_name = (main::grabber("ps -p $ppid"))[1];
			
			my @data = split /\s+/, $client_name;
			if ($bsd_type){
				$client_name = lc($data[5]);
			}
			# gnu/linux uses last value
			else {
				$client_name = lc($data[scalar @data - 1]);
			}
			$client_name =~ s/.*\|-(|)//;
			$client_name =~ s/[0-9\.]+$//; # clean things like python2.7
			if ($client_name){
				$client{'name'} = $client_name;
				$client{'native'} = 1;
				get_client_version();
			}
			else {
				$client{'name'} = "PPID='$ppid' - Empty?";
			}
		}
	}
	main::log_data("Client: $client{'name'} :: version: $client{'version'} :: konvi: $client{'konvi'} :: PPID: $ppid") if $b_log;
	eval $end if $b_log;
}
sub get_client_version {
	eval $start if $b_log;
	@app = main::program_values($client{'name'});
	my (@data,@working,$string);
	if (@app){
		$string = ($client{'name'} =~ /^gribble|limnoria|supybot$/) ? 'supybot' : $client{'name'};
		$client{'version'} = main::program_version($string,$app[0],$app[1],$app[2]);
		$client{'name-print'} = $app[3];
		$client{'console-irc'} = $app[4];
	}
	if ($client{'name'} =~ /^bash|dash|sh$/ ){
		$client{'name-print'} = 'shell wrapper';
		$client{'console-irc'} = 1;
	}
	elsif ($client{'name'} eq 'bitchx') {
		@data = main::grabber("$client{'name'} -v");
		$string = awk(\@data,'Version');
		if ($string){
			$string =~ s/[()]|bitchx-//g; 
			@data = split /\s+/, $string;
			$_=lc for @data;
			$client{'version'} = ($data[1] eq 'version') ? $data[2] : $data[1];
		}
	}
	# 'hexchat' => ['',0,'','HexChat',0,0], # special
	# the hexchat author decided to make --version/-v return a gtk dialogue box, lol...
	# so we need to read the actual config file for hexchat. Note that older hexchats
	# used xchat config file, so test first for default, then legacy. Because it's possible
	# for this file to be user edited, doing some extra checks here.
	elsif ($client{'name'} eq 'hexchat') {
		if ( -f '~/.config/hexchat/hexchat.conf' ){
			@data = main::reader('~/.config/hexchat/hexchat.conf','strip');
		}
		elsif ( -f '~/.config/hexchat/xchat.conf' ){
			@data = main::reader('~/.config/hexchat/xchat.conf','strip');
		}
		$client{'version'} = main::awk(\@data,'version',2,'\s*=\s*');
		$client{'name-print'} = 'HexChat';
	}
	# note: see legacy inxi konvi logic if we need to restore any of the legacy code.
	elsif ($client{'name'} eq 'konversation') {
		$client{'konvi'} = ( ! $client{'native'} ) ? 2 : 1;
	}
	elsif ($client{'name'} =~ /quassel/) {
		@data = main::grabber("$client{'name'} -v 2>/dev/null");
		foreach (@data){
			if ($_ =~ /^Quassel IRC:/){
				$client{'version'} = (split /\s+/, $_ )[2];
				last;
			}
			elsif ($_ =~ /quassel\s[v]?[0-9]/){
				$client{'version'} = (split /\s+/, $_ )[1];
				last;
			}
		}
		$client{'version'} ||= '(pre v0.4.1)?'; 
	}
	# then do some perl type searches, do this last since it's a wildcard search
	elsif ($client{'name'} =~ /^perl.*|ksirc|dsirc$/ ) {
		my @cmdline = main::get_cmdline();
		# Dynamic runpath detection is too complex with KSirc, because KSirc is started from
		# kdeinit. /proc/<pid of the grandparent of this process>/exe is a link to /usr/bin/kdeinit
		# with one parameter which contains parameters separated by spaces(??), first param being KSirc.
		# Then, KSirc runs dsirc as the perl irc script and wraps around it. When /exec is executed,
		# dsirc is the program that runs inxi, therefore that is the parent process that we see.
		# You can imagine how hosed I am if I try to make inxi find out dynamically with which path
		# KSirc was run by browsing up the process tree in /proc. That alone is straightjacket material.
		# (KSirc sucks anyway ;)
		foreach (@cmdline){
			if ( $_ =~ /dsirc/ ){
				$client{'version'} = main::program_version('ksirc','KSirc:',2,'-v',0);
				$client{'name'} = 'ksirc';
				$client{'name-print'} = 'KSirc';
			}
		}
		$client{'console-irc'} = 1;
		perl_python_client();
	}
	elsif ($client{'name'} =~ /python/) {
		perl_python_client();
	}
	if (!$client{'name-print'}) {
		$client{'name-print'} = 'Unknown Client: ' . $client{'name'};
	}
	eval $end if $b_log;
}
sub get_cmdline {
	eval $start if $b_log;
	my @cmdline;
	my $i = 0;
	$ppid = getppid();
	if (! -e "/proc/$ppid/cmdline" ){
		return 1;
	}
	local $\ = '';
	open( my $fh, '<', "/proc/$ppid/cmdline" ) or 
	  print_line("Open /proc/$ppid/cmdline failed: $!");
	my @rows = <$fh>;
	close $fh;
	
	foreach (@rows){
		push @cmdline, $_;
		$i++;
		last if $i > 31;
	}
	if ( $i == 0 ){
		$cmdline[0] = $rows[0];
		$i = ($cmdline[0]) ? 1 : 0;
	}
	main::log_data("cmdline: @cmdline count: $i") if $b_log;
	eval $end if $b_log;
	return @cmdline;
}
sub perl_python_client {
	eval $start if $b_log;
	return 1 if $client{'version'};
	# this is a hack to try to show konversation if inxi is running but started via /cmd
	# OR via script shortcuts, both cases in fact now
	# main::print_line("konvi: " . scalar grep { $_ =~ /konversation/ } @ps_cmd);
	if ( $b_display && main::check_program('konversation') && ( scalar grep { $_ =~ /konversation/ } @ps_cmd ) > 0){
		@app = main::program_values('konversation');
		$client{'version'} = main::program_version('konversation',$app[0],$app[1],$app[2]);
		$client{'name'} = 'konversation';
		$client{'name-print'} = $app[3];
		$client{'console-irc'} = $app[4];
	}
	## NOTE: supybot only appears in ps aux using 'SHELL' command; the 'CALL' command
	## gives the user system irc priority, and you don't see supybot listed, so use SHELL
	elsif ( !$b_display && 
	 (main::check_program('supybot') || main::check_program('gribble') || main::check_program('limnoria')) &&
	 ( scalar grep { $_ =~ /supybot/ } @ps_cmd ) > 0  ){
		@app = main::program_values('supybot');
		$client{'version'} = main::program_version('supybot',$app[0],$app[1],$app[2]);
		if ($client{'version'}){
			if ( ( scalar grep { $_ =~ /gribble/ } @ps_cmd ) > 0){
				$client{'name'} = 'gribble';
				$client{'name-print'} = 'Gribble';
			}
			if ( ( scalar grep { $_ =~ /limnoria/ } @ps_cmd ) > 0){
				$client{'name'} = 'limnoria';
				$client{'name-print'} = 'Limnoria';
			}
			else {
				$client{'name'} = 'supybot';
				$client{'name-print'} = 'Supybot';
			}
		}
		else {
			$client{'name'} = 'supybot';
			$client{'name-print'} = 'Supybot';
		}
		$client{'console-irc'} = 1;
	}
	else {
		$client{'name-print'} = "Unknown $client{'name'} client";
	}
	main::log_data("namep: $client{'name-print'} name: $client{'name'} version: $client{'version'}") if $b_log;
	eval $end if $b_log;
}
## try to infer the use of Konversation >= 1.2, which shows $PPID improperly
## no known method of finding Konvi >= 1.2 as parent process, so we look to see if it is running,
## and all other irc clients are not running. As of 2014-03-25 this isn't used in my cases
sub check_modern_konvi {
	eval $start if $b_log;
	
	return 0 if ! $client{'qdbus'};
	my $b_modern_konvi = 0;
	my $konvi_version = '';
	my $konvi = '';
	my $pid = '';
	my (@temp);
	# main::log_data("name: $client{'name'} :: qdb: $client{'qdbus'} :: version: $client{'version'} :: konvi: $client{'konvi'} :: PPID: $ppid") if $b_log;
	# sabayon uses /usr/share/apps/konversation as path
	if ( -d '/usr/share/kde4/apps/konversation' || -d '/usr/share/apps/konversation' ){
		$pid = main::awk(\@ps_aux,'konversation',2,'\s+');
		main::log_data("pid: $pid") if $b_log;
		$konvi = readlink ("/proc/$pid/exe");
		$konvi =~ s/^.*\///; # basename
		@app = main::program_values('konversation');
		if ($konvi){
			@app = main::program_values('konversation');
			$konvi_version = main::program_version($konvi,$app[0],$app[1],$app[2]);
			@temp = split /\./, $konvi_version;
			$client{'console-irc'} = $app[4];
			$client{'konvi'} = 3;
			$client{'name'} = 'konversation';
			$client{'name-print'} = $app[3];
			$client{'version'} = $konvi_version;
			# note: we need to change this back to a single dot number, like 1.3, not 1.3.2
			$konvi_version = $temp[0] . "." . $temp[1];
			if ($konvi_version > 1.1){
				$b_modern_konvi = 1;
			}
		}
	}
	main::log_data("name: $client{'name'} name print: $client{'name-print'} 
	qdb: $client{'qdbus'} version: $konvi_version konvi: $konvi PID: $pid") if $b_log;
	main::log_data("b_is_qt4: $b_modern_konvi") if $b_log;
	## for testing this module
# 	my $ppid = getppid();
# 	system('qdbus org.kde.konversation', '/irc', 'say', $client{'dserver'}, $client{'dtarget'}, 
# 	"getpid_dir: $konvi_qt4 verNum: $konvi_version pid: $pid ppid: $ppid" );
	eval $end if $b_log;
	return $b_modern_konvi;
}

sub set_konvi_data {
	eval $start if $b_log;
	my $config_tool = '';
	# https://userbase.kde.org/Konversation/Scripts/Scripting_guide
	if ( $client{'konvi'} == 3 ){
		$client{'dserver'} = shift @ARGV;
		$client{'dtarget'} = shift @ARGV;
		$client{'dobject'} = 'default';
	}
	elsif ( $client{'konvi'} == 1 ){
		$client{'dport'} = shift @ARGV;
		$client{'dserver'} = shift @ARGV;
		$client{'dtarget'} = shift @ARGV;
		$client{'dobject'} = 'Konversation';
	}
	# for some reason this logic hiccups on multiple spaces between args
	@ARGV = grep { $_ ne '' } @ARGV;
	# there's no current kde 5 konvi config tool that we're aware of. Correct if changes.
	if ( main::check_program('kde4-config') ){
		$config_tool = 'kde4-config';
	}
	elsif ( main::check_program('kde5-config') ){
		$config_tool = 'kde5-config';
	}
	elsif ( main::check_program('kde-config') ){
		$config_tool = 'kde-config';
	}
	# The section below is on request of Argonel from the Konversation developer team:
	# it sources config files like $HOME/.kde/share/apps/konversation/scripts/inxi.conf
	if ($config_tool){
		my @data = main::grabber("$config_tool --path data 2>/dev/null",':');
		main::get_configs(@data);
	}
	eval $end if $b_log;
}
}

########################################################################
#### OUTPUT
########################################################################

#### -------------------------------------------------------------------
#### FILTERS AND TOOLS
#### -------------------------------------------------------------------

sub apply_filter {
	my ($string) = @_;
	if ($string){
		$string = ( $show{'filter'} ) ? $filter_string : $string;
	}
	else {
		$string = 'N/A';
	}
	return $string;
}

sub clean_characters {
	my ($data) = @_;
	# newline, pipe, brackets, + sign, with space, then clear doubled
	# spaces and then strip out trailing/leading spaces.
	$data =~ s/\n|\|\+|\[\s\]|\s\s+/ /g if $data; 
	$data =~ s/^\s+|\s+$//g if $data;
	return $data;
}

sub cleaner {
	my ($item) = @_;
	return $item if !$item;# handle cases where it was 0 or ''
	$item =~ s/chipset|components|computing|computer|corporation|communications|electronics|electrical|electric|gmbh|group|incorporation|industrial|international|nee|revision|semiconductor|software|technologies|technology|ltd\.|<ltd>|inc\.|<inc>|intl\.|co\.|<co>|corp\.|<corp>|\(tm\)|\(r\)||\(rev ..\)|\'|\"|\sinc\s*$//gi;
	$item =~ s/,|\*/ /g;
	$item =~ s/\s\s+/ /g;
	$item =~ s/^\s+|\s+$//g;
	return $item;
}

# not used, but keeping logic for now
sub increment_starters {
	my ($key,$indexes) = @_;
	my $result = $key;
	if (defined $$indexes{$key} ){
		$$indexes{$key}++;
		$result = "$key-$$indexes{$key}";
	}
	return $result;
}
sub memory_data_full {
	eval $start if $b_log;
	my ($source) = @_;
	my $num = 0;
	my ($memory,$percent,$report,@rows);
	if (!$show{'info'}){
		$memory = get_memory_data();
		$memory ||= 'N/A';
		$memory =~ /(.+\s[MGTP]B)( \(([^\)]+)\))?/;
		$report = $1;
		$percent = $3 if $3; 
		$rows[0]{$num++ . "#System Memory"} = '' if $source eq 'process';
		$rows[0]{$num++ . "#Used/Total"} = $report;
		$rows[0]{$num++ . "#used"} = $percent if $percent;
	}
	$b_mem = 1;
	eval $end if $b_log;
	return @rows;
}

sub pci_cleaner {
	my ($string) = @_;
	$string =~ s/\[[^\]]+\]$|compatible\scontroller|device|controller|multimedia|\([^)]+\)//g;
	$string =~ s/^\s+|\s+$//g;
	return $string;
}

sub row_defaults {
	my ($type,$id) = @_;
	$id ||= '';
	my %unfound = (
	'arm-pci' => "ARM systems do not support PCI data type",
	'battery-data' => "No battery data found. Is one present?",
	'battery-data-sys' => "No /sys data found. Old system?",
	'data-bsd' => "Feature not supported yet for BSDs.",
	'display-console' => 'No advanced graphics data found on this system in console.',
	'display-null' => 'No advanced graphics data found on this system.',
	'display-root' => 'Advanced graphics data unavailable in console for root.',
	'display-root-x' => 'Advanced graphics data unavailable for root. Old System?',
	'display-server' => "No display server data found. Headless server?",
	'display-tool' => "Unable to show advanced data. Required tool $id missing.",
	'display-try' => 'Advanced graphics data unavailable in console. Try -G --display',
	'dev' => 'Feature under development',
	'IP' => "No $id data found. Connected to the web? SSL issues?",
	'machine-data' => "No machine data: try newer kernel.",
	'machine-data-alt-33' => "No machine data: try newer kernel. Is dmidecode installed? Try -M --alt 33.",
	'machine-data-dmidecode' => "No machine data: try newer kernel, or install dmidecoce.",
	'optical-data' => "No Optical or Floppy data was found.",
	'output-limit' => "Output throttled. IPs: $id; Limit: $limit; Override: --limit [1-x;-1 all]",
	'pci-advanced-data' => 'bus/chip ids unavailable',
	'pci-card-data' => "No PCI card data found.",
	'pci-slot-data' => "No PCI slot data found. SOC?",
	'ram-data' => "No RAM data was found. SOC?",
	'sensors-data-linux' => "No sensors data was found. Is sensors configured?",
	'usb-data' => "No USB data was found. Server?",
	'weather-null' => "No $id found. Internet connection working?",
	);
	return $unfound{$type};
}

#### -------------------------------------------------------------------
#### GENERATE OUTPUT
#### -------------------------------------------------------------------

sub output_handler {
	my (%data) = @_;
	# print Dumper \%data;
	if ($output_type eq 'screen'){
		print_data(%data);
	}
	elsif ($output_type eq 'csv'){
		generate_csv(%data);
	}
	elsif ($output_type eq 'json'){
		generate_json(%data);
	}
	elsif ($output_type eq 'xml'){
		generate_xml(%data);
	}
}
sub print_basic {
	my (@data) = @_;
	my $indent = 18;
	my $indent_static = 18;
	my $indent1_static = 5;
	my $indent2_static = 8;
	my $indent1 = 5;
	my $indent2 = 8;
	my $length =  @data;
	my ($start,$aref,$i,$j,$line);
	
	if ( $size{'max'} > 110 ){
		$indent_static = 22;
	}
	elsif ($size{'max'} < 90 ){
		$indent_static = 15;
	}
	# print $length . "\n";
	for my $i (0 .. $#data){
		$aref = $data[$i];
		#print "0: $data[$i][0]\n";
		if ($data[$i][0] == 0 ){
			$indent = 0;
			$indent1 = 0;
			$indent2 = 0;
		}
		elsif ($data[$i][0] == 1 ){
			$indent = $indent_static;
			$indent1 = $indent1_static;
			$indent2= $indent2_static;
		}
		elsif ($data[$i][0] == 2 ){
			$indent = ( $indent_static + 7 );
			$indent1 = ( $indent_static + 5 );
			$indent2 = 0;
		}
		$data[$i][3] =~ s/\n/ /g;
		$data[$i][3] =~ s/\s+/ /g;
		if ($data[$i][1] && $data[$i][2]){
			$data[$i][1] = $data[$i][1] . ', ';
		}
		$start = sprintf("%${indent1}s%-${indent2}s",$data[$i][1],$data[$i][2]);
		if ($indent > 1 && ( length($start) > ( $indent - 1) ) ){
			$line = sprintf("%-${indent}s\n", "$start");
			print_line($line);
			$start = '';
			#print "1-print.\n";
		}
		if ( ( $indent + length($data[$i][3]) ) < $size{'max'} ){
			$data[$i][3] =~ s/\^/ /g;
			$line = sprintf("%-${indent}s%s\n", "$start", $data[$i][3]);
			print_line($line);
			#print "2-print.\n";
		}
		else {
			my $holder = '';
			my $sep = ' ';
			foreach my $word (split / /, $data[$i][3]){
				#print "$word\n";
				if ( ( $indent + length($holder) + length($word) ) < $size{'max'} ) {
					$word =~ s/\^/ /g;
					$holder .= $word . $sep;
					#print "3-hold.\n";
				}
				#elsif ( ( $indent + length($holder) + length($word) ) >= $size{'max'}){
				else {
					$line = sprintf("%-${indent}s%s\n", "$start", $holder);
					print_line($line);
					$start = '';
					$word =~ s/\^/ /g;
					$holder = $word . $sep;
					#print "4-print-hold.\n";
				}
			}
			if ($holder !~ /^[ ]*$/){
				$line = sprintf("%-${indent}s%s\n", "$start", $holder);
				print_line($line);
				#print "5-print-last.\n";
			}
		}
	}
}
# this has to get a hash of hashes, at least for now.
# because perl does not retain insertion order, I use a prefix for each
# hash key to force sorts. 
sub print_data {
	my (%data) = @_;
	my $array = 0;
	my $counter=0;
	my $split_count = 0;
	my $hash = 0;
	my $holder = '';
	my $start = '';
	my $start2 = '';
	my $length = 0;
	my $indent = $size{'indent'};
	my (@temp,@working,@values,%ids,$holder2,%row);
	my ($key,$line,$val2,$val3);
	# $size{'max'} = 88;
	if ($size{'max'} < $size{'indent-min'}){
		$indent = 2;
	}
	foreach my $key1 (sort { (split/#/, $a)[0] <=> (split/#/, $b)[0] } keys %data) {
		$key = (split/#/, $key1)[1];
		if ($key ne 'SHORT' ) {
			$start = sprintf("$colors{'c1'}%-${indent}s$colors{'cn'}","$key$sep{'s1'}");
			if ($indent < 10){
				$line = "$start\n";
				print_line($line);
				$start = '';
				$line = '';
			}
		}
		else {
			$indent = 0;
		}
		if (ref($data{$key1}) eq 'ARRAY'){
			# @working = @{$data{$key1}};
			%ids = (
			'Array' => 1,
			'Battery' => 1,
			'Card' => 1,
			'Device' => 1,
			'Floppy' => 1,
			'ID' => 1,
			'Optical' => 1,
			);
			foreach my $val1 (@{$data{$key1}}){
				$length = $indent;
				if (ref($val1) eq 'HASH'){
					#%row = %$val1;
					$counter=0;
					$split_count = 0;
					$hash = scalar %$val1;
					foreach my $key2 (sort { (split/#/, $a)[0] <=> (split/#/, $b)[0] } keys %$val1){
						$key = (split/#/, $key2)[1];
						if ($counter == 0 && defined $ids{$key}){
							$key .= '-' . $ids{$key}++;
						}
						$val2 = $$val1{$key2};
						# we have to handle cases where $val2 is 0
						if ($val2 || $val2 eq '0'){
							$val2 .= " ";
						}
						# see: Use of implicit split to @_ is deprecated. Only get this warning
						# in Perl 5.08 oddly enough.
						@temp = split/\s+/, $val2;
						$split_count = scalar @temp;
						if ( ( length( "$key$sep{'s2'} $val2" ) + $length ) < $size{'max'} ) {
							$length += length("$key$sep{'s2'} $val2");
							$holder .= "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val2";
							#print "one\n";
						}
						# handle case where the opening key/value pair is > max, and where 
						# there are a lot of terms, like cpu flags, raid types supported. Raid
						# can have the last row have a lot of devices, or many raid types
						elsif ( ( length( "$key$sep{'s2'} $val2" ) + $indent ) > $size{'max'} && 
								   !defined $ids{$key} && $split_count > 2 ) {
							@values = split/\s+/, $val2;
							$val3 = shift @values;
							# $length += length("$key$sep{'s2'} $val3 ") + $indent;
							$start2 = "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val3 ";
							$holder2 = '';
							$length += length("$key$sep{'s2'} $val3 ");
							# print scalar @values,"\n";
							foreach (@values){
								# my $l =  (length("$_ ") + $length);
								#print "$l\n";
								if ( (length("$_ ") + $length) < $size{'max'} ){
									#print "a\n";
 									if ($start2){
										$holder2 .= "$start2$_ ";
										$start2 = '';
										#$length += $length2;
										#$length2 = 0;
									}
									else {
										$holder2 .= "$_ ";
									}
									$length += length("$_ ");
								}
								else {
									#print "three\n";
									if ($start2){
										$holder2 = "$start2$holder2";
									}
									else {
										$holder2 = "$colors{'c2'}$holder2";
									}
									#print "xx:$holder";
									$line = sprintf("%-${indent}s%s$colors{'cn'}\n","$start","$holder$holder2");
									print_line($line);
									$holder = '';
									
									$holder2 = "$_ ";
									#print "h2: $holder2\n";
									$length = length($holder2) + $indent;
									$start2 = '';
									$start = '';
									#$length2 = 0;
								}
							}
							if ($holder2 !~ /^\s*$/){
								#print "four\n";
								$holder2 = "$colors{'c2'}$holder2";
								$line = sprintf("%-${indent}s%s$colors{'cn'}\n","$start","$holder$holder2");
								print_line($line);
								$holder = '';
								$holder2 = '';
								$length = $indent;
								$start2 = '';
								$start = '';
								#$length2 = 0;
							}
						}
						else {
							#print "H: $counter $hash\n";
							if ($holder){
								#print "five\n";
								$line = sprintf("%-${indent}s%s$colors{'cn'}\n",$start,"$holder");
								$holder = "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val2";
								$length = length("$key$sep{'s2'} $val2") + $indent;
								print_line($line);
								$start = '';
							}
							else {
								#print "six\n";
								$holder = "$colors{'c1'}$key$sep{'s2'}$colors{'c2'} $val2";
								#$line = sprintf("%-${indent}s%s$colors{'cn'}\n",$start,"$holder");
								$length = $indent;
								#$holder = '';
							}
						}
						$counter++;
					}
					if ($holder !~ /^\s*$/){
						#print "seven\n";
						$line = sprintf("%-${indent}s%s$colors{'cn'}\n",$start,"$start2$holder");
						print_line($line);
						$holder = '';
						$length = 0;
						$start = '';
					}
				}
				# only for repos?
				elsif (ref($val1) eq 'ARRAY'){
					#print "eight\n";
					$array=0;
					foreach my $item (@$val1){
						$array++;
						$line = "$colors{'c1'}$array$sep{'s2'} $colors{'c2'}$item$colors{'cn'}";
						$line = sprintf("%-${indent}s%s\n","","$line");
						print_line($line);
					}
				}
				else {
					
				}
			}
		}
	}
}

sub print_line {
	my ($line) = @_;
	if ($b_irc && $client{'test-konvi'}){
		$client{'konvi'} = 3;
		$client{'dobject'} = 'Konversation';
	}
	if ($client{'konvi'} == 1 && $client{'dcop'} ){
		# konvi doesn't seem to like \n characters, it just prints them literally
		$line =~ s/\n//g;
		#qx('dcop "$client{'dport'}" "$client{'dobject'}" say "$client{'dserver'}" "$client{'dtarget'}" "$line 1");
		system('dcop', $client{'dport'}, $client{'dobject'}, 'say', $client{'dserver'}, $client{'dtarget'}, "$line 1");
	}
	elsif ($client{'konvi'} == 3 && $client{'qdbus'} ){
		# print $line;
		$line =~ s/\n//g;
		#qx(qdbus org.kde.konversation /irc say "$client{'dserver'}" "$client{'dtarget'}" "$line");
		system('qdbus', 'org.kde.konversation', '/irc', 'say', $client{'dserver'}, $client{'dtarget'}, $line);
	}
	else {
		print $line;
	}
}

sub show_version {
	require Cwd;
	import Cwd;
	# if not in PATH could be either . or directory name, no slash starting
	my $working_path=$self_path;
	my (@data, @row, @rows, $link, $self_string);
	if ( $working_path eq '.' ){
		$working_path = getcwd();
	}
	elsif ( $working_path !~ /^\// ){
		$working_path = getcwd() . "/$working_path";
	}
	# handle if it's a symbolic link, rare, but can happen with directories 
	# in irc clients which would only matter if user starts inxi with -! 30 override 
	# in irc client
	if ( -l "$working_path/$self_name" ){
		$link="$working_path/$self_name";
		$working_path = readlink "$working_path/$self_name";
		$working_path =~ s/[^\/]+$//;
	}
	@row = [ 0, '', '', "$self_name $self_version-$self_patch ($self_date)"];
	push @data, @row;
	if ( ! $b_irc ){
		my $year = (split/-/, $self_date)[0];
		@row = [ 0, '', '', "Program Location: $working_path" ];
		push @data, @row;
		if ( $link ){
			@row = [ 0, '', '', "Started via symbolic link: $link" ];
			push @data, @row;
		}
		@rows = (
		[ 0, '', '', "Website:^https://github.com/smxi/inxi^or^http://smxi.org/" ],
		[ 0, '', '', "IRC:^irc.oftc.net channel:^#smxi" ],
		[ 0, '', '', "Forums:^http://techpatterns.com/forums/forum-33.html" ],
		[ 0, '', '', " " ],
		[ 0, '', '', "$self_name - the universal, portable, system information tool 
		for console and irc." ],
		[ 0, '', '', "Using Perl version: $]"],
		[ 0, '', '', " " ],
		[ 0, '', '', "This program started life as a fork of Infobash 3.02: 
		Copyright^(C)^2005-2007^Michiel^de^Boer^a.k.a.^locsmif." ],
		[ 0, '', '', "Subsequent changes and modifications (after Infobash 3.02): 
		Copyright^(C)^2008-$year^Harald^Hope^aka^h2. 
		CPU/Konversation^fixes:^Scott^Rogers^aka^trash80.
		USB^audio^fixes:^Steven^Barrett^aka^damentz." ],
		[ 0, '', '', '' ],
		[ 0, '', '', "This program is free software; you can redistribute it and/or modify 
		it under the terms of the GNU General Public License as published by the Free Software 
		Foundation; either version 3 of the License, or (at your option) any later version. 
		(http://www.gnu.org/licenses/gpl.html)" ]
		);
		push @data, @rows;
	}
	print_basic(@data); 
	exit 1;
}

########################################################################
#### DATA PROCESSORS
########################################################################

#### -------------------------------------------------------------------
#### PRIMARY DATA GENERATORS
#### -------------------------------------------------------------------
# 0 type
# 1 type_id
# 2 bus_id
# 3 sub_id
# 4 device
# 5 vendor_id
# 6 chip_id
# 7 rev
# 8 port
# 9 driver
# 10 modules

## AudioData 
{
package AudioData;

sub get {
	eval $start if $b_log;
	my (@data,@rows);
	my $num = 0;
	if ($b_arm){
		my $key = 'ARM';
		@data = ({
		$num++ . "#$key" => main::row_defaults('arm-pci',''),
		},);
		@rows = (@rows,@data);
	}
	else {
		@data = card_data();
		@rows = (@rows,@data);
		if (!@rows && (my $file = main::system_files('asound-cards') ) ){
			@data = asound_data($file);
			@rows = (@rows,@data);
		}
		@data = usb_data();
		@rows = (@rows,@data);
		if (!@rows){
			my $key = 'Message';
			@data = ({
			$num++ . "#$key" => main::row_defaults('pci-card-data',''),
			},);
			@rows = (@rows,@data);
		}
		else {
			@data = sound_server_data();
			@rows = (@rows,@data);
		}
	}
	eval $end if $b_log;
	return @rows;
}

sub card_data {
	eval $start if $b_log;
	my (@rows,@data);
	my ($j,$num) = (0,1);
	foreach (@pci){
		$num = 1;
		my @row = @$_;
		if ($row[0] eq 'audio'){
			$j = scalar @rows;
			my $driver = $row[9];
			$driver ||= 'N/A';
			@data = ({
			$num++ . "#Card" => $row[4],
			$num++ . "#driver" => $driver,
			},);
			@rows = (@rows,@data);
			if ($extra > 1 && !$bsd_type){
				if ($row[9] ){
					my $version = main::get_module_version($row[9]);
					$rows[$j]{$num++ . "#v"} = $version if $version;
				}
			}
			if ($extra > 0){
				$rows[$j]{$num++ . "#bus ID"} = "$row[2].$row[3]";
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = "$row[5]:$row[6]";
			}
		}
		#print "$row[0]\n";
	}
	#my $ref = $pci[-1];
	#print $$ref[0],"\n";
	eval $end if $b_log;
	return @rows;
}
# this handles fringe cases where there is no card on pcibus,
# but there is a card present. I don't know the exact architecture
# involved but I know this situation exists on at least one old machine.
sub asound_data {
	eval $start if $b_log;
	my ($file) = @_;
	my (@asound,@rows,@data);
	my ($card,$driver,$j,$num) = ('','',0,1);
	@asound = main::reader($file);
	foreach (@asound){
		# filtering out modems and usb devices like webcams, this might get a
		# usb audio card as well, this will take some trial and error
		if ( !/modem|usb/i && /^\s*[0-9]/ ) {
			my @working = split /:\s*/, $_;
			# now let's get 1 2
			$working[1] =~ /(.*)\s+-\s+(.*)/;
			$card = $2;
			$driver = $1;
			if ( $card ){
				$j = scalar @rows;
				$driver ||= 'N/A';
				@data = ({
				$num++ . "#Card" => $card,
				$num++ . "#driver" => $driver,
				},);
				@rows = (@rows,@data);
				if ($extra > 0){
					my $version = main::get_module_version($driver);
					$rows[$j]{$num++ . "#v"} = $version if $version;
					$rows[$j]{$num++ . "#message"} = main::row_defaults('pci-advanced-data','');
				}
			}
		}
	}
	# print Data::Dumper:Dumper \s@rows;
	eval $end if $b_log;
	return @rows;
}
sub usb_data {
	eval $start if $b_log;
	my (@rows,@data,@ids,$vendor,$product);
	my ($j,$num) = (0,1);
	if (-d '/proc/asound') {
		# note: this will double the data, but it's easier this way.
		# inxi tested for -L in the /proc/asound files, and used only those.
		my @files = glob('/proc/asound/*/usbid');
		foreach (@files){
			my $id = (main::reader($_))[0];
			push @ids, $id if ($id && ! grep {/$id/} @ids);
		}
		# lsusb is a very expensive operation
		if (@ids){
			if (!$bsd_type && !$b_usb_check){
				main::set_usb_data();
				$b_usb_check = 1;
			}
		}
		return if !@usb;
		foreach my $id (@ids){
			$j = scalar @rows;
			foreach my $ref (@usb){
				my @row = @$ref;
				# a device will always be the second or > device on the bus
				if ($row[1] > 1 && $row[2] eq $id){
					if ($usb_level == 1){
						$product = main::cleaner($row[3]);
					}
					else {
						foreach my $line (@row){
							my @working = split /:/, $line;
							if ($working[0] eq 'idVendor'){
								$vendor = main::cleaner($working[2]) if $working[2];
							}
							if ($working[0] eq 'idProduct'){
								$product = main::cleaner($working[2]) if $working[2];
							}
							if ($vendor && $product){
								$product = ($product =~ /$vendor/) ? $product: "$vendor $product" ;
								last;
							}
						}
					}
					@data = ({
					$num++ . "#Card" => $product,
					$num++ . "#driver" => 'USB Audio',
					},);
					@rows = (@rows,@data);
					if ($extra > 0){
						$rows[$j]{$num++ . "#bus ID"} = "$row[0]:$row[1]";
					}
					if ($extra > 1){
						$rows[$j]{$num++ . "#chip ID"} = $row[2];
					}
				}
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}
sub sound_server_data {
	eval $start if $b_log;
	my (@data,$server,$version);
	my $num = 0;
	if (my $file = main::system_files('asound-version') ){
		my $content = (main::reader($file))[0];
		# some alsa strings have the build date in (...)
		# remove trailing . and remove possible second line if compiled by user
# 		foreach (@content){
# 			if (!/compile/i){
				#$_ =~ s/Advanced Linux Sound Architecture/ALSA/;
				$version = (split /\s+/, $content)[-1];
				$version =~ s/\.$//; # trim off period
				$server = 'ALSA';
# 			}
# 		}
	}
	elsif (my $program = main::check_program('oss')){
		$server = 'OSS';
		$version = main::program_version('oss','\S',2);
		$version ||= 'N/A';
	}
	if ($server){
		@data = ({
		$num++ . "#Sound Server" => $server,
		$num++ . "#v" => $version,
		},);
	}
	eval $end if $b_log;
	return @data;
}
}

## BatteryData
{
package BatteryData;

sub get {
	eval $start if $b_log;
	my (@rows,$key1,%battery,$val1);
	my $num = 0;
	if ($bsd_type || $b_dmidecode_force){
		my $ref = $alerts{'dmidecode'};
		if ( $$ref{'action'} ne 'use'){
			$key1 = $$ref{'action'};
			$val1 = $$ref{$key1};
			$key1 = ucfirst($key1);
			@rows = ({$num++ . "#$key1" => $val1,});
		}
		else {
			%battery = battery_data_dmi();
			if (!%battery){
				if ($show{'battery-forced'}){
					$key1 = 'Message';
					$val1 = main::row_defaults('battery-data','');
					@rows = ({$num++ . "#$key1" => $val1,});
				}
			}
			else {
				@rows = create_battery_data(%battery);
			}
		}
	}
	elsif (-d '/sys/class/power_supply/'){
		%battery = battery_data_sys();
		if (!%battery){
			if ($show{'battery-forced'}){
				$key1 = 'Message';
				$val1 = main::row_defaults('battery-data','');
				@rows = ({$num++ . "#$key1" => $val1,});
			}
		}
		else {
			@rows = create_battery_data(%battery);
		}
	}
	else {
		if ($show{'battery-forced'}){
			$key1 = 'Message';
			$val1 = main::row_defaults('battery-data-sys','');
			@rows = ({$num++ . "#$key1" => $val1,});
		}
	}
	eval $end if $b_log;
	return @rows;
}
# alarm capacity capacity_level charge_full charge_full_design charge_now 
# 	cycle_count energy_full energy_full_design energy_now location manufacturer model_name 
# 	power_now present serial_number status technology type voltage_min_design voltage_now
# 0  name - battery id, not used
# 1  status
# 2  present
# 3  technology
# 4  cycle_count
# 5  voltage_min_design
# 6  voltage_now
# 7  power_now
# 8  energy_full_design
# 9  energy_full
# 10 energy_now
# 11 capacity
# 12 capacity_level
# 13 of_orig
# 14 model_name
# 15 manufacturer
# 16 serial_number
# 17 location
sub create_battery_data {
	eval $start if $b_log;
	my (%battery,@data,@rows) = @_;
	my ($key);
	my $num = 0;
	my $j = 0;
	foreach $key (sort keys %battery){
		$num = 0;
		my ($charge,$condition,$model,$serial,$status,$volts) = ('','','','','','');
		my ($chemistry,$cycles,$location) = ('','','');
		# $battery{$key}{''};
		$charge = ($battery{$key}{'energy_now'}) ? "$battery{$key}{'energy_now'} Wh" : 'N/A';
		if ($battery{$key}{'energy_full'} || $battery{$key}{'energy_full_design'}){
			$battery{$key}{'energy_full_design'} ||= 'N/A';
			$battery{$key}{'energy_full'} ||= 'N/A';
			$condition = "$battery{$key}{'energy_full'}/$battery{$key}{'energy_full_design'} Wh";
			if ($battery{$key}{'of_orig'}){
				$condition .= " ($battery{$key}{'of_orig'}%)"; 
			}
		}
		$condition ||= 'N/A';
		$j = scalar @rows;
		@data = ({
		$num++ . "#$key" => '',
		$num++ . "#charge" => $charge,
		$num++ . "#condition" => $condition,
		},);
		@rows = (@rows,@data);
		if ($extra > 0){
			if ($extra > 1){
				if ($battery{$key}{'voltage_min_design'} || $battery{$key}{'voltage_now'}){
					$battery{$key}{'voltage_min_design'} ||= 'N/A';
					$battery{$key}{'voltage_now'} ||= 'N/A';
					$volts = "$battery{$key}{'voltage_now'}/$battery{$key}{'voltage_min_design'}";
				}
				$volts ||= 'N/A';
				$rows[$j]{$num++ . "#volts"} = $volts;
			}
			if ($battery{$key}{'manufacturer'} || $battery{$key}{'model_name'}) {
				if ($battery{$key}{'manufacturer'} && $battery{$key}{'model_name'}){
					$model = "$battery{$key}{'manufacturer'} $battery{$key}{'model_name'}";
				}
				elsif ($battery{$key}{'manufacturer'}){
					$model = $battery{$key}{'manufacturer'};
				}
				elsif ($battery{$key}{'model_name'}){
					$model = $battery{$key}{'model_name'};
				}
			}
			else {
				$model = 'N/A';
			}
			$rows[$j]{$num++ . "#model"} = $model;
			if ($extra > 2){
				$chemistry = ( $battery{$key}{'technology'} ) ? $battery{$key}{'technology'}: 'N/A';
				$rows[$j]{$num++ . "#type"} = $chemistry;
			}
			if ($extra > 1){
				$serial = main::apply_filter($battery{$key}{'serial_number'});
				$rows[$j]{$num++ . "#serial"} = $serial;
			}
			$status = ($battery{$key}{'status'}) ? $battery{$key}{'status'}: 'N/A';
			$rows[$j]{$num++ . "#status"} = $status;
			if ($extra > 2){
				if ($battery{$key}{'cycle_count'}){
					$rows[$j]{$num++ . "#cycles"} = $battery{$key}{'cycle_count'};
				}
				if ($battery{$key}{'location'}){
					$rows[$j]{$num++ . "#location"} = $battery{$key}{'location'};
				}
			}
		}
	}
	
	eval $end if $b_log;
	return @rows;
}

# charge: mAh energy: Wh
sub battery_data_sys {
	eval $start if $b_log;
	my ($b_ma,%battery,$file,$id,$item,$path,$value);
	my $num = 0;
	my @batteries = main::globber("/sys/class/power_supply/BAT*/");
	# note: there is no 'location' file, but dmidecode has it
	# 'type' is generic, like: Battery
	# capacity_level is a string, like: Normal
	my @items = qw(alarm capacity capacity_level charge_full charge_full_design charge_now 
	cycle_count energy_full energy_full_design energy_now location manufacturer model_name 
	power_now present serial_number status technology type voltage_min_design voltage_now);
	foreach $item (@batteries){
		$b_ma = 0;
		$id = $item;
		$id =~ s%/sys/class/power_supply/|\/$%%g;
		$id =~ s/BAT/BAT-/;
		$battery{$id} = ({});
		foreach $file (@items){
			$path = "$item$file";
			$value = (-f $path) ? (main::reader($path))[0]: '';
			if ($value){
				if ($file eq 'voltage_min_design'){
					$value = sprintf("%.1f", $value/1000000);
				}
				elsif ($file eq 'voltage_now'){
					$value = sprintf("%.1f", $value/1000000);
				}
				elsif ($file eq 'energy_full_design'){
					$value = $value/1000000;
				}
				elsif ($file eq 'energy_full'){
					$value = $value/1000000;
				}
				elsif ($file eq 'energy_now'){
					$value = sprintf("%.1f", $value/1000000);
				}
				# note: the following 3 were off, 100000 instead of 1000000
				# why this is, I do not know. I did not document any reason for that
				# so going on assumption it is a mistake. CHARGE is mAh, which are converted
				# to Wh by: mAh x voltage. Note: voltage fluctuates so will make results vary slightly.
				elsif ($file eq 'charge_full_design'){
					$value = $value/1000000;
					$b_ma = 1;
				}
				elsif ($file eq 'charge_full'){
					$value = $value/1000000;
					$b_ma = 1;
				}
				elsif ($file eq 'charge_now'){
					$value = $value/1000000;
					$b_ma = 1;
				}
			}
			$battery{$id}{$file} = $value;
			# print "$battery{$id}{$file}\n";
		}
		# note:voltage_now fluctuates, which will make capacity numbers change a bit
		# if any of these values failed, the math will be wrong, but no way to fix that
		# tests show more systems give right capacity/charge with voltage_min_design 
		# than with voltage_now
		if ($b_ma && $battery{$id}{'voltage_min_design'}){
			if ($battery{$id}{'charge_now'}){
				$battery{$id}{'energy_now'} = $battery{$id}{'charge_now'} * $battery{$id}{'voltage_min_design'};
			}
			if ($battery{$id}{'charge_full'}){
				$battery{$id}{'energy_full'} = $battery{$id}{'charge_full'}*$battery{$id}{'voltage_min_design'};
			}
			if ($battery{$id}{'charge_full_design'}){
				$battery{$id}{'energy_full_design'} = $battery{$id}{'charge_full_design'} * $battery{$id}{'voltage_min_design'};
			}
		}
		if ( $battery{$id}{'energy_now'} && $battery{$id}{'energy_full'} ){
			$battery{$id}{'capacity'} = 100 * $battery{$id}{'energy_now'}/$battery{$id}{'energy_full'};
			$battery{$id}{'capacity'} = sprintf( "%.1f", $battery{$id}{'capacity'} );
		}
		if ( $battery{$id}{'energy_full_design'} && $battery{$id}{'energy_full'} ){
			$battery{$id}{'of_orig'} = 100 * $battery{$id}{'energy_full'}/$battery{$id}{'energy_full_design'};
			$battery{$id}{'of_orig'} = sprintf( "%.0f", $battery{$id}{'of_orig'} );
		}
		if ( $battery{$id}{'energy_now'} ){
			$battery{$id}{'energy_now'} = sprintf( "%.1f", $battery{$id}{'energy_now'} );
		}
		if ( $battery{$id}{'energy_full_design'} ){
			$battery{$id}{'energy_full_design'} = sprintf( "%.1f",$battery{$id}{'energy_full_design'} );
		}
		if ( $battery{$id}{'energy_full'} ){
			$battery{$id}{'energy_full'} = sprintf( "%.1f", $battery{$id}{'energy_full'} );
		}
	}
	eval $end if $b_log;
	return %battery;
}
# note, dmidecode does not have charge_now or charge_full
sub battery_data_dmi {
	eval $start if $b_log;
	my (%battery,$id);
	my $i = 0;
	foreach (@dmi){
		my @ref = @$_;
		# Portable Battery
		if ($ref[0] == 22){
			$id = "BAT-$i";
			$i++;
			$battery{$id} = ({});
			# skip first three row, we don't need that data
			splice @ref, 0, 3 if @ref;
			foreach my $item (@ref){
				my @value = split /:\s+/, $item;
				next if !$value[0];
				if ($value[0] eq 'Location') {$battery{$id}{'location'} = $value[1] }
				elsif ($value[0] eq 'Manufacturer') {$battery{$id}{'manufacturer'} = $value[1] }
				elsif ($value[0] =~ /Chemistry/) {$battery{$id}{'technology'} = $value[1] }
				elsif ($value[0] =~ /Serial Number/) {$battery{$id}{'serial_number'} = $value[1] }
				elsif ($value[0] =~ /^Name/) {$battery{$id}{'model_name'} = $value[1] }
				elsif ($value[0] eq 'Design Capacity') {
					$value[1] =~ s/\s*mwh$//i;
					$battery{$id}{'energy_full_design'} = sprintf( "%.1f", $value[1]/1000);
					
				}
				elsif ($value[0] eq 'Design Voltage') {
					$value[1] =~ s/\s*mv$//i;
					$battery{$id}{'voltage_min_design'} = sprintf( "%.1f", $value[1]/1000);
				}
			}
			if ($battery{$id}{'energy_now'} && $battery{$id}{'energy_full'} ){
				$battery{$id}{'capacity'} = 100 * $battery{$id}{'energy_now'} / $battery{$id}{'energy_full'};
				$battery{$id}{'capacity'} = sprintf( "%.1f%", $battery{$id}{'capacity'} );
			}
			if ($battery{$id}{'energy_full_design'} && $battery{$id}{'energy_full'} ){
				$battery{$id}{'of_orig'} = 100 * $battery{$id}{'energy_full'} / $battery{$id}{'energy_full_design'};
				$battery{$id}{'of_orig'} = sprintf( "%.0f%", $battery{$id}{'of_orig'} );
			}
		}
		elsif ($ref[0] > 22){
			last;
		}
	}
	# print Data::Dumper::Dumper \%battery;
	eval $end if $b_log;
	return %battery;
}
}

## CpuData
{
package CpuData;

sub get {
	eval $start if $b_log;
	my ($type) = @_;
	my (@data,@rows,$single,$key1,$val1);
	my $num = 0;
	if ($type eq 'short' || $type eq 'basic'){
		@rows = data_short($type);
	}
	else {
		@rows = create_full_data();
	}
	return @rows;
	eval $end if $b_log;
}
sub create_full_data {
	eval $start if $b_log;
	my $num = 0;
	my ($b_flags,$flag_key,@flags,%cpu,@data,@rows);
	my $sleep = $cpu_sleep * 1000000;
	Time::HiRes::usleep( $sleep );
	if (my $file = main::system_files('cpuinfo')){
		%cpu = data_cpuinfo($file,'full');
	}
	elsif ($bsd_type ){
		my ($key1,$val1) = ('','');
		if ( $alerts{'sysctl'} ){
			if ( $alerts{'sysctl'}{'action'} eq 'use' ){
# 				$key1 = 'Status';
# 				$val1 = main::row_defaults('dev');
				%cpu = data_sysctl('full');
			}
			else {
				$key1 = ucfirst($alerts{'sysctl'}{'action'});
				$val1 = $alerts{'sysctl'}{$alerts{'sysctl'}{'action'}};
				@data = ({$num++ . "#$key1" => $val1,});
				return @data;
			}
		}
	}
	my %properties = cpu_properties(%cpu);
	my $type = ($properties{'cpu-type'}) ? $properties{'cpu-type'}: '';
	my $ref = $cpu{'processors'};
	my @processors = @$ref;
	my @speeds = cpu_speeds(@processors);
	
	my $j = scalar @rows;
	@data = ({
	$num++ . "#Topology" => $properties{'cpu-layout'},
	$num++ . "#model" => $cpu{'model_name'},
	},);
	@rows = (@rows,@data);
	if ($type){
		$rows[$j]{$num++ . "#type"} = $type;
	}
	if ($extra > 0){
		my $arch = $cpu{'arch'};
		$arch ||= 'N/A';
		$rows[$j]{$num++ . "#arch"} = $arch;
		if ($extra > 1 && $arch ne 'N/A' && $cpu{'rev'} ){
			$rows[$j]{$num++ . "#rev"} = $cpu{'rev'};
		}
	}
	$properties{'l2-cache'} ||= 'N/A';
	$rows[$j]{$num++ . "#L2 cache"} = $properties{'l2-cache'};
	if ($extra > 0 && !$show{'cpu-flag'}){
		$j = scalar @rows;
		@flags = split /\s+/, $cpu{'flags'} if $cpu{'flags'};
		$flag_key = ($b_arm || $bsd_type) ? 'features': 'flags';
		my $flag = 'N/A';
		if (@flags){
			# failure to read dmesg.boot: dmesg.boot permissions
			@flags = grep {/^(dmesg.boot|lm|nx|pae|permissions|pni|svm|vmx|(sss|ss)e([2-9])?([a-z])?(_[0-9])?)$/} @flags;
			@flags = map {s/pni/sse3/; $_} @flags;
			@flags = sort(@flags);
			$flag = join ' ', @flags if @flags;
		}
		if ($b_arm && $flag eq 'N/A'){
			$flag = 'use -f option to see features'
		}
		@data = ({
		$num++ . "#$flag_key" => $flag,
		},);
		@rows = (@rows,@data);
		$b_flags = 1;
	}
	if ($extra > 0 && !$bsd_type){
		my $bogomips = ($cpu{'bogomips'}) ? int($cpu{'bogomips'}) : 'N/A';
		$rows[$j]{$num++ . "#bogomips"} = $bogomips;
	}
	$j = scalar @rows;
	my $core_key = (scalar @speeds > 1) ? 'Core speeds' : 'Core speed';
	my $min_max = ($properties{'min-max'}) ? $properties{'min-max'}: 'N/A';
	my $min_max_key = ($properties{'min-max-key'}) ? $properties{'min-max-key'}: 'min/max';
	# aren't able to get per core speeds in bsds yet
	my $core_speeds_value = (@speeds) ? '' : 'N/A';
	$j = scalar @rows;
	@data = ({
	$num++ . "#$properties{'speed-key'}" => $properties{'speed'},
	$num++ . "#$min_max_key" => $min_max,
	$num++ . "#$core_key" => $core_speeds_value,
	},	);
	@rows = (@rows,@data);
	my $i = 1;
	foreach (@speeds){
		$rows[$j]{$num++ . "#" . $i++} = $_;
	}
	if ($show{'cpu-flag'} && !$b_flags){
		$flag_key = ($b_arm || $bsd_type) ? 'Features': 'Flags';
		@flags = split /\s+/, $cpu{'flags'} if $cpu{'flags'};
		my $flag = 'N/A';
		if (@flags){
			@flags = sort(@flags);
			$flag = join ' ', @flags if @flags;
		}
		@data = ({
		$num++ . "#$flag_key" => $flag,
		},);
		@rows = (@rows,@data);
	}
	eval $end if $b_log;
	return @rows;
}
sub data_short {
	eval $start if $b_log;
	my ($type) = @_;
	my $num = 0;
	my (%cpu,@data,%speeds);
	my $sys = '/sys/devices/system/cpu/cpufreq/policy0';
	my $sleep = $cpu_sleep * 1000000;
	Time::HiRes::usleep( $sleep );
	# NOTE: : Permission denied, ie, this is not always readable
	# /sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_cur_freq
	if (my $file = main::system_files('cpuinfo')){
		%cpu = data_cpuinfo($file,$type);
	}
	elsif ($bsd_type ){
		my ($key1,$val1) = ('','');
		if ( $alerts{'sysctl'} ){
			if ( $alerts{'sysctl'}{'action'} eq 'use' ){
# 				$key1 = 'Status';
# 				$val1 = main::row_defaults('dev');
				%cpu = data_sysctl($type);
			}
			else {
				$key1 = ucfirst($alerts{'sysctl'}{'action'});
				$val1 = $alerts{'sysctl'}{$alerts{'sysctl'}{'action'}};
				@data = ({$num++ . "#$key1" => $val1,});
				return @data;
			}
		}
	}
	# $cpu{'cur-freq'} = $cpu[0]{'core-id'}[0]{'speed'};
	if ($type eq 'short' || $type eq 'basic'){
		@data = prep_short_data(%cpu);
	}
	if ($type eq 'basic'){
		@data = create_short_data(@data);
	}
	eval $end if $b_log;
	return @data;
}
sub create_short_data {
	eval $start if $b_log;
	my (@cpu) = @_;
	my @data;
	my $num = 0;
	@data = ({
	$num++ . "#$cpu[0]" => $cpu[1],
	$num++ . "#type" => $cpu[2],
	},);
	if ($extra > 0){
		$data[0]{$num++ . "#arch"} = $cpu[7];
	}
	$data[0]{$num++ . "#$cpu[3]"} = $cpu[4];
	if ($cpu[6]){
		$data[0]{$num++ . "#$cpu[5]"} = $cpu[6];
	}
	
	eval $end if $b_log;
	return @data;
}
sub prep_short_data {
	eval $start if $b_log;
	my (%cpu) = @_;
	my %properties = cpu_properties(%cpu);
	my ($cpu,$speed_key,$speed,$type) = ('N/A','speed','N/A',0,'N/A');
 	if ($cpu{'model_name'}){
		$type = $properties{'cpu-type'} if $properties{'cpu-type'};
		$cpu = $cpu{'model_name'};
 	}
 	$speed_key = $properties{'speed-key'} if $properties{'speed-key'};
 	$speed = $properties{'speed'} if $properties{'speed'};
 	my @result = (
 	$properties{'cpu-layout'},
 	$cpu,
 	$type,
 	$speed_key,
 	$speed,
 	$properties{'min-max-key'},
 	$properties{'min-max'},
 	);
 	if ($extra > 0){
		$cpu{'arch'} ||= 'N/A';
		$result[7] = $cpu{'arch'};
 	}
	eval $end if $b_log;
	return @result;
}

sub data_cpuinfo {
	eval $start if $b_log;
	my ($file,$type)=  @_;
	my ($arch,@ids,@line,$b_first,$b_proc_int);
	# $file = "$ENV{HOME}/bin/scripts/inxi/data/cpu/amd/16-core-32-mt-ryzen.txt";
	#$file = "$ENV{HOME}/bin/scripts/inxi/data/cpu/arm/arm-4-4-speeds-1.txt";
	#$file = "$ENV{HOME}/bin/scripts/inxi/data/cpu/intel/core-2-i3.txt";
	#my @cpuinfo = main::reader($file);
	my %speeds = set_cpu_speeds_sys();
	my @cpuinfo = main::reader($file);
	my ($cache,$die_holder,$die_id,$phys_holder,$phys_id,$proc_count,$speed) = (0,0,0,0,0,0,0);
	# need to prime for arm cpus, which do not have physical/core ids usually
	# level 0 is phys id, level 1 is die id, level 2 is core id
	$ids[0] = ([(0)]);
	$ids[0][0] = ([(0)]);
	my %cpu =  set_cpu_data();
	# note, there con be a lot of processors, 32 core HT would have 64, for example.
	foreach (@cpuinfo){
		next if /^\s*$/;
		@line = split /\s*:\s*/, $_;
		$line[0] = lc($line[0]);
		if ($line[0] eq 'processor'){
			# this protects against double processor lines, one int, one string
			if ($line[1] =~ /^\d+$/){
				$b_proc_int = 1;
				$b_first = 1;
				$cpu{'processors'}[$proc_count] = 0;
				$proc_count++;
			}
			else {
				if (!$b_proc_int){
					$cpu{'processors'}[$proc_count] = 0;
					$proc_count++;
				}
				if (!$b_first ){
					# note: alternate: 
					# Processor	: AArch64 Processor rev 4 (aarch64)
					# but no model name type
					if ( $line[1] =~ /ARM|AArch/){
						$b_arm = 1;
						$cpu{'type'} = 'arm';
					}
					$cpu{'model_name'} = main::cleaner($line[1]);
					$cpu{'model_name'} = cpu_cleaner($cpu{'model'});
				}
				$b_first = 1;
			}
		}
		elsif (!$cpu{'family'} && 
		       ($line[0] eq 'architecture' || $line[0] eq 'cpu family' || $line[0] eq 'cpu architecture' )){
			$cpu{'family'} = uc(sprintf("%x", $line[1]));
		}
		elsif (!$cpu{'rev'} && ($line[0] eq 'stepping' || $line[0] eq 'cpu revision' )){
			$cpu{'rev'} = $line[1];
		}
		# this is hex so uc for cpu arch id
		elsif (!$cpu{'model_id'} && $line[0] eq 'model' ){
			$cpu{'model_id'} = uc(sprintf("%x", $line[1]));
		}
		elsif (!$cpu{'model_id'} && $line[0] eq 'cpu variant' ){
			$cpu{'model_id'} = uc($line[1]);
			$cpu{'model_id'} =~ s/^0X//;
		}
		# cpu can show in arm
		elsif (!$cpu{'model_name'} &&( $line[0] eq 'model name' || $line[0] eq 'cpu' )){
			$cpu{'model_name'} = main::cleaner($line[1]);
			$cpu{'model_name'} = cpu_cleaner($cpu{'model_name'});
			if ( $line[1] =~ /ARM|AArch/){
				$b_arm = 1;
				$cpu{'type'} = 'arm';
			}
		}
		elsif ( $line[0] eq 'cpu mhz' ){
			$speed = speed_cleaner($line[1]);
			$cpu{'processors'}[$proc_count-1] = $speed;
			#$ids[$phys_id][$die_id] = ([($speed)]);
		}
		elsif (!$cpu{'siblings'} && $line[0] eq 'siblings' ){
			$cpu{'siblings'} = $line[1];
		}
		elsif (!$cpu{'cores'} && $line[0] eq 'cpu cores' ){
			$cpu{'cores'} = $line[1];
		}
		# increment by 1 for every new physical id we see. These are in almost all cases
		# separate cpus, not separate dies within a single cpu body.
		elsif ( $line[0] eq 'physical id' ){
			if ($phys_holder != $line[1] ){
				$phys_id++;
				$phys_holder = $line[1];
				$ids[$phys_id] = ([(0)]);
				$ids[$phys_id][$die_id] = ([(0)]);
			}
		}
		elsif ( $line[0] eq 'core id' ){
			if ($line[1] > 0 ){
				$die_holder = $line[1];
			}
			# this handles multi die cpus like 16 core ryzen
			elsif ($line[1] == 0 && $die_holder > 0 ){
				$die_id++ ;
				$die_holder = $line[1];
			}
			$ids[$phys_id][$die_id][$line[1]] = $speed;
			$cpu{'dies'} = $die_id;
		}
		if (!$cpu{'type'} && $line[0] eq 'vendor_id' ){
			$cpu{'type'} = cpu_vendor($line[1]);
		}
		## this is only for -C full cpu output
		if ( $type eq 'full' ){
			if (!$cpu{'l2-cache'} && $line[0] eq 'cache size'){
				if ($line[1] =~ /(\d+)\sKB$/){
					$cpu{'l2-cache'} = $1;
				}
				elsif ($line[1] =~ /(\d+)\sMB$/){
					$cpu{'l2-cache'} = ($1*1024);
				}
			}
			if (!$cpu{'flags'} && ($line[0] eq 'flags' || $line[0] eq 'features' )){
				$cpu{'flags'} = $line[1];
			}
		}
		if ( $extra > 0 && $type eq 'full' ){
			if ($line[0] eq 'bogomips'){
				# new arm shows bad bogomip value, so don't use it
				$cpu{'bogomips'} += $line[1] if $line[1] > 50;
			}
		}
	}
	$cpu{'ids'} = (\@ids);
	if ( $extra > 0 && $type ne 'short' ){
		$cpu{'arch'} = cpu_arch($cpu{'type'},$cpu{'family'},$cpu{'model_id'});
		#print "$cpu{'type'},$cpu{'family'},$cpu{'model_id'},$cpu{'arch'}\n";
	}
	if (!$speeds{'cur-freq'}){
		$cpu{'cur-freq'} = $cpu{'processors'}[0];
		$speeds{'min-freq'} = 0;
		$speeds{'max-freq'} = 0;
	}
	else {
		$cpu{'cur-freq'} = $speeds{'cur-freq'};
		$cpu{'min-freq'} = $speeds{'min-freq'};
		$cpu{'max-freq'} = $speeds{'max-freq'};
	}
	#print Data::Dumper::Dumper \%cpu;
	eval $end if $b_log;
	return %cpu;
}

sub data_sysctl {
	eval $start if $b_log;
	my ($type) = @_;
	my %cpu = set_cpu_data();
	my (@ids,@line,%speeds,@working);
	my ($sep) = ('');
	my ($cache,$die_holder,$die_id,$phys_holder,$phys_id,$proc_count,$speed) = (0,0,0,0,0,0,0);
	
	foreach (@sysctl){
		@line = split /\s*:\s*/, $_;
		next if ! $line[0];
		# darwin shows machine, like MacBook7,1, not cpu
		# machdep.cpu.brand_string: Intel(R) Core(TM)2 Duo CPU     P8600  @ 2.40GHz
		if ( ($bsd_type ne 'darwin' && $line[0] eq 'hw.model' ) || $line[0] eq 'machdep.cpu.brand_string' ){
			# cut L2 cache/cpu max speed out of model string, if available
			# openbsd 5.6: AMD Sempron(tm) Processor 3400+ ("AuthenticAMD" 686-class, 256KB L2 cache)
			# freebsd 10: hw.model: AMD Athlon(tm) II X2 245 Processor
			$line[1] = main::cleaner($line[1]);
			$line[1] = cpu_cleaner($line[1]);
			if ( $line[1] =~ /([0-9]+)[\-[:space:]]*([KM]B)\s+L2 cache/) {
				my $multiplier = ($2 eq 'KB') ? 1024: 1;
				$cpu{'l2-cache'} = $1 * $multiplier;
			}
			if ( $line[1] =~ /([^0-9\.][0-9\.]+)[\-[:space:]]*[MG]Hz/) {
				$cpu{'max-freq'} = $1;
				if ($cpu{'max-freq'} =~ /MHz/i) {
					$cpu{'max-freq'} =~ s/[\-[:space:]]*MHz//;
					$cpu{'max-freq'} = speed_cleaner($cpu{'max-freq'},'mhz');
				}
				elsif ($cpu{'max-freq'} =~ /GHz/) {
					$cpu{'max-freq'} =~ s/[\-[:space:]]*GHz//i;
					$cpu{'max-freq'} = $cpu{'max-freq'} / 1000;
					$cpu{'max-freq'} = speed_cleaner($cpu{'max-freq'},'mhz');
				}
			}
			if ( $line[1] =~ /\)$/ ){
				$line[1] =~ s/\s*\(.*\)$//;
			}
			$cpu{'model_name'} = $line[1];
			$cpu{'type'} = cpu_vendor($line[1]);
		}
		# NOTE: hw.l1icachesize: hw.l1dcachesize:
		elsif ($line[0] eq 'hw.l1icachesize') {
			$cpu{'l1-cache'} = $line[1]/1024;
		}
		elsif ($line[0] eq 'hw.l2cachesize') {
			$cpu{'l2-cache'} = $line[1]/1024;
		}
		# this is in mghz in samples
		elsif ($line[0] eq 'hw.clockrate' || $line[0] eq 'hw.cpuspeed') {
			$cpu{'cur-freq'} = $line[1];
		}
		# these are in hz: 2400000000
		elsif ($line[0] eq 'hw.cpufrequency') {
			$cpu{'cur-freq'} = $line[1]/1000000;
		}
		elsif ($line[0] eq 'hw.busfrequency_min') {
			$cpu{'min-freq'} = $line[1]/1000000;
		}
		elsif ($line[0] eq 'hw.busfrequency_max') {
			$cpu{'max-freq'} = $line[1]/1000000;
		}
		elsif ($line[0] eq 'machdep.cpu.vendor') {
			$cpu{'type'} = cpu_vendor($line[1]);
		}
		# darwin only?
		elsif ($line[0] eq 'machdep.cpu.features') {
			$cpu{'flags'} = lc($line[1]);
		}
		elsif ($line[0] eq 'hw.ncpu' ) {
			$cpu{'cores'} = $line[1];
		}
		# Freebsd does some voltage hacking to actually run at lowest listed frequencies.
		# The cpu does not actually support all the speeds output here but works in freebsd. 
		elsif ($line[0] eq 'dev.cpu.0.freq_levels') {
			$line[1] =~ s/^\s+|\/[0-9]+|\s+$//g;
			if ( $line[1] =~ /[0-9]+\s+[0-9]+/ ) {
				my @temp = split /\s+/, $line[1];
				$cpu{'max-freq'} = $temp[0];
				$cpu{'min-freq'} = $temp[-1];
				$cpu{'scalings'} = \@temp;
			}
		}
		elsif (!$cpu{'cur-freq'} && $line[0] eq 'dev.cpu.0.freq' ) {
			$cpu{'cur-freq'} = $line[1];
		}
		# the following have only been seen in DragonflyBSD data but thumbs up!
		elsif ($line[0] eq 'hw.cpu_topology.members' ) {
			my @temp = split /\s+/, $line[1];
			my $count = scalar @temp;
			$count-- if $count > 0;
			$cpu{'processors'}[$count] = 0;
			# no way to get per processor speeds yet, so assign 0 to each
			foreach (0 .. $count){
				$cpu{'processors'}[$_] = 0;
			}
		}
		elsif ($line[0] eq 'hw.cpu_topology.cpu1.physical_siblings' ) {
			# string, like: cpu0 cpu1
			my @temp = split /\s+/, $line[1];
			$cpu{'siblings'} = scalar @temp;
		}
		# increment by 1 for every new physical id we see. These are in almost all cases
		# separate cpus, not separate dies within a single cpu body.
		elsif ( $line[0] eq 'hw.cpu_topology.cpu0.physical_id' ){
			if ($phys_holder != $line[1] ){
				$phys_id++;
				$phys_holder = $line[1];
				$ids[$phys_id] = ([(0)]);
				$ids[$phys_id][$die_id] = ([(0)]);
			}
		}
		elsif ( $line[0] eq 'hw.cpu_topology.cpu0.core_id' ){
			if ($line[1] > 0 ){
				$die_holder = $line[1];
			}
			# this handles multi die cpus like 16 core ryzen
			elsif ($line[1] == 0 && $die_holder > 0 ){
				$die_id++ ;
				$die_holder = $line[1];
			}
			$ids[$phys_id][$die_id][$line[1]] = $speed;
			$cpu{'dies'} = $die_id;
		}
	}
	if (!$cpu{'flags'}){
		$cpu{'flags'} = cpu_flags_bsd();
	}
	# print Data::Dumper::Dumper \%cpu;
	eval $end if $b_log;
	return %cpu;
}

sub set_cpu_speeds_sys {
	eval $start if $b_log;
	my (@arm,%speeds);
	my $sys = '/sys/devices/system/cpu/cpufreq/policy0';
	my $sys2 = '/sys/devices/system/cpu/cpu0/cpufreq/';
	my ($cur,$min,$max) = ('scaling_cur_freq','scaling_min_freq','scaling_max_freq');
	if (!-d $sys && -d $sys2){
		$sys = $sys2;
		($cur,$min,$max) = ('scaling_cur_freq','cpuinfo_min_freq','cpuinfo_max_freq');
	}
	if (-d $sys){
		$speeds{'cur-freq'} = (main::reader("$sys/$cur"))[0];
		$speeds{'cur-freq'} = speed_cleaner($speeds{'cur-freq'},'khz');
		$speeds{'min-freq'} = (main::reader("$sys/$min"))[0];
		$speeds{'min-freq'} = speed_cleaner($speeds{'min-freq'},'khz');
		$speeds{'max-freq'} = (main::reader("$sys/$max"))[0];
		$speeds{'max-freq'} = speed_cleaner($speeds{'max-freq'},'khz');
		if ($b_arm){
			@arm = main::globber('/sys/devices/system/cpu/cpufreq/policy*/');
			# there are arm chips with two dies, that run at different min max speeds!!
			# see: https://github.com/smxi/inxi/issues/128.
			# it would be slick to show both die min/max/cur speeds, but this is
			# ok for now.
			if (scalar @arm > 1){
				my ($current,$max,$min) = (0,0,0);
				foreach (@arm){
					$_ =~ s/\/$//; # strip off last slash in case globs have them
					my $max_temp = main::reader("$_/cpuinfo_max_freq");
					$max_temp = speed_cleaner($max_temp,'khz');
					if ($max_temp > $max){
						$max = $max_temp;
					}
					my $min_temp = main::reader("$_/cpuinfo_min_freq");
					$min_temp = speed_cleaner($min_temp,'khz');
					if ($min_temp < $min || $min == 0){
						$max = $min_temp;
					}
					my $cur_temp = main::reader("$_/cpuinfo_max_freq");
					$cur_temp = speed_cleaner($cur_temp,'khz');
					if ($cur_temp > $current){
						$current = $cur_temp;
					}
				}
				$speeds{'cur-freq'} = $current if $current;
				$speeds{'max-freq'} = $max if $max;
				$speeds{'min-freq'} = $min if $min;
			}
		}
		# policy4/cpuinfo_max_freq:["2000000"]
		# policy4/cpuinfo_min_freq:["200000"]
		if ($speeds{'min-freq'} > $speeds{'max-freq'} || $speeds{'min-freq'} == $speeds{'max-freq'}){
			$speeds{'min-freq'} = 0;
		}
	}
	eval $end if $b_log;
	return %speeds;
}

sub cpu_properties {
	my (%cpu) = @_;
	my $b_xeon = ($cpu{'model_name'} =~ /Xeon/i) ? 1 : 0;
	my $b_ht = 0;
	my $b_ryzen = 0;
	if ( ($cpu{'type'} && $cpu{'type'} eq 'amd' && $cpu{'family'} eq '17' ) || 
	     $cpu{'model_name'} =~ /Ryzen/i){
		$b_ryzen = 1;
	}
	#my @dies = $phys[0][0];
	my $ref = $cpu{'ids'};
	my @phys = @$ref;
	my $phyical_count = scalar @phys;
	my @processors;
	my ($speed,$speed_key);
	$phyical_count ||= 1; # assume 1 if no id found, as with ARM
	# count unique processors ##
	# note, this fails for intel cpus at times
	$ref = $cpu{'processors'};
	@processors = @$ref;
	#print ref $cpu{'processors'}, "\n";
	my $processors_count = scalar @processors;
	#print Data::Dumper::Dumper \@processors;
	# $cpu_cores is per physical cpu
	my ($cpu_layout,$cpu_type,$min_max,$min_max_key,$cache,$core_count,
	   $cpu_cores,$die_count) = ('','','','',0,0,0,0);
	my @cores;
	# like, intel core duo
	# NOTE: sadly, not all core intel are HT/MT, oh well...
	# if ($b_xeon || $cpu{'model_name'} =~ /intel.*core/i){
	if ($b_xeon ){
		$b_ht = 1;
	}
	foreach my $die_ref ( @phys ){
		my @dies = @$die_ref;
		$core_count = 0;
		$die_count = scalar @dies;
		$cpu{'dies'} = $die_count;
		foreach my $core_ref (@dies){
			my @cores = @$core_ref;
			$core_count += scalar @cores;
			#print 'cores: ' . $core_count, "\n";
		}
	}
	$cpu_cores = $cpu{'cores'} if $cpu{'cores'}; 
	# xeon may show wrong core / physical id count, if it does, fix it. A xeon
	# may show a repeated core id : 0 which gives a fake num_of_cores=1
	if ($b_xeon && $cpu{'siblings'} > 1){
		$cpu_cores = ($cpu{'siblings'}/2); 
	}
	if ($b_ryzen){
		$cpu_cores = $cpu{'cores'}; 
	}
	# final check, override the num of cores value if it clearly is wrong
	# and use the raw core count and synthesize the total instead of real count
	if ( $cpu_cores == 0 && ($cpu{'cores'} * $phyical_count > 1)){
		$cpu_cores = ($cpu{'cores'} * $phyical_count);
	}
	# last check, seeing some intel cpus and vms with intel cpus that do not show any
	# core id data at all, or siblings.
	if ($cpu_cores == 0 && $processors_count > 0){
		$cpu_cores = $processors_count;
	}
	# this happens with BSDs which have very little cpu data available
	if ( $processors_count == 0 && $cpu_cores > 0 ){
		$processors_count = $cpu_cores;
		if ($bsd_type && ($b_ht || $b_ryzen) && $cpu_cores > 2 ){
			$cpu_cores = $cpu_cores/2;;
		}
		my $count = $processors_count;
		$count-- if $count > 0;
		$cpu{'processors'}[$count] = 0;
		# no way to get per processor speeds yet, so assign 0 to each
		# must be a numeric value. Could use raw speed from core 0, but 
		# that would just be a hack.
		foreach (0 .. $count){
			$cpu{'processors'}[$_] = 0;
		}
	}
	#print "pc: $processors_count s: $cpu{'siblings'} cpuc: $cpu_cores corec: $core_count\n";
	# Algorithm:
	# if > 1 processor && processor id (physical id) == core id then Multi threaded (MT)
	# if siblings > 1 && siblings ==  2 * num_of_cores ($cpu{'cores'}) then Multi threaded (MT)
	# if > 1 processor && processor id (physical id) != core id then Multi-Core Processors (MCP)
	# if > 1 processor && processor ids (physical id) > 1 then Symmetric Multi Processing (SMP)
	# if = 1 processor then single core/processor Uni-Processor (UP)
	if ( $processors_count > 1 || ( $b_xeon && $cpu{'siblings'} > 0 ) ) {
		# non-multicore MT
		if ($processors_count == ($cpu_cores * 2)){
			$cpu_type .= 'MT'; 
		}
		elsif ($b_xeon && $cpu{'siblings'} > 1){
			$cpu_type .= 'MT'; 
		}
		elsif ($cpu{'siblings'} > 1 && ($cpu{'siblings'} == 2 * $cpu_cores )){
			$cpu_type .= 'MT'; 
		}
		# non-MT multi-core or MT multi-core
		if ( ($processors_count == $cpu_cores ) || ($phyical_count < $cpu_cores)){
			my $sep = ($cpu_type) ? ' ' : '' ;
			$cpu_type .= $sep . 'MCP'; 
		}
		# >1 cpu sockets active: Symetric Multi Processing
		if ($phyical_count > 1){
			my $sep = ($cpu_type) ? ' ' : '' ;
			$cpu_type .= $sep . 'SMP'; 
		}
	}
	else {
		$cpu_type = 'UP';
	}
	if ($phyical_count > 1){
		$cpu_layout = "$phyical_count ";
	}
	if (!$bsd_type){
		if ($cpu{'dies'} > 1){
			$cpu_layout .= count_alpha($cpu{'dies'}) . ' Die ';
		}
		$cpu_layout .= count_alpha($cpu_cores) . ' Core';
	}
	else {
		$cpu_layout .= count_alpha($cpu_cores) . ' Core';
	}
	# the only possible change for bsds is if we can get phys counts in the future
	if ($bsd_type){
		$cache = $cpu{'l2-cache'} * $phyical_count;
	}
	# AMD SOS chips appear to report full L2 cache per core
	elsif ($cpu{'type'} eq 'amd' && ($cpu{'family'} eq '14' || $cpu{'family'} eq '16')){
		$cache = $cpu{'l2-cache'} * $phyical_count;
	}
	elsif ($cpu{'type'} ne 'intel'){
		$cache = $cpu{'l2-cache'} * $cpu_cores * $phyical_count;
	}
	## note: this handles how intel reports L2, total instead of per core like AMD does
	# note that we need to multiply by number of actual cpus here to get true cache size
	else {
		$cache = $cpu{'l2-cache'} * $phyical_count;
	}
	if ($cache > 10000){
		$cache = sprintf("%.02f MB",$cache/1024);
	}
	elsif ($cache > 0){
		$cache = "$cache KB";
	}
	if ($cpu{'cur-freq'} && $cpu{'min-freq'} && $cpu{'max-freq'} ){
		$min_max = "$cpu{'min-freq'}/$cpu{'max-freq'} MHz";
		$min_max_key = "min/max";
		$speed_key = ($show{'short'} || $show{'cpu-basic'}) ? 'speed' : 'Speed';
		$speed = "$cpu{'cur-freq'} MHz";
 	}
 	elsif ($cpu{'cur-freq'} && $cpu{'max-freq'}){
		$min_max = "$cpu{'max-freq'} MHz";
		$min_max_key = "max";
		$speed_key = ($show{'short'} || $show{'cpu-basic'}) ? 'speed' : 'Speed';
		$speed = "$cpu{'cur-freq'} MHz";
 	}
#  	elsif ($cpu{'cur-freq'} && $cpu{'max-freq'} && $cpu{'cur-freq'} == $cpu{'max-freq'}){
# 		$speed_key = ($show{'short'} || $show{'cpu-basic'}) ? 'speed' : 'Speed';
# 		$speed = "$cpu{'cur-freq'} MHz (max)";
#  	}
 	elsif ($cpu{'cur-freq'} && $cpu{'min-freq'}){
		$min_max = "$cpu{'min-freq'} MHz";
		$min_max_key = "min";
		$speed_key = ($show{'short'} || $show{'cpu-basic'}) ? 'speed' : 'Speed';
		$speed = "$cpu{'cur-freq'} MHz";
 	}
 	elsif ($cpu{'cur-freq'} && !$cpu{'max-freq'}){
		$speed_key = ($show{'short'} || $show{'cpu-basic'}) ? 'speed' : 'Speed';
		$speed = "$cpu{'cur-freq'} MHz";
 	}
 	
	my %cpu_properties = (
	'cpu-layout' => $cpu_layout,
	'cpu-type' => $cpu_type,
	'min-max-key' => $min_max_key,
	'min-max' => $min_max,
	'speed-key' => $speed_key,
	'speed' => $speed,
	'l2-cache' => $cache,
	);
	
	#print Data::Dumper::Dumper \%cpu;
	#print Data::Dumper::Dumper \%cpu_properties;
	#my $dc = scalar @dies;
	#print 'phys: ' . $pc . ' dies: ' . $dc, "\n";
	return %cpu_properties;
}
sub cpu_flags_bsd {
	eval $start if $b_log;
	my ($flags,$sep) = ('','');
	# this will be null if it was not readable
	my $file = main::system_files('dmesg-boot');
	
	if ( $file && ! -r $file ){
		$flags = "dmesg.boot permissions";
	}
	else {
		foreach (@dmesg_boot){
			if ( /Features/ || ( $bsd_type eq "openbsd" && /^cpu0.*\s[a-z][a-z][a-z](\s|,)[a-z][a-z][a-z](\s|,)/ ) ) {
				my @line = split /:/, $_;
				# free bsd has to have weird syntax: <....<b23>,<b34>>
				# Features2=0x1e98220b<SSE3,PCLMULQDQ,MON,SSSE3,CX16,SSE4.1,SSE4.2,POPCNT,AESNI,XSAVE,OSXSAVE,AVX>
				$line[1] =~ s/^[^<]*<|>[^>]*$//g;
				# then get rid of <b23> stuff
				$line[1] =~ s/<[^>]+>//g;
				# and replace commas with spaces
				$line[1] =~ s/,/ /g;
				$flags .= ' ' . $line[1];
			}
			elsif (/real mem/){
				last;
			}
		}
		if ($flags){
			$flags =~ s/\s+/ /g;
			$flags =~ s/^\s+|\s+$//g;
		}
	}
	eval $end if $b_log;
	return $flags;
}
sub cpu_speeds {
	eval $start if $b_log;
	my (@processors) = @_;
	my (@speeds);
	my @files = main::globber("/sys/devices/system/cpu/cpu*/cpufreq/scaling_cur_freq");
	foreach (@files){
		my $speed = (main::reader($_))[0];
		if ($speed || $speed eq '0'){
			$speed = sprintf "%.0f", $speed/1000;
			push @speeds, $speed;
		}
	}
	if (!@speeds){
		foreach (@processors){
			if ($_ || $_ eq '0'){
				$_ = sprintf "%.0f", $_;
				push @speeds, $_;
			}
		}
	}
	#print join '; ', @speeds, "\n";
	eval $end if $b_log;
	return @speeds;
}
sub cpu_vendor {
	eval $start if $b_log;
	my ($string) = @_;
	my ($vendor) = ('');
	$string = lc($string);
	if ($string =~ /intel/) {
		$vendor = "intel"
	}
	elsif ($string =~ /amd/){
		$vendor = "amd"
	}
	# via
	elsif ($string =~ /centaur/){
		$vendor = "centaur"
	}
	eval $end if $b_log;
	return $vendor;
}

sub cpu_arch {
	eval $start if $b_log;
	my ($type,$family,$model) = @_;
	my $arch = '';
	# https://en.wikipedia.org/wiki/List_of_AMD_CPU_microarchitectures
	# print "$type;$family;$model\n";
	if ( $type eq 'amd'){
		if ($family eq '4'){
			if ( $model =~ /^(3|7|8|9|A)$/ ) {$arch = 'Am486'}
			elsif ( $model =~ /^(E|F)$/ ) {$arch = 'Am5x86'}
		}
		elsif ($family eq '5'){
			if ( $model =~ /^(0|1|2|3)$/ ) {$arch = 'K5'}
			elsif ( $model =~ /^(6|7)$/ ) {$arch = 'K6'}
			elsif ( $model =~ /^(8)$/ ) {$arch = 'K6-2'}
			elsif ( $model =~ /^(9|D)$/ ) {$arch = 'K6-3'}
			elsif ( $model =~ /^(A)$/ ) {$arch = 'Geode'}
			}
		elsif ($family eq '6'){
			if ( $model =~ /^(1|2)$/ ) {$arch = 'K7'}
			elsif ( $model =~ /^(3|4)$/ ) {$arch = 'K7 Thunderbird'}
			elsif ( $model =~ /^(6|7|8|A)$/ ) {$arch = 'K7 Palomino+'}
			else {$arch = 'K7'}
		}
		elsif ($family eq 'F'){
			if ( $model =~ /^(4|5|7|8|B|C|E|F|14|15|17|18|1B|1C|1F)$/ ) {$arch = 'K8'}
			elsif ( $model =~ /^(21|23|24|25|27|28|2C|2F)$/ ) {$arch = 'K8 rev.E'}
			elsif ( $model =~ /^(41|43|48|4B|4C|4F|5D|5F|68|6B|6C|6F|7C|7F|C1)$/ ) {$arch = 'K8 rev.F+'}
			else {$arch = 'K8'}
		}
		elsif ($family eq '10'){
			if ( $model =~ /^(2|4|5|6|8|9|A)$/ ) {$arch = 'K10'}
			else {$arch = 'K10'}
		}
		elsif ($family eq '11'){
			if ( $model =~ /^(3)$/ ) {$arch = 'Turion X2 Ultra'}
		}
		# might also need cache handling like 14/16
		elsif ($family eq '12'){
			if ( $model =~ /^(1)$/ ) {$arch = 'Fusion'}
			else {$arch = 'Fusion'}
		}
		# SOC, apu
		elsif ($family eq '14'){
			if ( $model =~ /^(1|2)$/ ) {$arch = 'Bobcat'}
			else {$arch = 'Bobcat'}
		}
		elsif ($family eq '15'){
			if ( $model =~ /^(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F)$/ ) {$arch = 'Bulldozer'}
			elsif ( $model =~ /^(10|11|12|13|14|15|16|17|18|19|1A|1B|1C|1D|1E|1F)$/ ) {$arch = 'Piledriver'}
			elsif ( $model =~ /^(30|31|32|33|34|35|36|37|38|39|3A|3B|3C|3D|3E|3F)$/ ) {$arch = 'Steamroller'}
			elsif ( $model =~ /^(60|61|62|63|64|65|66|67|68|69|6A|6B|6C|6D|6E|6F|70|71|72|73|74|75|76|77|78|79|7A|7B|7C|7D|7E|7F)$/ ) {$arch = 'Excavator'}
			else {$arch = 'Bulldozer'}
		}
		# SOC, apu
		elsif ($family eq '16'){
			if ( $model =~ /^(0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F)$/ ) {$arch = 'Jaguar'}
			elsif ( $model =~ /^(30|31|32|33|34|35|36|37|38|39|3A|3B|3C|3D|3E|3F)$/ ) {$arch = 'Puma'}
			else {$arch = 'Jaguar'}
		}
		elsif ($family eq '17'){
			if ( $model =~ /^(1)$/ ) {$arch = 'Zen'}
			else {$arch = 'Zen'}
		}
	}
	elsif ( $type eq 'arm'){
		if ($family ne ''){$arch="ARMv$family";}
		else {$arch='ARM';}
	}
	# aka VIA
	elsif ( $type eq 'centaur'){ 
		if ($family eq '5'){
			if ( $model =~ /^(4)$/ ) {$arch = 'WinChip C6'}
			elsif ( $model =~ /^(8)$/ ) {$arch = 'WinChip 2'}
			elsif ( $model =~ /^(9)$/ ) {$arch = 'WinChip 3'}
		}
		elsif ($family eq '6'){
			if ( $model =~ /^(6)$/ ) {$arch = 'WinChip-based'}
			elsif ( $model =~ /^(7|8)$/ ) {$arch = 'C3'}
			elsif ( $model =~ /^(9)$/ ) {$arch = 'C3-2'}
			elsif ( $model =~ /^(A|D)$/ ) {$arch = 'C7'}
			elsif ( $model =~ /^(F)$/ ) {$arch = 'Isaiah'}
		}
	}
	elsif ( $type eq 'intel'){
		if ($family eq '4'){
			if ( $model =~ /^(0|1|2|3|4|5|6|7|8|9)$/ ) {$arch = '486'}
		}
		elsif ($family eq '5'){
			if ( $model =~ /^(1|2|3|7)$/ ) {$arch = 'P5'}
			elsif ( $model =~ /^(4|8)$/ ) {$arch = 'P5'} # MMX
			elsif ( $model =~ /^(9)$/ ) {$arch = 'Quark'}
		}
		elsif ($family eq '6'){
			if ( $model =~ /^(1)$/ ) {$arch = 'P6 Pro'}
			elsif ( $model =~ /^(3|5|6)$/ ) {$arch = 'P6 II'}
			elsif ( $model =~ /^(7|8)$/ ) {$arch = 'P6 III'}
			elsif ( $model =~ /^(9)$/ ) {$arch = 'Banias'} # pentium M
			elsif ( $model =~ /^(15)$/ ) {$arch = 'Dothan Tolapai'} # pentium M system on chip
			elsif ( $model =~ /^(D)$/ ) {$arch = 'Dothan'} # Pentium M
			elsif ( $model =~ /^(E)$/ ) {$arch = 'Yonah'}
			elsif ( $model =~ /^(F|16)$/ ) {$arch = 'Conroe'}
			elsif ( $model =~ /^(17|1D)$/ ) {$arch = 'Penryn'}
			elsif ( $model =~ /^(1A|1E|1F|2E|25|2C|2F)$/ ) {$arch = 'Nehalem'}
			elsif ( $model =~ /^(1C|26)$/ ) {$arch = 'Bonnell'}
			elsif ( $model =~ /^(27|35|36)$/ ) {$arch = 'Saltwell'}
			elsif ( $model =~ /^(25|2C|2F)$/ ) {$arch = 'Westmere'}
			elsif ( $model =~ /^(26|27)$/ ) {$arch = 'Bonnell'}
			elsif ( $model =~ /^(2A|2D)$/ ) {$arch = 'Sandy Bridge'}
			elsif ( $model =~ /^(37|4A|4D|5A)$/ ) {$arch = 'Silvermont'}
			elsif ( $model =~ /^(3A|3E)$/ ) {$arch = 'Ivy Bridge'}
			elsif ( $model =~ /^(3C|3F|45|46)$/ ) {$arch = 'Haswell'}
			elsif ( $model =~ /^(3D|47|4F|56)$/ ) {$arch = 'Broadwell'}
			elsif ( $model =~ /^(4E|55|9E)$/ ) {$arch = 'Skylake'}
			elsif ( $model =~ /^(5E)$/ ) {$arch = 'Skylake-S'}
			elsif ( $model =~ /^(4C|5D)$/ ) {$arch = 'Airmont'}
			elsif ( $model =~ /^(8E|9E)$/ ) {$arch = 'Kaby Lake'}
			elsif ( $model =~ /^(57)$/ ) {$arch = 'Knights Landing'}
			elsif ( $model =~ /^(85)$/ ) {$arch = 'Knights Mill'}
			# product codes: https://en.wikipedia.org/wiki/List_of_Intel_microprocessors
			# coming: coffee lake; cannonlake; icelake; tigerlake
		}
		elsif ($family eq 'B'){
			if ( $model =~ /^(1)$/ ) {$arch = 'Knights Corne'}
		}
		elsif ($family eq 'F'){
			if ( $model =~ /^(0|1|2)$/ ) {$arch = 'Netburst Willamette'}
			elsif ( $model =~ /^(3|4|6)$/ ) {$arch = 'Netburst Prescott'} # Nocona
			else {$arch = 'Netburst'}
		}
	}
	eval $end if $b_log;
	return $arch;
}

sub count_alpha {
	my ($count) = @_;
	#print "$count\n";
	my @alpha = qw(Single Dual Triple Quad);
	$count = $alpha[$count-1] if $count > 0 && $count < 5;
	return $count;
}
sub set_cpu_data {
	my %cpu =  (
	'arch' => '',
	'bogomips' => 0,
	'cores' => 0,
	'cur-freq' => 0,
	'dies' => 0,
	'family' => '',
	'flags' => '',
	'ids' => [],
	'l1-cache' => 0, # store in KB
	'l2-cache' => 0, # store in KB
	'l3-cache' => 0, # store in KB
	'max-freq' => 0,
	'min-freq' => 0,
	'model_id' => '',
	'model_name' => '',
	'processors' => [],
	'rev' => '',
	'scalings' => [],
	'siblings' => 0,
	'type' => '',
	);
	return %cpu;
}
# MHZ - cell cpus
sub speed_cleaner {
	my ($speed,$opt) = @_;
	return if ! $speed || $speed eq '0';
	$speed =~ s/[GMK]HZ$//gi;
	$speed = ($speed/1000) if $opt && $opt eq 'khz';
	$speed = sprintf "%.0f", $speed;
	return $speed;
}
sub cpu_cleaner {
	my ($cpu) = @_;
	return if ! $cpu;
	$cpu =~ s/@|cpu |cpu deca|([0-9]+|single|dual|triple|tri|quad|penta|hepta|hexa|octa|multi)[ -]core|ennea|genuine|multi|processor|single|triple|[0-9\.]+ *[MmGg][Hh][Zz]//ig;
	$cpu =~ s/\s\s+/ /g;
	$cpu =~ s/^\s+|\s+$//g;
	return $cpu;
}
}

## DiskData
{
package DiskData;

sub get {
	eval $start if $b_log;
	my (@data,@rows,$key1,$val1);
	my $num = 0;
	if ($show{'disk-total'}){
		$key1 = 'Status';
		$val1 = main::row_defaults('dev');
		@data = ({$num++ . "#$key1" => $val1,});
	}
	elsif ($show{'disk'}){
		$key1 = 'Status';
		$val1 = main::row_defaults('dev');
		@data = ({$num++ . "#$key1" => $val1,});
	}
	@rows = (@rows,@data);
	@data = ();
	if ($show{'optical'} || $show{'optical-basic'}){
		@data = OpticalData::get();
	}
	@rows = (@rows,@data);
	return @rows;
	eval $end if $b_log;
	
}
sub disk_data {
	eval $start if $b_log;
	my (@rows);
	my $num = 0;
	
	eval $end if $b_log;
	return @rows;
}

}

## GraphicData 
{
package GraphicData;
my $driver = ''; # we need this as a fallback in case no xorg.0.log
sub get {
	eval $start if $b_log;
	my (@data,@rows);
	my $num = 0;
	if ($b_arm){
		my $key = 'ARM';
		@data = ({
		$num++ . "#$key" => main::row_defaults('arm-pci',''),
		},);
		@rows = (@rows,@data);
	}
	else {
		@data = card_data();
		@rows = (@rows,@data);
		if (!@rows){
			my $key = 'Message';
			@data = ({
			$num++ . "#$key" => main::row_defaults('pci-card-data',''),
			},);
			@rows = (@rows,@data);
		}
	}
	@data = display_server();
	@rows = (@rows,@data);
	@data = gl_data();
	@rows = (@rows,@data);
	eval $end if $b_log;
	return @rows;
}
# 0 type
# 1 type_id
# 2 bus_id
# 3 sub_id
# 4 device
# 5 vendor_id
# 6 chip_id
# 7 rev
# 8 port
# 9 driver
# 10 modules
# not using 3D controller yet, needs research: |3D controller |display controller
# note: this is strange, but all of these can be either a separate or the same
# card. However, by comparing bus id, say: 00:02.0 we can determine that the
# cards are  either the same or different. We want only the .0 version as a valid
# card. .1 would be for example: Display Adapter with bus id x:xx.1, not the right one
sub card_data {
	eval $start if $b_log;
	my (@rows,@data);
	my ($j,$num) = (0,1);
	foreach (@pci){
		$num = 1;
		my @row = @$_;
		#print "$row[0] $row[3]\n";
		if ($row[3] == 0 && ( $row[0] eq 'vga' || $row[0] eq 'display' || $row[0] eq '3d' ) ){
			#print "$row[0] $row[3]\n";
			$j = scalar @rows;
			$driver = $row[9];
			$driver ||= 'N/A';
			@data = (
			{
			$num++ . "#Card" => $row[4],
			$num++ . "#driver" => $driver,
			},
			);
			@rows = (@rows,@data);
			if ($row[9] && !$bsd_type){
				my $version = main::get_module_version($row[9]);
				$version ||= 'N/A';
				$rows[$j]{$num++ . "#v"} = $version;
			}
			if ($extra > 0){
				$rows[$j]{$num++ . "#bus ID"} = "$row[2].$row[3]";
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = "$row[5]:$row[6]";
			}
		}
		#print "$row[0]\n";
	}
	
	#my $ref = $pci[-1];
	#print $$ref[0],"\n";
	eval $end if $b_log;
	return @rows;
}
sub display_server(){
	eval $start if $b_log;
	my (%graphics,@row);
	my @xdpyinfo;
	my $num = 0;
	# note: this may not always be set, it won't be out of X, for example
	my $server = $ENV{'XDG_SESSION_TYPE'};
	if ($extra > 1){
		$graphics{'compositor'} = display_compositor();
	}
	$server = $ENV{'WAYLAND_DISPLAY'} if (!$server && $ENV{'WAYLAND_DISPLAY'});
	
	if ( $show{'display-data'}){
		# X vendor and version detection.
		# new method added since radeon and X.org and the disappearance of 
		# <X server name> version : ...etc. Later on, the normal textual version string 
		# returned, e.g. like: X.Org version: 6.8.2 
		# A failover mechanism is in place: if $version empty, release number parsed instead
		if (my $program = main::check_program('xdpyinfo')){
			my @xdpyinfo_temp = main::grabber("$program $display_opt 2>/dev/null");
			foreach (@xdpyinfo_temp){
				s/^\s+//;
				s/:\s+/:/;
				push @xdpyinfo, $_ if $_;
			}
			foreach (@xdpyinfo){
				my @working = split /:/, $_;
				if ($working[0] eq 'vendor string'){
					$working[1] =~ s/The\s|\sFoundation//g;
					# some distros, like fedora, report themselves as the xorg vendor, 
					# so quick check here to make sure the vendor string includes Xorg in string
					if ($working[1] !~ /x/i){
						$working[1] .= ' X.org';
					}
					$graphics{'vendor'} = $working[1];
				}
				elsif ($working[0] eq 'version number'){
					$graphics{'version-id'} = $working[1];
				}
				elsif ($working[0] eq 'vendor release number'){
					$graphics{'vendor-release'} = $working[1];
				}
				elsif ($working[0] eq 'X.Org version'){
					$graphics{'xorg-version'} = $working[1];
				}
				elsif ($working[0] eq 'dimensions'){
					$working[1] =~ s/\spixels//;
					$working[1] =~ s/\smillimeters/ mm/;
					if ($graphics{'dimensions'}){
						$graphics{'dimensions'} = ([@{$graphics{'dimensions'}},$working[1]]);
					}
					else {
						$graphics{'dimensions'} = ([$working[1]]);
					}
				}
			}
			#$graphics{'dimensions'} = (\@dimensions);
			# we get a bit more info from xrandr than xdpyinfo, but xrandr fails to handle
			# multiple screens from different video cards
			my $ref = $graphics{'dimensions'};
			if (defined $ref){
				my @screens = @$ref;
				if (scalar @screens == 1){
					if (my $program = main::check_program('xrandr')){
						my @xrandr = main::grabber("$program $display_opt 2>/dev/null",'','strip');
						foreach (@xrandr){
							my @working = split /\s+/,$_;
							print join "$_\n";
							if ($working[1] =~ /\*/){
								$working[1] =~ s/\*|\+//g;
								$working[1] = sprintf("%0.0f",$working[1]);
								my $screen = "$working[0]~$working[1]Hz";
								if ($graphics{'screens'}){
									$graphics{'screens'} = ([@{$graphics{'screens'}},$screen]);
								}
								else {
									$graphics{'screens'} = ([$screen]);
								}
							}
						}
						
					}
				}
			}
			else {
				$graphics{'tty'} = tty_data();
			}
		}
	}
	else {
		$graphics{'tty'} = tty_data();
	}
	# this gives better output than the failure last case, which would only show:
	# for example: X.org: 1.9 instead of: X.org: 1.9.0
	$graphics{'version'} = $graphics{'xorg-version'} if $graphics{'xorg-version'};;
	$graphics{'version'} = x_version() if !$graphics{'version'};
	$graphics{'version'} = $graphics{'version-id'} if !$graphics{'version'};
	
	undef @xdpyinfo;
	#print Data::Dumper::Dumper \%graphics;
	if (%graphics){
		my $resolution = '';
		my $server_string = '';
		if ($graphics{'vendor'}){
			my $version = ($graphics{'version'}) ? " $graphics{'version'}" : '';
			if ($server){
				$server_string = "$server ($graphics{'vendor'}$version)";
			}
			else {
				$server_string = "$graphics{'vendor'}$version";
			}
		}
		elsif ($graphics{'version'}) {
			$server_string = "X.org $graphics{'version'}";
		}
		if ($graphics{'screens'}){
			my $ref = $graphics{'screens'};
			my @screens = @$ref;
			my $sep = '';
			foreach (@screens){
				$resolution .= $sep . $_;
				$sep = ', ';
			}
		}
		my @drivers = x_drivers();
		if (!$server_string && !$graphics{'vendor'} && !@drivers){
			$server_string = main::row_defaults('display-server');
			@row = ({
			$num++ . "#Display Server" => $server_string,
			});
		}
		else {
			$server_string ||= 'N/A';
			# note: if no xorg log, and if wayland, there will be no xorg drivers, 
			# obviously, so we use the last driver found on the card section in that case.
			# those come from lscpi kernel drivers so there should be no xorg/wayland issues.
			$driver = ($drivers[0]) ? $drivers[0]: $driver;
			@row = ({
			$num++ . "#Display Server" => $server_string,
			$num++ . "#driver" => $driver,
			});
			if ($drivers[2]){
				$row[0]{$num++ . "#FAILED"} = $drivers[2];
			}
			if ($drivers[1]){
				$row[0]{$num++ . "#unloaded"} = $drivers[1];
			}
		}
		if ($resolution){
			$row[0]{$num++ . "#resolution"} = $resolution;
		}
		else {
			$graphics{'tty'} ||= 'N/A';
			$row[0]{$num++ . "#tty"} = $graphics{'tty'};
		}
	}
	eval $end if $b_log;
	return @row;
}
sub gl_data(){
	eval $start if $b_log;
	my $num = 0;
	my (@row,$arg);
	#print ("$show{'display-data'} : $b_root\n");
	if ( $show{'display-data'} == 1 || (!$b_root && $show{'display-data'} == 2)){
		if (my $program = main::check_program('glxinfo')){
			# NOTE: glxinfo -B is not always available, unforunately
			my @glxinfo = main::grabber("$program $display_opt 2>/dev/null");
			if (!@glxinfo){
				my $type = 'display-console';
				if ($b_root){
					$type = 'display-root-x';
				}
				elsif ($show{'display-data'} == 1){
					$type = 'display-null';
				}
				@row = ({
				$num++ . "#Message" => main::row_defaults($type),
				});
				return @row;
			}
			@glxinfo = grep {!/^\s/} @glxinfo;
			my $compat_version = '';
			my ($b_compat,@core_profile_version,@direct_render,@renderer,@opengl_version,@working);
			foreach (@glxinfo){
				if (/^opengl renderer/i){
					@working = split /:\s*/, $_;
					$working[1] = main::cleaner($working[1]);
					# Allow all mesas
					if ($working[1] =~ /mesa/i){
						
					}
					push @renderer, $working[1];
				}
				# dropping all conditions from this test to just show full mesa information
				# there is a user case where not f and mesa apply, atom mobo
				# /opengl version/ && ( f || $2 !~ /mesa/ ) {
				elsif (/^opengl version/i){
					# fglrx started appearing with this extra string, does not appear 
					# to communicate anything of value
					@working = split /:\s*/, $_;
					$working[1] =~ s/(Compatibility Profile Context|\(Compatibility Profile\))//;
					$working[1] =~ s/\s\s/ /g;
					$working[1] =~ s/^\s+|\s+$//;
					push @opengl_version, $working[1];
					# note: this is going to be off if ever multi opengl versions appear, never seen one
					@working = split /\s+/, $working[1];
					$compat_version = $working[0];
				}
				elsif (/^opengl core profile version/i){
					# fglrx started appearing with this extra string, does not appear 
					# to communicate anything of value
					@working = split /:\s*/, $_;
					$working[1] =~ s/(Compatibility Profile Context|\((Compatibility|Core) Profile\))//;
					$working[1] =~ s/\s\s/ /g;
					$working[1] =~ s/^\s+|\s+$//;
					push @core_profile_version, $working[1];
				}
				elsif (/direct rendering/){
					@working = split /:\s*/, $_;
					push @direct_render, $working[1];
				}
				# if -B was always available, we could skip this, but it is not
				elsif (/GLX Visuals/){
					last;
				}
			}
			my ($direct_render,$renderer,$version) = ('N/A','N/A','N/A');
			$direct_render = join ', ',  @direct_render if @direct_render;
			if (@core_profile_version && @opengl_version && 
			  join ('', @core_profile_version) ne join( '', @opengl_version)){
				@opengl_version = @core_profile_version;
				$b_compat = 1;
			}
			$version = join ', ', @opengl_version if @opengl_version;
			$renderer = join ', ', @renderer if @renderer;
			@row = ({
			$num++ . "#OpenGL" => '',
			$num++ . "#renderer" => $renderer,
			$num++ . "#version" => $version,
			});
			if ($b_compat && $extra > 1 && $compat_version){
				$row[0]{$num++ . "#compat-v"} = $compat_version;
			}
			$row[0]{$num++ . "#direct render"} = $direct_render;
		}
		else {
			@row = ({
			$num++ . "#Message" => main::row_defaults('display-tool','glxinfo'),
			});
		}
	}
	else {
		my $type = 'display-console';
		my $ref = $alerts{'glxinfo'};
		if ($$ref{'action'} eq 'missing'){
			$type = 'display-tool';
			$arg = 'glxinfo';
		}
		elsif ($b_root){
			$type = 'display-root';
		}
		elsif ($show{'display-data'} == 0){
			$type = 'display-try';
		}
		@row = ({
		$num++ . "#Message" => main::row_defaults($type,$arg),
		});
	}
	eval $end if $b_log;
	return @row;
}
sub tty_data(){
	eval $start if $b_log;
	my ($tty);
	if ($size{'term-cols'}){
		$tty = "$size{'term-cols'}x$size{'term-lines'}";
	}
	elsif ($b_irc && $client{'console-irc'}){
		my $tty_working = main::get_tty_console_irc();
		if (my $program = main::check_program('stty')){
			my $tty_arg = ($bsd_type) ? '-f' : '-F';
			$tty = (main::grabber("$program $tty_arg /dev/pts/$tty_working size 2>/dev/null"))[0];
			if ($tty){
				my @temp = split /\s+/, $tty;
				$tty = "$temp[1]x$temp[0]";
			}
		}
	}
	eval $end if $b_log;
	return $tty;
}
sub x_drivers {
	eval $start if $b_log;
	my ($driver,@driver_data,,%drivers);
	my ($failed,$loaded,$sep,$unloaded) = ('','','','');
	if (my $log = main::system_files('xorg-log')){
		my @xorg = main::reader($log);
		# list is from sgfxi plus non-free drivers
		my $list = 'amdgpu|apm|ark|ati|chips|cirrus|cyrix|fbdev|fglrx|glint|i128|i740|i810|iftv|imstt|intel|ivtv|mach64|mesa|mga|modesetting|neomagic|newport|nouveau|nsc|nvidia|nv|openchrome|radeonhd|radeon|rendition|s3virge|s3|savage|siliconmotion|sisimedia|sisusb|sis|tdfx|tga|trident|tseng|unichrome|v4l|vboxvideo|vesa|vga|via|vmware|voodoo';
		#@xorg = grep {/Failed|Unload|Loading/} @xorg;
		foreach (@xorg){
			# note that in file names, driver is always lower case
			if (/\sLoading.*($list)_drv.so$/i ) {
				$driver=lc($1);
				# we get all the actually loaded drivers first, we will use this to compare the
				# failed/unloaded, which have not always actually been truly loaded
				$drivers{$driver}="loaded";
			}
			# openbsd uses UnloadModule: 
			elsif (/(Unloading\s|UnloadModule).*($list)(_drv.so)?$/i ) {
				$driver=lc($2);
				# we get all the actually loaded drivers first, we will use this to compare the
				# failed/unloaded, which have not always actually been truly loaded
				$drivers{$driver}="unloaded" ;
			}
			# verify that the driver actually started the desktop, even with false failed messages 
			# which can occur. This is the driver that is actually driving the display
			elsif (/Failed.*($list)\"?(_drv.so)?$/i ) {
				$driver=lc($1);
				# we need to make sure that the driver has already been truly loaded, not just 
				# discussed, also set driver to lower case because sometimes it will show as 
				# RADEON or NVIDIA in the actual x start
				if (exists $drivers{$driver}){
					$drivers{$driver}="failed";
				}
			}
		}
		my $sep = '';
		foreach (keys %drivers){
			if ($drivers{$_} eq 'loaded') {
				$sep = ($loaded) ? ',' : '';
				$loaded .= $sep . $_;
			}
			elsif ($drivers{$_} eq 'unloaded') {
				$sep = ($unloaded) ? ',' : '';
				$unloaded .= $sep . $_;
			}
			elsif ($drivers{$_} eq 'failed') {
				$sep = ($failed) ? ',' : '';
				$failed .= $sep . $_;
			}
		}
		$loaded ||= 'none';
		@driver_data = ($loaded,$unloaded,$failed);
	}
	eval $end if $b_log;
	return @driver_data;
}
sub x_version {
	eval $start if $b_log;
	my ($version,@data,$program);
	# IMPORTANT: both commands send version data to stderr!
	if ($program = main::check_program('Xorg')){
		@data = main::grabber("$program -version 2>&1");
	}
	elsif ($program = main::check_program('X')){
		@data = main::grabber("$program -version 2>&1");
	}
	#print Data::Dumper::Dumper \@data;
	if (@data){
		foreach (@data){
			if (/^X.org X server/i){
				my @working = split /\s+/, $_;
				$version = $working[3];
				last;
			}
			elsif (/^X Window System Version/i) {
				my @working = split /\s+/, $_;
				$version = $working[4];
				last;
			}
		}
	}
	eval $end if $b_log;
	return $version;
}
sub display_compositor(){
	eval $start if $b_log;
	my ($compositor);
#  	my $compositors = 'mutter|gnome-shell|kwin|moblin|kmscon|sway|grefson|westford|rustland|fireplace|wayhouse|weston|compton|compiz|swc|dwc';
# 	foreach (@ps_cmd){
# 		if (/($compositors)/){
# 			$compositor = $1;
# 			last;
# 		}
# 	}
	# NOTE: chains of greps of ps data are VERY expensive, so check for program presence
	if (main::check_program('mutter') && (grep {/mutter/} @ps_cmd ) ) {
		$compositor = 'mutter';
	}
	elsif (main::check_program('gnome-shell') && (grep {/gnome-shell/} @ps_cmd ) ) {
		$compositor = 'gnome-shell';
	}
	elsif (main::check_program('kwin') && (grep {/kwin/} @ps_cmd ) ) {
		$compositor = 'kwin';
	}
	elsif (main::check_program('weston') && (grep {/weston/} @ps_cmd ) ) {
		$compositor = 'weston';
	}
	elsif (main::check_program('compton') && (grep {/compton/} @ps_cmd ) ) {
		$compositor = 'compton';
	}
	# owned by: compiz-core in debian
	elsif (main::check_program('compiz') && (grep {/compiz/} @ps_cmd ) ) {
		$compositor = 'compiz';
	}
	# did not find in debian apt
	elsif (main::check_program('moblin') && (grep {/moblin/} @ps_cmd ) ) {
		$compositor = 'moblin';
	}
	# did not find in debian apt
	elsif (main::check_program('kmscon') && (grep {/kmscon/} @ps_cmd ) ) {
		$compositor = 'kmscon';
	}
	# did not find in debian apt
	elsif (main::check_program('sway') && (grep {/sway/} @ps_cmd ) ) {
		$compositor = 'sway';
	}
	# did not find in debian apt
	elsif (main::check_program('grefson') && (grep {/grefson/} @ps_cmd ) ) {
		$compositor = 'grefson';
	}
	# did not find in debian apt
	elsif (main::check_program('westford') && (grep {/westford/} @ps_cmd ) ) {
		$compositor = 'westford';
	}
	# did not find in debian apt
	elsif (main::check_program('rustland') && (grep {/rustland/} @ps_cmd ) ) {
		$compositor = 'rustland';
	}
	# did not find in debian apt
	elsif (main::check_program('ireplace') && (grep {/fireplace/} @ps_cmd ) ) {
		$compositor = 'fireplace';
	}
	# did not find in debian apt
	elsif (main::check_program('wayhouse') && (grep {/wayhouse/} @ps_cmd ) ) {
		$compositor = 'wayhouse';
	}
	# did not find in debian apt
	elsif (main::check_program('swc') && (grep {/swc/} @ps_cmd ) ) {
		$compositor = 'swc';
	}
	# did not find in debian apt
	elsif (main::check_program('dwc') && (grep {/dwc/} @ps_cmd ) ) {
		$compositor = 'dwc';
	}
	eval $end if $b_log;
	return $compositor;
}
}

## MachineData
{
package MachineData;

sub get {
	eval $start if $b_log;
	my (@data,@rows,$key1,$val1,$which);
	my $num = 0;
	if ($bsd_type || $b_dmidecode_force){
		my $ref = $alerts{'dmidecode'};
		if ( $$ref{'action'} ne 'use'){
			$key1 = $$ref{'action'};
			$val1 = $$ref{$key1};
			$key1 = ucfirst($key1);
		}
		else {
			@data = machine_data_dmi();
			if (!@data && !$key1){
				$key1 = 'Message';
				$val1 = main::row_defaults('machine-data','');
			}
		}
	}
	elsif (-d '/sys/class/dmi/id/') {
		@data = machine_data_sys();
		if (!@data){
			$key1 = 'Message';
			$val1 = main::row_defaults('machine-data-dmidecode','');
		}
	}
	elsif (!$bsd_type) {
		$key1 = 'Message';
		$val1 = main::row_defaults('machine-data-alt-33','');
	}
	# if error case, null data, whatever
	if ($key1) {
		@data = ({$num++ . "#$key1" => $val1,});
	}
	return @data;
	eval $end if $b_log;
}

sub machine_data_sys {
	eval $start if $b_log;
	my (%data,$path,$vm);
	my $sys_dir = '/sys/class/dmi/id/';
	my $sys_dir_alt = '/sys/devices/virtual/dmi/id/';
	my @sys_files = qw(bios_vendor bios_version bios_date 
	board_name board_serial board_vendor board_version chassis_type 
	product_name product_serial product_uuid product_version sys_vendor
	);
	if ($extra > 1){
		splice @sys_files, 0, 0, qw( chassis_serial chassis_vendor chassis_version);
	}
	$data{'firmware'} = 'BIOS';
	# print Data::Dumper::Dumper \@sys_files;
	if (!-d $sys_dir ){
		if ( -d $sys_dir_alt){
			$sys_dir = $sys_dir_alt;
		}
		else {
			return 0;
		}
	}
	if ( -d '/sys/firmware/efi'){
		$data{'firmware'} = 'UEFI';
	}
	elsif ( glob('/sys/firmware/acpi/tables/UEFI*') ){
		$data{'firmware'} = 'UEFI [Legacy]';
	}
	foreach (@sys_files){
		$path = "$sys_dir$_";
		if (-r $path){
			$data{$_} = (main::reader($path))[0];
			$data{$_} = ($data{$_}) ? m_cleaner($data{$_}) : '';
		}
		else {
			$data{$_} = '';
		}
	}
	if ($data{'chassis_type'}){
		if ( $data{'chassis_type'} == 1){
			$data{'device'} = get_device_vm($data{'sys_vendor'},$data{'product_name'});
			$data{'device'} ||= 'other-vm?';
		}
		else {
			$data{'device'} = get_device_sys($data{'chassis_type'});
		}
	}
# 	print "sys:\n";
# 	foreach (keys %data){
# 		print "$_: $data{$_}\n";
# 	}
	my @rows = create_output(\%data);
	eval $end if $b_log;
	return @rows;
}

# bios_date: 09/07/2010
# bios_romsize: dmi only
# bios_vendor: American Megatrends Inc.
# bios_version: P1.70
# bios_rev: 8.14:  dmi only
# board_name: A770DE+
# board_serial: 
# board_vendor: ASRock
# board_version: 
# chassis_serial: 
# chassis_type: 3
# chassis_vendor: 
# chassis_version: 
# firmware: 
# product_name: 
# product_serial: 
# product_uuid: 
# product_version: 
# sys_uuid: dmi only
# sys_vendor:
sub machine_data_dmi {
	eval $start if $b_log;
	my (%data,$vm);
	return if ! @dmi;
	$data{'firmware'} = 'BIOS';
	# dmi types:
	# 0 bios; 1 system info; 2 board|base board info; 3 chassis info; 
	# 4 processor info, use to check for hypervisor
	foreach (@dmi){
		my @ref = @$_;
		# bios/firmware
		if ($ref[0] == 0){
			# skip first three row, we don't need that data
			splice @ref, 0, 3 if @ref;
			foreach my $item (@ref){
				if ($item !~ /^~/){ # skip the indented rows
					my @value = split /:\s+/, $item;
					if ($value[0] eq 'Release Date') {$data{'bios_date'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Vendor') {$data{'bios_vendor'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Version') {$data{'bios_version'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'ROM Size') {$data{'bios_romsize'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'BIOS Revision') {$data{'bios_rev'} = m_cleaner($value[1]) }
					elsif ($value[0] =~ /^UEFI is supported/) {$data{'firmware'} = 'UEFI';}
				}
			}
			next;
		}
		# system information
		elsif ($ref[0] == 1){
			# skip first three row, we don't need that data
			splice @ref, 0, 3 if @ref;
			foreach my $item (@ref){
				if ($item !~ /^~/){ # skip the indented rows
					my @value = split /:\s+/, $item;
					if ($value[0] eq 'Product Name') {$data{'product_name'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Version') {$data{'product_version'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Serial Number') {$data{'product_serial'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Manufacturer') {$data{'sys_vendor'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'UUID') {$data{'sys_uuid'} = m_cleaner($value[1]) }
				}
			}
			next;
		}
		# baseboard information
		elsif ($ref[0] == 2){
			# skip first three row, we don't need that data
			splice @ref, 0, 3 if @ref;
			foreach my $item (@ref){
				if ($item !~ /^~/){ # skip the indented rows
					my @value = split /:\s+/, $item;
					if ($value[0] eq 'Product Name') {$data{'board_name'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Serial Number') {$data{'board_serial'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Manufacturer') {$data{'board_vendor'} = m_cleaner($value[1]) }
				}
			}
			next;
		}
		# chassis information
		elsif ($ref[0] == 3){
			# skip first three row, we don't need that data
			splice @ref, 0, 3 if @ref;
			foreach my $item (@ref){
				if ($item !~ /^~/){ # skip the indented rows
					my @value = split /:\s+/, $item;
					if ($value[0] eq 'Serial Number') {$data{'chassis_serial'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Type') {$data{'chassis_type'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Manufacturer') {$data{'chassis_vendor'} = m_cleaner($value[1]) }
					elsif ($value[0] eq 'Version') {$data{'chassis_version'} = m_cleaner($value[1]) }
				}
			}
			if ( $data{'chassis_type'} && $data{'chassis_type'} ne 'Other' ){
				$data{'device'} = $data{'chassis_type'};
			}
			next;
		}
		# this may catch some BSD and fringe Linux cases
		# processor information: check for hypervisor
		elsif ($ref[0] == 4){
			# skip first three row, we don't need that data
			splice @ref, 0, 3 if @ref;
			if (!$data{'device'}){
				if (grep {/hypervisor/i} @ref){
					$data{'device'} = 'virtual-machine';
				}
			}
			last;
		}
		elsif ($ref[0] > 4){
			last;
		}
	}
	if (!$data{'device'}){
		$data{'device'} = get_device_vm($data{'sys_vendor'},$data{'product_name'});
		$data{'device'} ||= 'other-vm?';
	}
# 	print "dmi:\n";
# 	foreach (keys %data){
# 		print "$_: $data{$_}\n";
# 	}
	my @rows = create_output(\%data);
	eval $end if $b_log;
	return @rows;
}
## keys for machine data are:
# 0-sys_vendor 1-product_name 2-product_version 3-product_serial 4-product_uuid 
# 5-board_vendor 6-board_name 7-board_version 8-board_serial 
# 9-bios_vendor 10-bios_version 11-bios_date
## with extra data: 
# 12-chassis_vendor 13-chassis_type 14-chassis_version 15-chassis_serial
## unused: 16-bios_rev  17-bios_romsize 18 - firmware type
sub create_output {
	eval $start if $b_log;
	my ($ref) = @_;
	my (%data,@row,@rows);
	%data = %$ref;
	my $firmware = 'BIOS';
	my $num = 0;
	my $j = 0;
	my ($b_chassis,$b_skip_chassis,$b_skip_system);
	my ($bios_date,$bios_rev,$bios_romsize,$bios_vendor,$bios_version,$chassis_serial,
	$chassis_type,$chassis_vendor,$chassis_version, $mobo_model,$mobo_serial,$mobo_vendor,
	$mobo_version,$product_name,$product_serial,$product_version,$system_vendor);
# 	foreach my $key (keys %data){
# 		print "$key: $data{$key}\n";
# 	}
	# found a case of battery existing but having nothing in it on desktop mobo
	# not all laptops show the first. /proc/acpi/battery is deprecated.
	if (!$data{'sys_vendor'}){
		$b_skip_system = 1;
	}
	elsif ( !glob('/proc/acpi/battery/*') && !glob('/sys/class/power_supply/*') ){
		# ibm / ibm can be true; dell / quantum is false, so in other words, only do this
		# in case where the vendor is the same and the version is the same and not null, 
		# otherwise the version information is going to be different in all cases I think
		if ( ($data{'sys_vendor'} && $data{'sys_vendor'} eq $data{'board_vendor'} ) &&
			( ($data{'product_version'} && $data{'product_version'} eq $data{'board_version'} ) ||
			(!$data{'product_version'} && $data{'product_name'} eq $data{'board_name'} ) ) ){
			$b_skip_system = 1;
		}
	}
	$data{'device'} ||= 'N/A';
	$j = scalar @rows;
	@row = ({
	$num++ . "#Device" => ucfirst($data{'device'}),
	},);
	@rows = (@rows,@row);
	if (!$b_skip_system){
		# this has already been tested for above so we know it's not null
		$system_vendor = main::cleaner($data{'sys_vendor'});
		$product_name = ($data{'product_name'})?$data{'product_name'}:'N/A';
		$product_version = ($data{'product_version'})?$data{'product_version'}:'N/A';
		$product_serial = main::apply_filter($data{'product_serial'});
		$rows[$j]{$num++ . "#System"} = $system_vendor;
		$rows[$j]{$num++ . "#product"} = $product_name;
		$rows[$j]{$num++ . "#v"} = $product_version;
		$rows[$j]{$num++ . "#serial"} = $product_serial;
		# no point in showing chassis if system isn't there, it's very unlikely that 
		# would be correct
		if ($extra > 1){
			if ($data{'board_version'} && $data{'chassis_version'} eq $data{'board_version'}){
				$b_skip_chassis = 1;
			}
			if (!$b_skip_chassis && $data{'chassis_vendor'} ){
				if ($data{'chassis_vendor'} ne $data{'sys_vendor'} ){
					$chassis_vendor = $data{'chassis_vendor'};
				}
				if ($data{'chassis_type'} ){
					$chassis_type = $data{'chassis_type'};
				}
				if ($data{'chassis_version'}){
					$chassis_version = $data{'chassis_version'}
				}
				$chassis_serial = main::apply_filter($data{'chassis_serial'});
				$chassis_vendor ||= '';
				$chassis_type ||= '';
				$rows[$j]{$num++ . "#Chassis"} = $chassis_vendor;
				if ($chassis_type){
					$rows[$j]{$num++ . "#type"} = $chassis_type;
				}
				if ($chassis_version){
					$rows[$j]{$num++ . "#v"} = $chassis_version;
				}
				$rows[$j]{$num++ . "#serial"} = $chassis_serial;
			}
		}
		$j++; # start new row
	}
	if ($data{'firmware'}){
		$firmware = $data{'firmware'};
	}
	$mobo_vendor = ($data{'board_vendor'}) ? main::cleaner($data{'board_vendor'}) : 'N/A';
	$mobo_model = ($data{'board_name'}) ? $data{'board_name'}: 'N/A';
	$mobo_version = ($data{'board_version'})? $data{'board_version'} : '';
	$mobo_serial = main::apply_filter($data{'board_serial'});
	$bios_vendor = ($data{'bios_vendor'}) ? main::cleaner($data{'bios_vendor'}) : 'N/A';
	if ($data{'bios_version'}){
		$bios_version = $data{'bios_version'};
		if ($data{'bios_rev'}){
			$bios_rev = $data{'bios_rev'};
		}
		$bios_version ||= 'N/A';
	}
	if ($data{'bios_date'}){
		$bios_date = $data{'bios_date'};
	}
	if ($extra > 1 && $data{'bios_romsize'}){
		$bios_romsize = $data{'bios_romsize'};
	}
	$rows[$j]{$num++ . "#Mobo"} = $mobo_vendor;
	$rows[$j]{$num++ . "#model"} = $mobo_model;
	if ($mobo_version){
		$rows[$j]{$num++ . "#v"} = $mobo_version;
	}
	$rows[$j]{$num++ . "#serial"} = $mobo_serial;
	$rows[$j]{$num++ . "#$firmware"} = $bios_vendor;
	$rows[$j]{$num++ . "#v"} = $bios_version;
	if ($bios_rev){
		$rows[$j]{$num++ . "#rev"} = $bios_rev;
	}
	$rows[$j]{$num++ . "#date"} = $bios_date;
	if ($bios_romsize){
		$rows[$j]{$num++ . "#rom size"} = $bios_romsize;
	}
	eval $end if $b_log;
	return @rows;
}

sub get_device_sys {
	eval $start if $b_log;
	my ($chasis_id) = @_;
	my ($device) = ('');
	my @chassis;
	$chassis[2] = 'unknown';
	# note: 13 is all-in-one which we take as a mac type system
	$chassis[3] = 'desktop';
	$chassis[4] = 'desktop';
	$chassis[6] = 'desktop';
	$chassis[7] = 'desktop';
	$chassis[13] = 'desktop';
	$chassis[15] = 'desktop';
	$chassis[24] = 'desktop';
	# 5 - pizza box was a 1 U desktop enclosure, but some old laptops also id this way
	$chassis[5] = 'pizza-box';
	$chassis[9] = 'laptop';
	# note: lenovo T420 shows as 10, notebook,  but it's not a notebook
	$chassis[10] = 'laptop';
	$chassis[16] = 'laptop';
	$chassis[14] = 'notebook';
	$chassis[8] = 'portable';
	$chassis[11] = 'portable';
	$chassis[17] = 'server';
	$chassis[23] = 'server';
	$chassis[25] = 'server';
	$chassis[27] = 'blade';
	$chassis[25] = 'blade';
	$chassis[29] = 'blade';
	$chassis[12] = 'docking-station';
	$chassis[18] = 'expansion-chassis';
	$chassis[19] = 'sub-chassis';
	$chassis[20] = 'bus-expansion';
	$chassis[21] = 'peripheral';
	$chassis[22] = 'RAID';
	$chassis[26] = 'compact-PCI';
	$device = $chassis[$chasis_id] if $chassis[$chasis_id];
	eval $end if $b_log;
	return $device;
}

sub get_device_vm {
	eval $start if $b_log;
	my ($manufacturer,$product_name) = @_;
	my $vm;
	if ( my $program = main::check_program('systemd-detect-virt') ){
		my $vm_test = (main::grabber("$program 2>/dev/null"))[0];
		$vm = $vm_test if ( $vm_test && $vm_test ne 'none');
	}
	if (!$vm || lc($vm) eq 'bochs') {
		if (-e '/proc/vz'){$vm = 'openvz'}
		elsif (-e '/proc/xen'){$vm = 'xen'}
		elsif (-e '/dev/vzfs'){$vm = 'virtuozzo'}
		elsif (my $program = main::check_program('lsmod')){
			my @vm_data = main::grabber("$program 2>/dev/null");
			if (@vm_data){
				if (grep {/kqemu/i} @vm_data){$vm = 'kqemu'}
				elsif (grep {/kvm/i} @vm_data){$vm = 'kvm'}
				elsif (grep {/qemu/i} @vm_data){$vm = 'qemu'}
			}
		}
	}
	# this will catch many Linux systems and some BSDs
	if (!$vm || lc($vm) eq 'bochs' ) {
		my @vm_data = (@pci,@sysctl,@dmesg_boot);
		if (-e '/dev/disk/by-id'){
			my @dev = glob('/dev/disk/by-id/*');
			@vm_data = (@vm_data,@dev);
		}
		if ( grep {/innotek|vbox|virtualbox/i} @vm_data){
			$vm = 'virtualbox';
		}
		elsif (grep {/vmware/i} @vm_data){
			$vm = 'vmware';
		}
		elsif (grep {/Virtual HD/i} @vm_data){
			$vm = 'hyper-v';
		}
		if (!$vm && (my $file = main::system_files('cpuinfo'))){
			my @info = main::reader($file);
			$vm = 'virtual-machine' if grep {/^flags.*hypervisor/} @info;
		}
		if (!$vm && -e '/dev/vda' || -e '/dev/vdb' || -e '/dev/xvda' || -e '/dev/xvdb' ){
			$vm = 'virtual-machine';
		}
	}
	if (!$vm  && $product_name){
		if ($product_name eq 'VMware'){
			$vm = 'vmware';
		}
		elsif ($product_name eq 'VirtualBox'){
			$vm = 'virtualbox';
		}
		elsif ($product_name eq 'KVM'){
			$vm = 'kvm';
		}
		elsif ($product_name eq 'Bochs'){
			$vm = 'qemu';
		}
	}
	if (!$vm && $manufacturer && $manufacturer eq 'Xen'){
		$vm = 'xen';
	}
	eval $end if $b_log;
	return $vm;
}

sub m_cleaner {
	my ($string) = @_;
	#my @filters = ('Base Board .*','^Chassis .*','.*O\.E\.M\..*','.*OEM.*',
	#'^System .*','^Not .*','.*unknow.*','.*N\/A.*','Default string','','none',
	#'^To be filled.*');
	$string =~ s/^Base Board .*|^Chassis .*|.*O\.E\.M\..*|.*OEM.*|^Not .*|^System .*|.*unknow.*|.*N\/A.*|Default string|none|^To be filled.*//;
	$string =~ s/^\s+|\bbios\b|\bacpi\b|\s+$//g;
	$string =~ s/http:\/\/www.abit.com.tw\//Abit/;
	$string =~ s/\s\s+/ /g;
	return $string;
}
}

## NetworkData 
{
package NetworkData;
my $b_ip_run;
sub get {
	eval $start if $b_log;
	my (@data,@rows);
	my $num = 0;
	if ($b_arm){
		my $key = 'ARM';
		@data = ({
		$num++ . "#$key" => main::row_defaults('arm-pci',''),
		},);
		@rows = (@rows,@data);
	}
	else {
		@data = card_data();
		@rows = (@rows,@data);
		@data = usb_data();
		@rows = (@rows,@data);
	}
	if ($show{'ip'}){
# 		if ($bsd_type){
# 			@data = if_ip('all');
# 			@rows = (@rows,@data);
# 		}
		@data = wan_ip();
		@rows = (@rows,@data);
	}
	eval $end if $b_log;
	return @rows;
}
# 1 type_id
# 2 bus_id
# 3 sub_id
# 4 device
# 5 vendor_id
# 6 chip_id
# 7 rev
# 8 port
# 9 driver
# 10 modules
# 11 driver nu (bsds)
sub card_data {
	eval $start if $b_log;
	my ($b_wifi,@rows,@data,%holder);
	my ($j,$num) = (0,1);
	foreach (@pci){
		$num = 1;
		my @row = @$_;
		#print "$row[0] $row[3]\n";
		if ($row[0] eq 'network' || $row[0] eq 'ethernet' ){
			#print "$row[0] $row[3]\n";
			$j = scalar @rows;
			my $driver = $row[9];
			my $chip_id = "$row[5]:$row[6]";
			# working around a virtuo bug same chip id is used on two nics
			if (!defined $holder{$chip_id}){
				$holder{$chip_id} = 0;
			}
			else {
				$holder{$chip_id}++; 
			}
			# first check if it's a known wifi id'ed card, if so, no print of duplex/speed
			$b_wifi = ($row[4] =~ /wireless|wifi|wi-fi|wlan|802\.11|centrino/i) ? 1 : 0;
			$driver ||= 'N/A';
			@data = (
			{
			$num++ . "#Card" => $row[4],
			$num++ . "#driver" => $driver,
			},
			);
			@rows = (@rows,@data);
			
			if ($extra > 0){
				if ($row[9] && !$bsd_type){
					my $version = main::get_module_version($row[9]);
					$version ||= 'N/A';
					$rows[$j]{$num++ . "#v"} = $version;
				}
				$row[8] ||= 'N/A';
				$rows[$j]{$num++ . "#port"} = $row[8];
				$rows[$j]{$num++ . "#bus ID"} = $row[2];
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = $chip_id;
			}
			if ($show{'network-advanced'}){
				if (!$bsd_type){
					@data = advanced_data_sys($row[5],$row[6],$holder{$chip_id},$b_wifi);
				}
				else {
					@data = advanced_data_bsd("$row[9]$row[11]",$b_wifi);
				}
				@rows = (@rows,@data);
			}
		}
		#print "$row[0]\n";
	}
	if (!@rows){
		my $key = 'Message';
		@data = ({
		$num++ . "#$key" => main::row_defaults('pci-card-data',''),
		},);
		@rows = (@rows,@data);
	}
	#my $ref = $pci[-1];
	#print $$ref[0],"\n";
	eval $end if $b_log;
	return @rows;
}
sub advanced_data_sys {
	eval $start if $b_log;
	return if ! -d '/sys/class/net';
	my ($vendor,$chip,$count,$b_wifi) = @_;
	my $num = 0;
	my (@row,@rows,$if);
	my @paths = glob('/sys/class/net/*');
	@paths = grep {!/\/lo$/} @paths;
	if ( $count > 0 && $count < scalar @paths ){
		@paths = splice @paths, $count, scalar @paths;
	}
	#print join '; ', @paths,  $count, "\n";
	foreach (@paths){
		my $path = "$_/device/vendor";
		my ($data1,$data2,$duplex,$mac,$speed,$state);
		$data1 = (main::reader($path))[0] if -e $path;
		$data1 =~ s/^0x//;
		$path = "$_/device/device";
		$data2 = (main::reader($path))[0] if -e $path;
		$data2 =~ s/^0x//;
		# this is a fix for a redhat bug in virtio 
		$data2 = ($data2 eq '0001' && $chip eq '1000') ? '1000' : $data2;
		#print "d1:$data1 v:$vendor d2:$data2 c:$chip\n";
		if ($data1 && $data2 && $data1 eq $vendor && $data2 eq $chip) {
			my $j = scalar @rows - 1;
			$if = $_;
			$if =~ s/^\/.+\///;
			$path = "$_/duplex";
			$duplex = (main::reader($path))[0] if -e $path;
			$duplex ||= 'N/A';
			$path = "$_/address";
			$mac = (main::reader($path))[0] if -e $path;
			$mac = main::apply_filter($mac);
			$path = "$_/speed";
			$speed = (main::reader($path))[0] if -e $path;
			$speed ||= 'N/A';
			$path = "$_/operstate";
			$state = (main::reader($path))[0] if -e $path;
			$state ||= 'N/A';
			#print "$speed \n";
			@rows = ({
			$num++ . "#IF" => $if,
			$num++ . "#state" => $state,
			},);
			# no print out for wifi since it doesn't have duplex/speed data available
			# note that some cards show 'unknown' for state, so only testing explicitly
			# for 'down' string in that to skip showing speed/duplex
			if (!$b_wifi && $state ne 'down' && $state ne 'no'){
				# make sure the value is strictly numeric before appending Mbps
				$speed = ($speed =~ /^[0-9]+$/) ? "$speed Mbps" : $speed;
				$rows[$j]{$num++ .  "#speed"} = $speed;
				$rows[$j]{$num++ . "#duplex"} = $duplex;
			}
			$rows[$j]{$num++ . "#mac"} = $mac;
			last;
		}
	}
	if ($show{'ip'}){
		@row = if_ip($if);
		@rows = (@rows,@row);
	}
	eval $end if $b_log;
	return @rows;
}
sub advanced_data_bsd {
	eval $start if $b_log;
	return if ! @ifs_bsd;
	my ($if,$b_wifi) = @_;
	my (@data,@row,@rows,$working_if);
	my ($state,$speed,$duplex,$mac);
	my $num = 0;
	foreach my $ref (@ifs_bsd){
		if (ref $ref ne 'ARRAY'){
			$working_if = $ref;
			# print "$working_if\n";
			next;
		} 
 		else {
			@data = @$ref;
 		}
		if ($working_if eq $if){
			foreach my $line (@data){
				my $j = scalar @rows - 1;
				# ($state,$speed,$duplex,$mac)
				$duplex = $data[2];
				$duplex ||= 'N/A';
				$mac = main::apply_filter($data[3]);
				$speed = $data[1];
				$speed ||= 'N/A';
				$state = $data[0];
				$state ||= 'N/A';
				#print "$speed \n";
				@rows = ({
				$num++ . "#IF" => $if,
				$num++ . "#state" => $state,
				},);
				# no print out for wifi since it doesn't have duplex/speed data available
				# note that some cards show 'unknown' for state, so only testing explicitly
				# for 'down' string in that to skip showing speed/duplex
				if (!$b_wifi && $state ne 'down' && $state ne 'no'){
					# make sure the value is strictly numeric before appending Mbps
					$speed = ($speed =~ /^[0-9]+$/) ? "$speed Mbps" : $speed;
					$rows[$j]{$num++ .  "#speed"} = $speed;
					$rows[$j]{$num++ . "#duplex"} = $duplex;
				}
				$rows[$j]{$num++ . "#mac"} = $mac;
			}
			if ($show{'ip'}){
				@row = if_ip($if);
				@rows = (@rows,@row);
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}
## values:
# 0 - ipv 
# 1 - ip 
# 2 - broadcast, if found 
# 3 - scope, if found 
# 4 - scope if, if different from if
sub if_ip {
	eval $start if $b_log;
	$b_ip_run = 1;
	my ($if) = @_;
	my (@data,@row,@rows,$working_if);
	my $num = 0;
	my $j = 0;
	OUTER:
	foreach my $ref (@ifs){
		if (ref $ref ne 'ARRAY'){
			$working_if = $ref;
			# print "if:$if wif:$working_if\n";
			next;
		} 
 		else {
			@data = @$ref;
			# print "ref:$ref\n";
 		}
		if ($working_if eq $if || $if eq 'all'){
			foreach my $ref2 (@data){
				$j = scalar @rows;
				if ($limit > 0 && $j >= $limit){
					@row  = ({
					$num++ . "#Message" => main::row_defaults('output-limit',scalar @data),
					},);
					@rows = (@rows,@row);
					last OUTER;
				}
				my @data2 = @$ref2;
				#print "$data2[0] $data2[1]\n";
				my ($ipv,$ip,$broadcast,$scope,$scope_id);
				$ipv = ($data2[0])? $data2[0]: 'N/A';
				$ip = main::apply_filter($data2[1]);
				$scope = ($data2[3])? $data2[3]: 'N/A';
				if ($if ne 'all'){
					if (defined $data2[4] && $working_if ne $data2[4]){
						# scope global temporary deprecated dynamic 
						# scope global dynamic 
						# scope global temporary deprecated dynamic 
						# scope site temporary deprecated dynamic 
						# scope global eth0
						# scope link
						# scope site dynamic 
						# scope link 
						my $key = ($data2[4] =~ /deprecated|dynamic|temporary/ ) ? 'type':'virtual' ;
						@row  = ({
						$num++ . "#IP v$ipv" => $ip,
						$num++ . "#$key" => $data2[4],
						$num++ . "#scope" => $scope,
						},);
					}
					else {
						@row  = ({
						$num++ . "#IP v$ipv" => $ip,
						$num++ . "#scope" => $scope,
						},);
					}
				}
				else {
					@row  = ({
					$num++ . "#IF" => $if,
					$num++ . "#IP v$ipv" => $ip,
					$num++ . "#scope" => $scope,
					},);
				}
				@rows = (@rows,@row);
				if ($extra > 1 && $data2[2]){
					$broadcast = main::apply_filter($data2[2]);
					$rows[$j]{$num++ . "#broadcast"} = $broadcast;
				}
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}
# get ip using downloader to stdout. This is a clean, text only IP output url,
# single line only, ending in the ip address. May have to modify this in the future
# to handle ipv4 and ipv6 addresses but should not be necessary.
# ip=$( echo  2001:0db8:85a3:0000:0000:8a2e:0370:7334 | gawk  --re-interval '
# ip=$( wget -q -O - $WAN_IP_URL | gawk  --re-interval '
# this generates a direct dns based ipv4 ip address, but if opendns.com goes down, 
# the fall backs will still work. 
# note: consistently slower than domain based: 
# dig +short +time=1 +tries=1 myip.opendns.com. A @208.67.222.222
sub wan_ip {
	eval $start if $b_log;
	my (@data,$ip);
	my $num = 0;
	# time: 0.06 - 0.07 seconds
	if (my $program = main::check_program('dig')){
		$ip = (main::grabber("$program +short +time=1 +tries=1 myip.opendns.com \@resolver1.opendns.com 2>/dev/null"))[0];
	}
	else {
		# note: tests: akamai: 0.055 - 0.065 icanhazip.com: 0.177 0.164
		# smxi: 0.525, so almost 10x slower. Dig is fast too
		# leaving smxi as last test because I know it will always be up.
		my @urls = qw( http://whatismyip.akamai.com/ http://icanhazip.com/ https://smxi.org/opt/ip.php);
		foreach (@urls){
			$ip = main::download_file('stdout',$_);
			if ($ip){
				# print "$_\n";
				chomp $ip;
				$ip = (split /\s+/, $ip)[-1];
				last;
			}
		}
	}
	if ($ip && $show{'filter'}){
		$ip = $filter_string;
	}
	$ip ||= main::row_defaults('IP', 'WAN IP');
	@data = ({
	$num++ . "#WAN IP" => $ip,
	},);
	eval $end if $b_log;
	return @data;
}

sub usb_data {
	eval $start if $b_log;
	my (@rows,@data,$vendor,$product);
	my ($j,$num) = (0,1);
	return if !@usb;
	foreach my $ref (@usb){
		my @row = @$ref;
		$product = '';
		# a device will always be the second or > device on the bus
		if ($row[1] > 1){
			if ($usb_level == 1){
				$product = main::cleaner($row[3]);
			}
			else {
				foreach my $line (@row){
					my @working = split /:/, $line;
					if ($working[0] eq 'idVendor'){
						$vendor = main::cleaner($working[2]) if $working[2];
					}
					if ($working[0] eq 'idProduct'){
						$product = main::cleaner($working[2]) if $working[2];
					}
					if ($vendor && $product){
						$product = ($product =~ /$vendor/) ? $product: "$vendor $product" ;
						last;
					}
				}
			}
			if ($product && network_device($product)){
				@data = ({
				$num++ . "#Card" => $product,
				$num++ . "#driver" => 'USB network',
				},);
				@rows = (@rows,@data);
				if ($extra > 0){
					$rows[$j]{$num++ . "#bus ID"} = "$row[0]:$row[1]";
				}
				if ($extra > 1){
					$rows[$j]{$num++ . "#chip ID"} = $row[2];
				}
				$j = scalar @rows;
				if ($show{'network-advanced'}){
					@data = advanced_data_sys($row[5],$row[6],'usb');
					@rows = (@rows,@data);
				}
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}
### USB networking search string data, because some brands can have other products than
### wifi/nic cards, they need further identifiers, with wildcards.
### putting the most common and likely first, then the less common, then some specifics

# Wi-Fi.*Adapter Wireless.*Adapter Ethernet.*Adapter WLAN.*Adapter 
# Network.*Adapter 802\.11 Atheros Atmel D-Link.*Adapter D-Link.*Wireless Linksys 
# Netgea Ralink Realtek.*Network Realtek.*Wireless Realtek.*WLAN Belkin.*Wireless 
# Belkin.*WLAN Belkin.*Network Actiontec.*Wireless Actiontec.*Network AirLink.*Wireless 
# Asus.*Network Asus.*Wireless Buffalo.*Wireless Davicom DWA-.*RangeBooster DWA-.*Wireless 
# ENUWI-.*Wireless LG.*Wi-Fi Rosewill.*Wireless RNX-.*Wireless Samsung.*LinkStick 
# Samsung.*Wireless Sony.*Wireless TEW-.*Wireless TP-Link.*Wireless 
# WG[0-9][0-9][0-9].*Wireless WNA[0-9][0-9][0-9] WNDA[0-9][0-9][0-9] 
# Zonet.*ZEW.*Wireless
sub network_device {
	eval $start if $b_log;
	my ($device) = @_;
	my ($b_network);
	# belkin=050d; d-link=07d1; netgear=0846; ralink=148f; realtek=0bda; 
	# Atmel makes other stuff
	my @tests = qw(Wi-Fi.*Adapter Ethernet WLAN Network 802\.11 
	Wireless.*Adapter 54\sMbps Network Atheros D-Link.*Adapter 
	D-Link.*Wireless Linksys Netgea Ralink Realtek.*Network Realtek.*Wireless
	Belkin.*Wireless Actiontec.*Wireless AirLink.*Wireless Asus.*Wireless 
	Buffalo.*Wireless Davicom DWA-.*RangeBooster DWA-.*Wireless
	ENUWI-.*Wireless LG.*Wi-Fi Rosewill.*Wireless RNX-.*Wireless Samsung.*LinkStick 
	Samsung.*Wireless Sony.*Wireless TEW-.*Wireless TP-Link.*Wireless 
	WG[0-9][0-9][0-9].*Wireless WNA[0-9][0-9][0-9] WNDA[0-9][0-9][0-9] 
	Zonet.*ZEW.*Wireless 050d:935b 0bda:8189 0bda:8197
	);
	foreach (@tests){
		if ($device =~ /$_/i ){
			$b_network = 1;
			last;
		}
	}
	eval $end if $b_log;
	return $b_network;
}
}

## OpticalData
{
package OpticalData;

sub get {
	eval $start if $b_log;
	my (@data,@rows,$key1,$val1);
	my $num = 0;
	if ($bsd_type){
		#@data = optical_data_bsd();
		$key1 = 'Optical';
		$val1 = main::row_defaults('data-bsd');
		@data = ({$num++ . "#$key1" => $val1,});
	}
	else {
		@data = optical_data_linux();
	}
	if (!@data){
		$key1 = 'Message';
		$val1 = main::row_defaults('optical-data');
		@data = ({$num++ . "#$key1" => $val1,});
	}
	@rows = (@rows,@data);
	return @rows;
	eval $end if $b_log;
	
}
sub optical_data_bsd {
	eval $start if $b_log;
	my (@data,%devices,@rows);
	
	@rows = create_data(%devices) if %devices;
	eval $end if $b_log;
	return @rows;
}
sub optical_data_linux {
	eval $start if $b_log;
	my (@data,%devices,@info,@rows);
	@data = main::globber('/dev/dvd* /dev/cd* /dev/scd* /dev/sr* /dev/fd[0-9]');
	# Newer kernel is NOT linking all optical drives. Some, but not all.
	# Get the actual disk dev location, first try default which is easier to run, 
	# need to preserve line breaks
	foreach (@data){
		my $working = readlink($_);
		$working = ($working) ? $working: $_;
		next if $working =~ /random/;
		$working =~ s/\/dev\///;
		$_ =~ s/\/dev\///;
		if  (! defined $devices{$working}){
			my @temp = ($_ ne $working) ? ([$_]) : ([]);
			$devices{$working} = ({'links' => @temp});
			$devices{$working}{'type'} = ($working =~ /^fd/) ? 'floppy' : 'optical' ;
		}
 		else {
			my $ref = $devices{$working}{'links'};
 			push @$ref, $_ if $_ ne $working;
 		}
		#print "$working\n";
	}
	if ($show{'optical'} && -e '/proc/sys/dev/cdrom/info'){
		@info = main::reader('/proc/sys/dev/cdrom/info','strip');
	}
	#print join '; ', @data, "\n";
	foreach my $key (keys %devices){
		next if $devices{$key}{'type'} eq 'floppy';
		my $device = "/sys/block/$key/device";
		if ( -d $device){
			if (-e "$device/vendor"){
				$devices{$key}{'vendor'} = (main::reader("$device/vendor"))[0];
				$devices{$key}{'vendor'} = main::cleaner($devices{$key}{'vendor'});
				$devices{$key}{'state'} = (main::reader("$device/state"))[0];
				$devices{$key}{'model'} = (main::reader("$device/model"))[0];
				$devices{$key}{'model'} = main::cleaner($devices{$key}{'model'});
				$devices{$key}{'rev'} = (main::reader("$device/rev"))[0];
			}
		}
		elsif ( -e "/proc/ide/$_/model"){
			$devices{$key}{'vendor'} = (main::reader("/proc/ide/$_/model"))[0];
			$devices{$key}{'vendor'} = main::cleaner($devices{$key}{'vendor'});
		}
		if ($show{'optical'} && @info){
			my $index = 0;
			foreach my $item (@info){
				next if /^\s*$/;
				my @split = split '\s+', $item;
				if ($item =~ /^drive name:/){
					foreach my $id (@split){
						last if ($id eq $key);
						$index++;
					}
					last if ! $index; # index will be > 0 if it was found
				}
				elsif ($item =~/^drive speed:/) {
					$devices{$key}{'speed'} = $split[$index];
				}
				elsif ($item =~/^Can read multisession:/) {
					$devices{$key}{'multisession'}=$split[$index+1];
				}
				elsif ($item =~/^Can read MCN:/) {
					$devices{$key}{'mcn'}=$split[$index+1];
				}
				elsif ($item =~/^Can play audio:/) {
					$devices{$key}{'audio'}=$split[$index+1];
				}
				elsif ($item =~/^Can write CD-R:/) {
					$devices{$key}{'cdr'}=$split[$index+1];
				}
				elsif ($item =~/^Can write CD-RW:/) {
					$devices{$key}{'cdrw'}=$split[$index+1];
				}
				elsif ($item =~/^Can read DVD:/) {
					$devices{$key}{'dvd'}=$split[$index+1];
				}
				elsif ($item =~/^Can write DVD-R:/) {
					$devices{$key}{'dvdr'}=$split[$index+1];
				}
				elsif ($item =~/^Can write DVD-RAM:/) {
					$devices{$key}{'dvdram'}=$split[$index+1];
				}
			}
		}
	}
	#print Data::Dumper::Dumper \%devices;
	@rows = create_data(%devices) if %devices;
	eval $end if $b_log;
	return @rows;
}
sub create_data {
	eval $start if $b_log;
	my (%devices) = @_;
	my (@data,@rows);
	my $num = 0;
	my $j = 0;
	# build floppy if any
	foreach my $key (sort keys %devices){
		if ($devices{$key}{'type'} eq 'floppy'){
			@data = ({ $num++ . '#' . ucfirst($devices{$key}{'type'}) => "/dev/$key"});
			@rows = (@rows,@data);
			delete $devices{$key};
		}
	}
	foreach my $key (sort keys %devices){
		$j = scalar @rows;
		my $vendor = $devices{$key}{'vendor'};
		$vendor ||= 'N/A';
		my $model = $devices{$key}{'model'};
		$model ||= 'N/A';
		@data = ({ 
		$num++ . '#' . ucfirst($devices{$key}{'type'}) => "/dev/$key",
		$num++ . '#vendor' => $vendor,
		$num++ . '#model' => $model,
		});
		@rows = (@rows,@data);
		if ($extra > 0){
			my $rev = $devices{$key}{'rev'};
			$rev ||= 'N/A';
			$rows[$j]{ $num++ . '#rev'} = $rev;
		}
		my $ref = $devices{$key}{'links'};
		my $links = (@$ref) ? join ',', sort @$ref: 'N/A' ;
		$rows[$j]{ $num++ . '#dev-links'} = $links;
		
		if ($show{'optical'}){
			$j = scalar @rows;
			my $speed = $devices{$key}{'speed'};
			$speed ||= 'N/A';
			my $multisession = ( $devices{$key}{'multisession'} == 1 ) ? 'yes' : 'no' ;
			my $audio = ( $devices{$key}{'audio'} == 1 ) ? 'yes' : 'no' ;
			my $dvd = 'N/A';
			my (@rw,$rws);
			if (defined $devices{$key}{'dvd'}){
				$dvd = ( $devices{$key}{'dvd'} == 1 ) ? 'yes' : 'no' ;
			}
			if ($devices{$key}{'cdr'}){
				push @rw, 'cd-r';
			}
			if ($devices{$key}{'cdrw'}){
				push @rw, 'cd-rw';
			}
			if ($devices{$key}{'dvdr'}){
				push @rw, 'dvd-r';
			}
			if ($devices{$key}{'dvdram'}){
				push @rw, 'dvd-ram';
			}
			$rws = (@rw) ? join ',', @rw: 'none' ;
			@data = ({
			$num++ . '#Features' => '',
			$num++ . '#speed' => $speed,
			$num++ . '#multisession' => $multisession,
			$num++ . '#audio' => $audio,
			$num++ . '#dvd' => $dvd,
			$num++ . '#rw' => $rws,
			});
			@rows = (@rows,@data);
			
			if ($extra > 0 ){
				my $state = $devices{$key}{'state'};
				$state ||= 'N/A';
				$rows[$j]{ $num++ . '#state'} = $state;
			}
		}
	}
	#print Data::Dumper::Dumper \%devices;
	eval $end if $b_log;
	return @rows;
}
}

## PartitionData
{
package PartitionData;

sub get {
	eval $start if $b_log;
	my (@rows,$key1,$val1);
	my $num = 0;
# 	my $ref = $alerts{'sensors'};
# 	if ( $$ref{'action'} ne 'use'){
# 		$key1 = $$ref{'action'};
# 		$val1 = $$ref{$key1};
# 		$key1 = ucfirst($key1);
# 	}
# 	else {
		$key1 = 'Status';
		$val1 = main::row_defaults('dev');
# 	}
	my @data = ({$num++ . "#$key1" => $val1,});
	return @data;
	eval $end if $b_log;
	
}
sub partition_data {
	eval $start if $b_log;
	my (@rows);
	my $num = 0;
	
	eval $end if $b_log;
	return @rows;
}
}

## ProcessData 
{
package ProcessData;

sub get {
	eval $start if $b_log;
	my (@processes,@rows);
	if ($show{'ps-cpu'}){
		@rows = cpu_processes();
		@processes = (@processes,@rows);
	}
	if ($show{'ps-mem'}){
		@rows = mem_processes();
		@processes = (@processes,@rows);
	}
	return @processes;
	eval $end if $b_log;
}
sub cpu_processes {
	eval $start if $b_log;
	my ($j,$num,$cpu,$cpu_mem,$mem) = (0,0,'','','');
	my (@processes);
	my $count = ($b_irc)? 5: $ps_count;
	my @rows = sort { 
		my @a = split(/\s+/,$a); 
		my @b = split(/\s+/,$b); 
		$b[2] <=> $a[2] } @ps_aux;
	# if there's a count limit, for irc, etc, only use that much of the data
	@rows = splice @rows,0,$count;
	$cpu_mem = ' - Memory: MB / % used' if $extra > 0;
	$j = scalar @rows;
	my $throttled = throttled($ps_count,$count,$j);
	my @data = (
	{$num++ . "#CPU  % used - Command - pid$cpu_mem - top" => "$count$throttled",},
	);
	@processes = (@processes,@data);
	my $i = 1;
	foreach (@rows){
		$num = 1;
		$j = scalar @processes;
		my @row = split /\s+/, $_;
		my @command = process_starter(scalar @row, $row[10],$row[11]);
		@data = (
		{
		$num++ . "#" . $i++ => '',
		$num++ . "#cpu" => $row[2] . '%',
		$num++ . "#command" => $command[0],
		},
		);
		@processes = (@processes,@data);
		if ($command[1]) {
			$processes[$j]{$num++ . "#started by"} = $command[1];
		}
		$processes[$j]{$num++ . "#pid"} = $row[1];
		if ($extra > 0){
			my $decimals = ($row[5]/1024 > 10 ) ? 1 : 2;
			$mem = (defined $row[5]) ? sprintf( "%.${decimals}f", $row[5]/1024 ) . 'MB' : 'N/A';
			$mem .= ' (' . $row[3] . '%)';
			$processes[$j]{$num++ . "#mem"} = $mem;
		}
		#print Data::Dumper::Dumper \@processes, "i: $i; j: $j ";
	}
	eval $end if $b_log;
	return @processes;
}
sub mem_processes {
	eval $start if $b_log;
	my ($j,$num,$cpu,$cpu_mem,$mem) = (0,0,'','','');
	my (@data,@processes,$memory);
	my $count = ($b_irc)? 5: $ps_count;
	my @rows = sort { 
		my @a = split(/\s+/,$a); 
		my @b = split(/\s+/,$b); 
		$b[5] <=> $a[5] } @ps_aux;
	@rows = splice @rows,0,$count;
	@processes = main::memory_data_full('process') if !$b_mem;
	$cpu_mem = ' - CPU: % used' if $extra > 0;
	$j = scalar @rows;
	my $throttled = throttled($ps_count,$count,$j);
	@data = (
	{$num++ . "#Memory MB/% used - Command - pid$cpu_mem - top" => "$count$throttled",},
	);
	@processes = (@processes,@data);
	my $i = 1;
	foreach (@rows){
		$num = 1;
		$j = scalar @processes;
		my @row = split /\s+/, $_;
		my $decimals = ($row[5]/1024 > 10 ) ? 1 : 2;
		$mem = ($row[5]) ? sprintf( "%.${decimals}f", $row[5]/1024 ) . ' MB' : 'N/A';
		my @command = process_starter(scalar @row, $row[10],$row[11]);
		if ($extra > 0){
			$mem .= " (" . $row[2] . "%)"; 
		}
		@data = (
		{
		$num++ . "#" . $i++ => '',
		$num++ . "#mem" => $mem,
		$num++ . "#command" => $command[0],
		},
		);
		@processes = (@processes,@data);
		if ($command[1]) {
			$processes[$j]{$num++ . "#started by"} = $command[1];
		}
		$processes[$j]{$num++ . "#pid"} = $row[1];
		if ($extra > 0){
			$cpu = $row[3] . '%';
			$processes[$j]{$num++ . "#cpu"} = $cpu;
		}
		#print Data::Dumper::Dumper \@processes, "i: $i; j: $j ";
	}
	eval $end if $b_log;
	return @processes;
}
sub process_starter {
	my ($count, $row10, $row11) = @_;
	my (@return);
	# note: [migration/0] would clear with a simple basename
	if ($count > 11 && $row11 =~ /^\//){
		$row11 =~ s/^\/.*\///;
		$return[0] = $row11;
		$row10 =~ s/^\/.*\///;
		$return[1] = $row10;
	}
	else {
		$row10 =~ s/^\/.*\///;
		$return[0] = $row10;
		$return[1] = '';
	}
	return @return;
}
sub throttled {
	my ($ps_count,$count,$j) = @_;
	my $throttled = '';
	if ($count > $j){
		$throttled = " (only $j processes)";
	}
	elsif ($count < $ps_count){
		$throttled = " (throttled from $ps_count)";
	}
	return $throttled;
}
}

## RaidData
{
package RaidData;

sub get {
	eval $start if $b_log;
	my (@rows,$key1,$val1);
	my $num = 0;
	my $ref = $alerts{'sensors'};
# 	if ( $$ref{'action'} ne 'use'){
# 		$key1 = $$ref{'action'};
# 		$val1 = $$ref{$key1};
# 		$key1 = ucfirst($key1);
# 	}
# 	else {
		$key1 = 'Status';
		$val1 = main::row_defaults('dev');
# 	}
	my @data = ({$num++ . "#$key1" => $val1,});
	return @data;
	eval $end if $b_log;
	
}
sub raid_data {
	eval $start if $b_log;
	my (@rows);
	my $num = 0;
	
	eval $end if $b_log;
	return @rows;
}
}

## RamData
{
package RamData;

sub get {
	my (@data,@rows,$key1,@ram,$val1);
	my $num = 0;
	my $ref = $alerts{'dmidecode'};
	@rows = main::memory_data_full('ram') if !$b_mem;
	if ( $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		@data = ({
		$num++ . "#RAM Report" => '',
		$num++ . "#$key1" => $val1,
		});
		@rows = (@rows,@data);
	}
	else {
		@ram = dmidecode_data();
		if (@ram){
			@data = create_ram_data(@ram);
		}
		else {
			$key1 = 'message';
			$val1 = main::row_defaults('ram-data');
			@data = ({
			$num++ . "#RAM Report" => '',
			$num++ . "#$key1" => $val1,
			});
		}
		@rows = (@rows,@data);
	}
	eval $end if $b_log;
	return @rows;
}

sub create_ram_data {
	eval $start if $b_log;
	my (@ram) = @_;
	return if !@ram;
	my $num = 0;
	my $j = 0;
	my (@data,@rows);
	foreach (@ram){
		$j = scalar @rows;
		my %ref = %$_;
		@data = ({
		$num++ . "#Array" => '',
		$num++ . "#capacity" => process_size($ref{'capacity'}),
		});
		@rows = (@rows,@data);
		if ($ref{'cap-qualifier'}){
			$rows[$j]{$num++ . "#note"} = $ref{'cap-qualifier'};
		}
		$rows[$j]{$num++ . "#slots"} = $ref{'slots'};
		$rows[$j]{$num++ . "#EC"} = $ref{'eec'};
		if ($extra > 0 ){
			$rows[$j]{$num++ . "#max module size"} = process_size($ref{'max-module-size'});
			if ($ref{'mod-qualifier'}){
				$rows[$j]{$num++ . "#note"} = $ref{'mod-qualifier'};
			}
		}
		foreach my $ref2 ($ref{'modules'}){
			my @modules = @$ref2;
			# print Data::Dumper::Dumper \@modules;
			foreach my $ref3 ( @modules){
				$j = scalar @rows;
				my %mod = %$ref3;
				$mod{'locator'} ||= 'N/A';
				@data = ({
				$num++ . "#Device" => $mod{'locator'},
				$num++ . "#size" => process_size($mod{'size'}),
				});
				@rows = (@rows,@data);
				next if ($mod{'size'} =~ /\D/);
				if ($extra > 1 && $mod{'type'} ){
					$rows[$j]{$num++ . "#info"} = $mod{'type'};
				}
				$rows[$j]{$num++ . "#speed"} = $mod{'speed'};
				if ($extra > 0 ){
					$mod{'device-type'} ||= 'N/A';
					$rows[$j]{$num++ . "#type"} = $mod{'device-type'};
					if ($extra > 2 && $mod{'device-type'} ne 'N/A'){
						$mod{'device-type-detail'} ||= 'N/A';
						$rows[$j]{$num++ . "#detail"} = $mod{'device-type-detail'};
					}
				}
				if ($extra > 2 ){
					$mod{'data-width'} ||= 'N/A';
					$rows[$j]{$num++ . "#bus width"} = $mod{'data-width'};
					$mod{'total-width'} ||= 'N/A';
					$rows[$j]{$num++ . "#total"} = $mod{'total-width'};
				}
				if ($extra > 1 ){
					$mod{'manufacturer'} ||= 'N/A';
					$rows[$j]{$num++ . "#manufacturer"} = $mod{'manufacturer'};
					$mod{'part-number'} ||= 'N/A';
					$rows[$j]{$num++ . "#part-nu"} = $mod{'part-number'};
				}
				if ($extra > 2 ){
					$mod{'serial'} ||= 'N/A';
					$rows[$j]{$num++ . "#serial"} = $mod{'serial'};
				}
			}
		}
	}
	eval $end if $b_log;
	return @rows;
}

sub dmidecode_data {
	eval $start if $b_log;
	my ($b_5,$handle,@ram,@temp);
	my ($derived_module_size,$max_cap_5,$max_cap_16,$max_module_size) = (0,0,0,0);
	my ($i,$j,$k) = (0,0,0);
	foreach (@dmi){
		my @ref = @$_;
		# Portable Battery
		if ($ref[0] == 5){
			$ram[$k] = ({}) if !$ram[$k];
			foreach my $item (@ref){
				@temp = split /:\s*/, $item;
				next if ! $temp[1];
				if ($temp[0] eq 'Maximum Memory Module Size'){
					$max_module_size = calculate_size($temp[1],$max_module_size);
					$ram[$k]{'max-module-size'} = $max_module_size;
				}
				elsif ($temp[0] eq 'Maximum Total Memory Size'){
					$max_cap_5 = calculate_size($temp[1],$max_cap_5);
					$ram[$k]{'max-capacity-5'} = $max_cap_5;
				}
				elsif ($temp[0] eq 'Memory Module Voltage'){
					$temp[1] =~ s/\s*V.*$//;
					$ram[$k]{'voltage'} = $temp[1];
				}
				elsif ($temp[0] eq 'Associated Memory Slots'){
					$ram[$k]{'slots-5'} = $temp[1];
				}
			}
			$ram[$k]{'modules'} = ([],);
			#print Data::Dumper::Dumper \@ram;
			$b_5 = 1;
		}
		elsif ($ref[0] == 6){
			my ($size,$speed,$type) = (0,0,0);
			foreach my $item (@ref){
				@temp = split /:\s*/, $item;
				next if ! $temp[1];
				if ($temp[0] eq 'Installed Size'){
					# get module size
					
					$size = calculate_size($temp[1],0);
					# get data after module size
					$temp[1] =~ s/ Connection\)?//;
					$temp[1] =~ s/^[0-9]+\s*[MGTP]B\s*\(?//;
					$type = lc($temp[1]);
				}
				elsif ($temp[0] eq 'Current Speed'){
					$speed = $temp[1];
				}
			}
			$ram[$k]{'modules'}[$j] = ({
			'size' => $size,
			'speed-ns' => $speed,
			'type' => $type,
			});
			#print Data::Dumper::Dumper \@ram;
			$j++;
		}
		elsif ($ref[0] == 16){
			$handle = $ref[1];
			$ram[$handle] = $ram[$k] if $ram[$k];
			$ram[$k] = undef;
			$ram[$handle] = ({}) if !$ram[$handle];
			foreach my $item (@ref){
				@temp = split /:\s*/, $item;
				next if ! $temp[1];
				if ($temp[0] eq 'Maximum Capacity'){
					$max_cap_16 = calculate_size($temp[1],$max_cap_16);
					$ram[$handle]{'max-capacity-16'} = $max_cap_16;
				}
				# note: these 3 have cleaned data in set_dmidecode_data, so replace stuff manually
				elsif ($temp[0] eq 'Location'){
					$temp[1] =~ s/\sOr\sMotherboard//;
					$temp[1] ||= 'System Board';
					$ram[$handle]{'location'} = $temp[1];
				}
				elsif ($temp[0] eq 'Use'){
					$temp[1] ||= 'System Memory';
					$ram[$handle]{'use'} = $temp[1];
				}
				elsif ($temp[0] eq 'Error Correction Type'){
					$temp[1] ||= 'None';
					$ram[$handle]{'eec'} = $temp[1];
				}
				elsif ($temp[0] eq 'Number Of Devices'){
					$ram[$handle]{'slots-16'} = $temp[1];
				}
				#print "0: $temp[0]\n";
			}
			$ram[$handle]{'derived-module-size'} = 0;
			$ram[$handle]{'device-count-found'} = 0;
			$ram[$handle]{'used-capacity'} = 0;
			#print "s16: $ram[$handle]{'slots-16'}\n";
		}
		elsif ($ref[0] == 17){
			my ($bank_locator,$configured_clock_speed,$data_width) = ('','','');
			my ($device_type,$device_type_detail,$form_factor,$locator,$main_locator) = ('','','','','');
			my ($manufacturer,$part_number,$serial,$speed,$total_width) = ('','','','','');
			my ($device_size,$i_data,$i_total,$working_size) = (0,0,0,0);
			foreach my $item (@ref){
				@temp = split /:\s*/, $item;
				next if ! $temp[1];
				if ($temp[0] eq 'Array Handle'){
					$handle = hex($temp[1]);
				}
				elsif ($temp[0] eq 'Data Width'){
					$data_width = $temp[1];
				}
				elsif ($temp[0] eq 'Total Width'){
					$total_width = $temp[1];
				}
				# do not try to guess from installed modules, only use this to correct type 5 data
				elsif ($temp[0] eq 'Size'){
					# we want any non real size data to be preserved
					if ( $temp[1] =~ /^[0-9]+\s*[MTPG]B/ ) {
						$derived_module_size = calculate_size($temp[1],$derived_module_size);
						$working_size = calculate_size($temp[1],0);
						$device_size = $working_size;
					}
					else {
						$device_size = $temp[1];
					}
				}
				elsif ($temp[0] eq 'Locator'){
					$temp[1] =~ s/RAM slot #/Slot/;
					$locator = $temp[1];
				}
				elsif ($temp[0] eq 'Bank Locator'){
					$bank_locator = $temp[1];
				}
				elsif ($temp[0] eq 'Form Factor'){
					$form_factor = $temp[1];
				}
				elsif ($temp[0] eq 'Type'){
					$device_type = $temp[1];
				}
				elsif ($temp[0] eq 'Type Detail'){
					$device_type_detail = $temp[1];
				}
				elsif ($temp[0] eq 'Speed'){
					$speed = $temp[1];
				}
				elsif ($temp[0] eq 'Configured Clock Speed'){
					$configured_clock_speed = $temp[1];
				}
				elsif ($temp[0] eq 'Manufacturer'){
					$temp[1] =~ s/(^[0]+$|Undefined.*|.*Manufacturer.*)//g;
					$manufacturer = $temp[1];
				}
				elsif ($temp[0] eq 'Part Number'){
					$temp[1] =~ s/(^[0]+$||.*Module.*|Undefined.*|PartNum.*)//g;
					$part_number = $temp[1];
				}
				elsif ($temp[0] eq 'Serial Number'){
					$temp[1] =~ s/(^[0]+$|Undefined.*|SerNum.*)//g;
					$serial = $temp[1];
				}
			}
			# because of the wide range of bank/slot type data, we will just use
			# the one that seems most likely to be right. Some have: Bank: SO DIMM 0 slot: J6A
			# so we dump the useless data and use the one most likely to be visibly correct
			if ( $bank_locator =~ /DIMM/ ) {
				$main_locator = $bank_locator;
			}
			else {
				$main_locator = $locator;
			}
			if ($working_size =~ /^[0-9][0-9]+$/) {
				$ram[$handle]{'device-count-found'}++;
				# build up actual capacity found for override tests
				$ram[$handle]{'used-capacity'} += $working_size;
			}
			# sometimes the data is just wrong, they reverse total/data. data I believe is
			# used for the actual memory bus width, total is some synthetic thing, sometimes missing.
			# note that we do not want a regular string comparison, because 128 bit memory buses are
			# in our future, and 128 bits < 64 bits with string compare
			$data_width =~ /(^[0-9]+).*/;
			$i_data = $1;
			$total_width =~ /(^[0-9]+).*/;
			$i_total = $1;
			if ($i_data && $i_total && $i_data > $i_total){
				my $temp_width = $data_width;
				$data_width = $total_width;
				$total_width = $temp_width;
			}
			$ram[$handle]{'derived-module-size'} = $derived_module_size;
			$ram[$handle]{'modules'}[$i]{'configured-clock-speed'} = $configured_clock_speed;
			$ram[$handle]{'modules'}[$i]{'data-width'} = $data_width;
			$ram[$handle]{'modules'}[$i]{'size'} = $device_size;
			$ram[$handle]{'modules'}[$i]{'device-type'} = $device_type;
			$ram[$handle]{'modules'}[$i]{'device-type-detail'} = lc($device_type_detail);
			$ram[$handle]{'modules'}[$i]{'form-factor'} = $form_factor;
			$ram[$handle]{'modules'}[$i]{'locator'} = $main_locator;
			$ram[$handle]{'modules'}[$i]{'manufacturer'} = $manufacturer;
			$ram[$handle]{'modules'}[$i]{'part-number'} = $part_number;
			$ram[$handle]{'modules'}[$i]{'serial'} = $serial;
			$ram[$handle]{'modules'}[$i]{'speed'} = $speed;
			$ram[$handle]{'modules'}[$i]{'total-width'} = $total_width;
			$i++
		}
		elsif ($ref[0] < 17 ){
			next;
		}
		elsif ($ref[0] > 17 ){
			last;
		}
	}
	@ram = data_processor(@ram) if @ram;
	# print Data::Dumper::Dumper \@ram;
	eval $end if $b_log;
	return @ram;
}
sub data_processor {
	eval $start if $b_log;
	my (@ram) = @_;
	my $b_debug = 0;
	my (@return,@temp);
	
	foreach (@ram){
		# because we use the actual array handle as the index, 
		# there will be many undefined keys
		next if ! defined $_;
		my %ref = %$_;
		my ($max_cap,$max_mod_size) = (0,0);
		my ($alt_cap,$est_cap,$est_mod,$unit) = (0,'','','');
		$max_cap = $ref{'max-capacity-16'};
		# make sure they are integers not string if empty
		$ref{'slots-5'} ||= 0; 
		$ref{'slots-16'} ||= 0; 
		$ref{'max-capacity-5'} ||= 0;
		$ref{'max-module-size'} ||= 0;
		
		# 1: if max cap 1 is null, and max cap 2 not null, use 2
		if ($b_debug){
			print "1: mms: $ref{'max-module-size'} :dms: $ref{'derived-module-size'} :mc: $max_cap :uc: $ref{'used-capacity'}\n";
		}
		if (!$max_cap && $ref{'max-capacity-5'}) {
			$max_cap = $ref{'max-capacity-5'};
		}
		if ($b_debug){
			print "2: mms: $ref{'max-module-size'} :dms: $ref{'derived-module-size'} :mc: $max_cap :uc: $ref{'used-capacity'}\n";
		}
		# 2: now check to see if actually found module sizes are > than listed max module, replace if >
		if ( $ref{'max-module-size'} && $ref{'derived-module-size'} && 
		     $ref{'derived-module-size'} > $ref{'max-module-size'} ){
			$ref{'max-module-size'} = $ref{'derived-module-size'};
			$est_mod = 'est';
		}
		if ($b_debug){
			print "3: dcf: $ref{'device-count-found'} :dms: $ref{'derived-module-size'} :mc: $max_cap :uc: $ref{'used-capacity'}\n";
		}
		# note: some cases memory capacity == max module size, so one stick will fill it
		# but I think only with cases of 2 slots does this happen, so if > 2, use the count of slots.
		if ($max_cap && ($ref{'device-count-found'} || $ref{'slots-16'}) ){
			# first check that actual memory found is not greater than listed max cap, or
			# checking to see module count * max mod size is not > used capacity
			if ($ref{'used-capacity'} && $ref{'max-capacity-16'}){
				if ($ref{'used-capacity'} > $max_cap){
					if ($ref{'max-module-size'} && 
					  $ref{'used-capacity'} < ($ref{'slots-16'} * $ref{'max-module-size'} )){
						$max_cap = $ref{'slots-16'} * $ref{'max-module-size'};
						$est_cap = 'est';
						print "A\n" if $b_debug;
					}
					elsif ($ref{'derived-module-size'} && 
					  $ref{'used-capacity'} < ($ref{'slots-16'} * $ref{'derived-module-size'}) ){
						$max_cap = $ref{'slots-16'} * $ref{'derived-module-size'};
						$est_cap = 'est';
						print "B\n" if $b_debug;
					}
					else {
						$max_cap = $ref{'used-capacity'};
						$est_cap = 'est';
						print "C\n" if $b_debug;
					}
				}
			}
			# note that second case will never really activate except on virtual machines and maybe
			# mobile devices
			if (!$est_cap){
				# do not do this for only single modules found, max mod size can be equal to the array size
				if ($ref{'slots-16'} > 1 && $ref{'device-count-found'} > 1 && 
				  $max_cap < ($ref{'derived-module-size'} * $ref{'slots-16'} ) ){
					$max_cap = $ref{'derived-module-size'} * $ref{'slots-16'};
					$est_cap = 'est';
					print "D\n" if $b_debug;
				}
				elsif ($ref{'device-count-found'} > 0 && $max_cap < ( $ref{'derived-module-size'} * $ref{'device-count-found'} )){
					$max_cap = $ref{'derived-module-size'} * $ref{'device-count-found'};
					$est_cap = 'est';
					print "E\n" if $b_debug;
				}
				## handle cases where we have type 5 data: mms x device count equals type 5 max cap
				# however do not use it if cap / devices equals the derived module size
				elsif ($ref{'max-module-size'} > 0 &&
				  ($ref{'max-module-size'} * $ref{'slots-16'}) == $ref{'max-capacity-5'} &&
				  $ref{'max-capacity-5'} != $ref{'max-capacity-16'} &&
				  $ref{'derived-module-size'} != ($ref{'max-capacity-16'}/$ref{'slots-16'}) ){
					$max_cap = $ref{'max-capacity-5'};
					$est_cap = 'est';
					print "F\n" if $b_debug;
				}
				
			}
			if ($b_debug){
				print "4: mms: $ref{'max-module-size'} :dms: $ref{'derived-module-size'} :mc: $max_cap :uc: $ref{'used-capacity'}\n";
			}
			# some cases of type 5 have too big module max size, just dump the data then since
			# we cannot know if it is valid or not, and a guess can be wrong easily
			if ($ref{'max-module-size'} && $max_cap && $ref{'max-module-size'} > $max_cap){
				$ref{'max-module-size'} = 0;
			}
			if ($b_debug){
				print "5: dms: $ref{'derived-module-size'} :s16: $ref{'slots-16'} :mc: $max_cap\n";
			}
			# now prep for rebuilding the ram array data 
			if (!$ref{'max-module-size'}){
				# ie: 2x4gB
				if (!$est_cap && $ref{'derived-module-size'} > 0 && $max_cap > ($ref{'derived-module-size'} * $ref{'slots-16'} * 4) ){
					$est_cap = 'check';
					print "G\n" if $b_debug;
				}
			}
			# case where listed max cap is too big for actual slots x max cap, eg:
			# listed max cap, 8gb, max mod 2gb, slots 2
			else {
				if (!$est_cap && $ref{'max-module-size'} > 0){
					if ($max_cap > ( $ref{'max-module-size'} * $ref{'slots-16'})){
						$est_cap = 'check';
						print "H\n" if $b_debug;
					}
				}
			}
		}
		@temp = ({
		'capacity' => $max_cap,
		'cap-qualifier' => $est_cap,
		'eec' => $ref{'eec'},
		'location' => $ref{'location'},
		'max-module-size' => $ref{'max-module-size'},
		'mod-qualifier' => $est_mod,
		'modules' => $ref{'modules'},
		'slots' => $ref{'slots-16'},
		'use' => $ref{'use'},
		'voltage' => $ref{'voltage'},
		});
		@return = (@return,@temp);
	}
	eval $end if $b_log;
	return @return;
}
sub process_size {
	my ($size) = @_;
	my ($b_trim,$unit) = (0,'');
	return 'N/A' if ( ! $size );
	return $size if $size =~ /\D/;
	if ( $size < 1024 ){
		$unit='MB';
	}
	elsif ( $size < 1024000 ){
		$size = $size / 1024;
		$unit='GB';
		$b_trim = 1;
	}
	elsif ( $size < 1024000000 ){
		$size = $size / 1024000;
		$unit='TB';
		$b_trim = 1;
	}
	# we only want a max 2 decimal places, and only when it's 
	# a unit > MB
	$size = sprintf("%.2f",$size) if $b_trim;
	$size =~ s/\.[0]+$//;
	$size = "$size $unit";
	return $size;
}
sub calculate_size {
	my ($data, $size) = @_;
	if ( $data =~ /^[0-9]+\s*[GMTP]B/) {
		if ( $data =~ /([0-9]+)\s*GB/ ) {
			$data = $1 * 1024;
		}
		elsif ( $data =~ /([0-9]+)\s*MB/ ) {
			$data = $1;
		}
		elsif ( $data =~ /([0-9]+)\s*TB/ ) {
			$data = $1 * 1024 * 1000;
		}
		elsif ( $data =~ /([0-9]+)\s*PB/ ) {
			$data = $1 * 1024 * 1000 * 1000;
		}
		if ($data =~ /^[0-9][0-9]+$/ && $data > $size ) {
			$size=$data;
		}
	}
	else {
		$size = 0;
	}
	return $size;
}
}

## RepoData
{
package RepoData;

# easier to keep these package global, but undef after done
my (@dbg_files,$debugger_dir);
my $num = 0;
sub get {
	eval $start if $b_log;
	($debugger_dir) = @_;
	my (@data,@rows);
	if ($bsd_type){
		@rows = get_repos_bsd();
	}
	else {
		@rows = get_repos_linux();
	}
	if ($debugger_dir){
		@rows = @dbg_files;
		undef @dbg_files;
		undef $debugger_dir;
	}
	else {
		if (!@rows){
			my $pm = (!$bsd_type) ? 'package manager': 'OS type';
			@data = (
			{$num++ . '#Alert' => "No repo data detected. Does $self_name support your $pm?"},
			);
			@rows = (@data);
		}
	}
	eval $end if $b_log;
	return @rows;
}

sub get_repos_linux {
	eval $start if $b_log;
	my (@content,@data,@data2,@files,$repo,@rows);
	my $apk = '/etc/apk/repositories';
	my $apt = '/etc/apt/sources.list';
	my $pacman = '/etc/pacman.conf';
	my $pisi_dir = '/etc/pisi/';
	my $portage_dir = '/etc/portage/repos.conf/';
	my $slackpkg = '/etc/slackpkg/mirrors';
	my $slackpkg_plus = '/etc/slackpkg/slackpkgplus.conf';
	my $yum_conf = '/etc/yum.conf';
	my $yum_repo_dir = '/etc/yum.repos.d/';
	my $zypp_repo_dir = '/etc/zypp/repos.d/';
	
	# apt - debian, buntus, also sometimes some yum/rpm repos may create 
	# apt repos here as well
	if (-f $apt || -d "$apt.d"){
		@files = main::globber('/etc/apt/sources.list.d/*.list');
		push @files, $apt;
		main::log_data("apt repo files:\n" . main::joiner(\@files, "\n", 'unset') ) if $b_log;
		foreach ( sort @files){
			@data = repo_builder($_,'apt','^\s*deb') if -r $_;
			@rows = (@rows,@data);
		}
		@files = ();
	}
	# pacman: Arch and derived
	if (-f $pacman){
		@files = main::reader($pacman,'strip');
		@files = grep {/^\s*Include/i} @files if @files;
		@files = map {
			my @working = split( /\s+=\s+/, $_); 
			$working[1];
		} @files if @files;
		@files = sort(@files);
		@files = main::uniq(@files);
		foreach (sort @files){
			if (-f $_){
				@data = repo_builder($_,'pacman','^[[:space:]]*Server','\s*=\s*',1);
				@rows = (@rows,@data);
			}
			else {
				# set it so the debugger knows the file wasn't there
				push @dbg_files, $_ if $debugger_dir;
				@data = (
				{$num++ . "#File listed in" => $pacman},
				[("$_ does not seem to exist.")],
				);
				@rows = (@rows,@data);
			}
		}
	}
	# slackware
	elsif (-f $slackpkg || -f $slackpkg_plus){
		if (-f $slackpkg){
			@data = repo_builder($slackpkg,'slackpkg','^[[:space:]]*#*');
			@rows = (@rows,@data);
		}
		if (-f $slackpkg_plus){
			push @dbg_files, $slackpkg_plus if $debugger_dir;
			@data =  main::reader($slackpkg_plus,'strip');
			my (@repoplus_list,$active_repos);
			foreach my $row (@data){
				@data2 = split /\s*=\s*/, $row;
				@data2 = map { $_ =~ s/^\s+|\s+$//g ; $_ } @data2;
				last if $data2[0] =~ /^SLACKPKGPLUS/ && $data2[1] eq 'off';
				# REPOPLUS=( slackpkgplus restricted alienbob ktown multilib slacky)
				if ($data2[0] =~ /^REPOPLUS/){
					@repoplus_list = split /\s+/, $data2[1];
					@repoplus_list = map {s/\(|\)//g; $_} @repoplus_list;
					$active_repos = join ('|',@repoplus_list);
					
				}
				# MIRRORPLUS['multilib']=http://taper.alienbase.nl/mirrors/people/alien/multilib/14.1/
				if ($active_repos && $data2[0] =~ /^MIRRORPLUS/){
					$data2[0] =~ s/MIRRORPLUS\[\'|\'\]//g;
					if ($data2[0] =~ /$active_repos/){
						push @content,"$data2[0] ~ $data2[1]";
					}
				}
			}
			@content = ('No slackpkg+ sources found in file') if ! @content;
			@content = url_cleaner(@content);
			@data = (
			{$num++ . "#slackpkg+ sources" => $slackpkg_plus},
			[@content],
			);
			@data = url_cleaner(@data);
			@rows = (@rows,@data);
			@content = ();
		}
	}
	# redhat/suse
	elsif (-d $yum_repo_dir || -f $yum_conf || -d $zypp_repo_dir){
		if (-d $yum_repo_dir || -f $yum_conf){
			@files = main::globber("$yum_repo_dir*.repo");
			push @files, $yum_conf if -f $yum_conf;
			$repo = 'yum';
		}
		elsif (-d $zypp_repo_dir){
			@files = main::globber("$zypp_repo_dir*.repo");
			main::log_data("zypp repo files:\n" . main::joiner(\@files, "\n", 'unset')) if $b_log;
			$repo = 'zypp';
		}
 		#$repo = 'yum';
 		#push @files, "$ENV{'HOME'}/bin/scripts/inxi/data/repo/yum/rpmfusion-nonfree-1.repo";
		if (@files){
			foreach (sort @files){
				@data2 = main::reader($_);
				push @dbg_files, $_ if $debugger_dir;
				my ($enabled,$url,$title) = (0,'','');
				foreach my $line (@data2){
					# this is a hack, assuming that each item has these fields listed, we collect the 3
					# items one by one, then when the url/enabled fields are set, we print it out and
					# reset the data. Not elegant but it works. Note that if enabled was not present
					# we assume it is enabled then, and print the line, reset the variables. This will
					# miss the last item, so it is printed if found in END
					if ($line =~ /^\[(.+)\]/){
						my $temp = $1;
						if ($url && $title){
							if ($enabled > 0){
								push @content, "$title ~ $url";
							}
							($enabled,$url,$title) = (0,'','');
						}
						$title = $temp;
					}
					elsif ($line =~ /^(metalink|mirrorlist|baseurl)\s*=\s*(.*)/){
						$url = $2;
					}
					# note: enabled = 1. enabled = 0 means disabled
					elsif ($line =~ /^enabled\s*=\s*([01])/){
						$enabled = $1;
						# print out the line if all 3 values are found, otherwise if a new
						# repoTitle is hit above, it will print out the line there instead
						if ($enabled > 0){
 							push @content, "$title ~ $url";
 						}
 						($enabled,$url,$title) = (0,'','');
					}
				}
				# print the last one if there is data for it
				if ($url && $title && $enabled){
					push @content, "$title ~ $url";
				}
				@content = url_cleaner(@content);
				@content = ("No enabled $repo sources found in file") if ! @content;
				@data = (
				{$num++ . "#Enabled $repo sources in" => $_},
				[@content],
				);
				@rows = (@rows,@data);
				@content = ();
			}
		}
		# print Data::Dumper::Dumper \@rows;
	}
	# gentoo 
	elsif (-d $portage_dir && main::check_program('emerge')){
		@files = main::globber("$portage_dir*.conf");
		$repo = 'portage';
		if (@files){
			foreach (sort @files){
				@data2 = main::reader($_);
				push @dbg_files, $_ if $debugger_dir;
				my ($enabled,$url,$title) = (0,'','');
				foreach my $line (@data2){
					# this is a hack, assuming that each item has these fields listed, we collect the 3
					# items one by one, then when the url/enabled fields are set, we print it out and
					# reset the data. Not elegant but it works. Note that if enabled was not present
					# we assume it is enabled then, and print the line, reset the variables. This will
					# miss the last item, so it is printed if found in END
					if ($line =~ /^\[(.+)\]/){
						my $temp = $1;
						if ($url && $title){
							if ($enabled > 0){
								push @content, "$title ~ $url";
							}
							($enabled,$url,$title) = (0,'','');
						}
						$title = $temp;
					}
					elsif ($line =~ /^(sync-uri)\s*=\s*(.*)/){
						$url = $2;
					}
					# note: enabled = 1. enabled = 0 means disabled
					elsif ($line =~ /^auto-sync\s*=\s*([01])/){
						$enabled = $1;
						# print out the line if all 3 values are found, otherwise if a new
						# repoTitle is hit above, it will print out the line there instead
						if ($enabled > 0){
 							push @content, "$title ~ $url";
 							print "here $title\n";
 						}
 						($enabled,$url,$title) = (0,'','');
					}
				}
				# print the last one if there is data for it
				if ($url && $title && $enabled){
					push @content, "$title ~ $url";
				}
				@content = url_cleaner(@content);
				@content = ("No enabled $repo sources found in file") if ! @content;
				@data = (
				{$num++ . "#Enabled $repo sources in" => $_},
				[@content],
				);
				@rows = (@rows,@data);
				@content = ();
			}
		}
	}
	# Alpine linux
	elsif (-f $apk){
		@data = repo_builder($apk,'apk','^\s*[^#]+');
		@rows = (@rows,@data);
	}
	# Mandriva/Mageia using: urpmq
	elsif ( main::check_program('urpmq') ){
		@data2 = main::grabber("urpmq --list-media active --list-url","\n",'strip');
		main::writer("$debugger_dir/system-repo-data-urpmq.txt",@data2) if $debugger_dir;
		# now we need to create the structure: repo info: repo path
		# we do that by looping through the lines of the output and then
		# putting it back into the <data>:<url> format print repos expects to see
		# note this structure in the data, so store first line and make start of line
		# then when it's an http line, add it, and create the full line collection.
		# Contrib ftp://ftp.uwsg.indiana.edu/linux/mandrake/official/2011/x86_64/media/contrib/release
		# Contrib Updates ftp://ftp.uwsg.indiana.edu/linux/mandrake/official/2011/x86_64/media/contrib/updates
		# Non-free ftp://ftp.uwsg.indiana.edu/linux/mandrake/official/2011/x86_64/media/non-free/release
		# Non-free Updates ftp://ftp.uwsg.indiana.edu/linux/mandrake/official/2011/x86_64/media/non-free/updates
		# Nonfree Updates (Local19) /mnt/data/mirrors/mageia/distrib/cauldron/x86_64/media/nonfree/updates
		foreach (@data2){
			# need to dump leading/trailing spaces and clear out color codes for irc output
			$_ =~ s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g;
			$_ =~ s/\e\[([0-9];)?[0-9]+m//g;
			# urpmq output is the same each line, repo name space repo url, can be:
			# rsync://, ftp://, file://, http:// OR repo is locally mounted on FS in some cases
			if (/(.+)\s([\S]+:\/\/.+)/){
				# pack the repo url
				push @content, $1;
				# get the repo
				$repo = $2;
				@data = (
				{$num++ . "#urpmq repo" => $repo},
				[@content],
				);
				@rows = (@rows,@data);
				@content = ();
			}
		}
	}
	# Pardus
	elsif (-d $pisi_dir && main::check_program('pisi') ){
		@data2 = main::grabber("pisi list-repo 2>/dev/null","\n",'strip');
		main::writer("$debugger_dir/system-repo-data-pisi.txt",@data2) if $debugger_dir;
		# now we need to create the structure: repo info: repo path
		# we do that by looping through the lines of the output and then
		# putting it back into the <data>:<url> format print repos expects to see
		# note this structure in the data, so store first line and make start of line
		# then when it's an http line, add it, and create the full line collection.
		# Pardus-2009.1 [Aktiv]
		# 	http://packages.pardus.org.tr/pardus-2009.1/pisi-index.xml.bz2
		# Contrib [Aktiv]
		# 	http://packages.pardus.org.tr/contrib-2009/pisi-index.xml.bz2
		foreach (@data2){
			# need to dump leading/trailing spaces and clear out color codes for irc output
			$_ =~ s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g;
			$_ =~ s/\e\[([0-9];)?[0-9]+m//g;
			if (/:\/\//){
				push @content, $_;
			}
			else {
				$repo = $_;
				@data = (
				{$num++ . "#pisi repo" => $repo},
				[@content],
				);
				@rows = (@rows,@data);
				@content = ();
			}
		}
		# last one if present
		if ($repo && @content){
			@data = (
			{$num++ . "#pisi repo" => $repo},
			[@content],
			);
			@rows = (@rows,@data);
		}
	}
	# print Dumper \@rows;
	eval $end if $b_log;
	return @rows;
}
sub get_repos_bsd {
	eval $start if $b_log;
	my (@content,@data,@data2,@data3,@files,@rows);
	my $bsd_pkg = '/usr/local/etc/pkg/repos/';
	my $freebsd = '/etc/freebsd-update.conf';
	my $freebsd_pkg = '/etc/pkg/FreeBSD.conf';
	my $netbsd = '/usr/pkg/etc/pkgin/repositories.conf';
	my $openbsd = '/etc/pkg.conf';
	my $portsnap =  '/etc/portsnap.conf';
	if ( -f $portsnap || -f $freebsd || -d $bsd_pkg){
		if ( -f $portsnap ) {
			@data = repo_builder($portsnap,'portsnap','^\s*SERVERNAME','\s*=\s*',1);
			@rows = (@rows,@data);
		}
		if ( -f $freebsd ){
			@data = repo_builder($freebsd,'freebsd','^\s*ServerName','\s+',1);
			@rows = (@rows,@data);
		}
# 		if ( -f $freebsd_pkg ){
# 			@data = repo_builder($freebsd_pkg,'freebsd-pkg','^\s*url',':\s+',1);
# 			@rows = (@rows,@data);
# 		}
		if ( -d $bsd_pkg || -f $freebsd_pkg){
			@files = main::globber('/usr/local/etc/pkg/repos/*.conf');
			push @files, $freebsd_pkg if -f $freebsd_pkg;
			if (@files){
				my ($url);
				foreach (@files){
					push @dbg_files, $_ if $debugger_dir;
					# these will be result sets separated by an empty line
					# first dump all lines that start with #
					@content =  main::reader($_,'strip');
					# then do some clean up on the lines
					@content = map { $_ =~ s/{|}|,|\*//g; $_; } @content if @content;
					# get all rows not starting with a # and starting with a non space character
					my $url = '';
					foreach my $line (@content){
						if ($line !~ /^\s*$/){
							my @data2 = split /\s*:\s*/, $line;
							@data2 = map { $_ =~ s/^\s+|\s+$//g; $_; } @data2;
							if ($data2[0] eq 'url'){
								$url = "$data2[1]:$data2[2]";
								$url =~ s/"|,//g;
							}
							#print "url:$url\n" if $url;
							if ($data2[0] eq 'enabled'){
								if ($url && $data2[1] eq 'yes'){
									push @data3, "$url"
								}
								$url = '';
							}
						}
					}
					@data3 = url_cleaner(@data3);
					@data3 = ('No pkg enabled servers found in file') if ! @data3;
					@data = (
					{$num++ . "#BSD pkg enabled servers" => $_},
					[@data3],
					);
					@rows = (@rows,@data);
					@data3 = ();
				}
			}
		}
	}
	elsif (-f $openbsd) {
		@data = repo_builder($openbsd,'openbsd','^installpath','\s*=\s*',1);
		@rows = (@rows,@data);
	}
	elsif (-f $netbsd){
		# not an empty row, and not a row starting with #
		@data = repo_builder($netbsd,'netbsd','^\s*[^#]+$');
		@rows = (@rows,@data);
	}
	eval $start if $b_log;
	return @rows;
}
sub repo_builder {
	eval $start if $b_log;
	my ($file,$type,$search,$split,$count) = @_;
	my (@content,@data,$missing,$key);
	my %unfound = (
	'apk' => 'No repos found in this file',
	'apt' => 'No repos found in this file',
	'bsd-package' => 'No package servers found in this file',
	'pacman' => 'No repos found in this file',
	'portsnap' => 'No ports servers found in this file',
	'freebsd' => 'No update servers found in this file',
	'freebsd-pkg' => 'No default pkg server found in this file',
	'openbsd' => 'No pkg mirrors found in this file',
	'netbsd' => 'No pkg servers found in this file',
	'slackpkg' => 'No sources found in this file',
	'slackpkg-plus' => 'No sources found in this file',
	'yum' => 'No sources found in this file',
	'zypp' => 'No sources found in this file',
	);
	$missing = $unfound{$type};
	my %keys = (
	'apk' => 'APK repo',
	'apt' => 'Active apt sources in',
	'bsd-package' => 'BSD pkg server',
	'pacman' => 'Active Pacman repo servers in',
	'freebsd' => 'FreeBSD update server',
	'freebsd-pkg' => 'FreeBSD default pkg server',
	'portsnap' => 'BSD ports server',
	'openbsd' => 'OpenBSD pkg mirror',
	'netbsd' => 'NetBSD pkg servers',
	'slackpkg' => 'slackpkg sources',
	'slackpkg-plus' => 'slackpkg+ sources',
	'yum' => 'Active yum sources in',
	'zypp' => 'Active zypp sources in',
	);
	$key = $keys{$type};
	push @dbg_files, $file if $debugger_dir;
	@content =  main::reader($file);
	@content = grep {/$search/i && !/^\s*$/} @content if @content;
	@content = data_cleaner(@content);
	if ($split){
		@content = map { 
		my @inner = split (/$split/, $_);
		$inner[$count];
		} @content;
	}
	@content = url_cleaner(@content);
	@content = ($missing) if ! @content;
	@data = (
	{$num++ . "#$key" => $file},
	[@content],
	);
	eval $end if $b_log;
	return @data;
}
sub data_cleaner {
	my (@content) = @_;
	# basics: trim white space, get rid of double spaces
	@content = map { $_ =~ s/^\s+|\s+$//g; $_ =~ s/\s\s+/ /g; $_} @content;
	return @content;
}
# clean if irc
sub url_cleaner {
	my (@content) = @_;
	@content = map { $_ =~ s/:\//: \//; $_} @content if $b_irc;
	return @content;
}
sub file_path {
	my ($filename,$dir) = @_;
	my ($working);
	$working = $filename;
	$working =~ s/^\///;
	$working =~ s/\//-/g;
	$working = "$dir/file-repo-$working.txt";
	return $working;
}
}

## SensorData
{
package SensorData;
my (@sensors_data);
sub get {
	eval $start if $b_log;
	my ($key1,$val1,@rows,%sensors);
	my $num = 0;
	my $ref = $alerts{'sensors'};
	# gpu_data();
	
	if ( $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		$key1 = ucfirst($key1);
		@rows = ({$num++ . "#$key1" => $val1,});
	}
	else {
		%sensors = sensors_data();
		@rows = create_sensor_data(%sensors);
		if (!@rows) {
			$key1 = 'Message';
			$val1 = main::row_defaults('sensors-data-linux');
			@rows = ({$num++ . "#$key1" => $val1,});
		}
	}
	undef @sensors_data;
	eval $end if $b_log;
	return @rows;
}
sub create_sensor_data {
	eval $start if $b_log;
	my (%sensors) = @_;
	return if ! %sensors;
	my (@gpu,@data,@rows,@fan_default,@fan_main);
	my $fan_number = 0;
	my $num = 0;
	my $j = 0;
	@gpu = gpu_data();
	my $temp_unit  = (defined $sensors{'temp-unit'}) ? " $sensors{'temp-unit'}": '';
	my $cpu_temp = (defined $sensors{'cpu-temp'}) ? $sensors{'cpu-temp'} . $temp_unit: 'N/A';
	my $mobo_temp = (defined $sensors{'mobo-temp'}) ? $sensors{'mobo-temp'} . $temp_unit: 'N/A';
	
	@data = ({
	$num++ . '#System Temperatores' => '',
	$num++ . '#cpu' => $cpu_temp,
	$num++ . '#mobo' => $mobo_temp,
	});
	@rows = (@rows,@data);
	if (defined $sensors{'psu-temp'}){
		my $psu_temp = $sensors{'psu-temp'} . $temp_unit;
		$rows[$j]{$num++ . '#psu'} = $psu_temp;
	}
	if (scalar @gpu == 1){
		my $gpu_temp = $gpu[0]{'temp'};
		my $gpu_type = $gpu[0]{'type'};
		my $gpu_unit = (defined $gpu[0]{'temp-unit'} && $gpu_temp ) ? " $gpu[0]{'temp-unit'}" : ' C';
		$rows[$j]{$num++ . '#gpu'} = $gpu_type;
		$rows[$j]{$num++ . '#temp'} = $gpu_temp . $gpu_unit;
	}
	$j = scalar @rows;
	my $ref_main = $sensors{'fan-main'};
	my $ref_default = $sensors{'fan-default'};
	@fan_main = @$ref_main if @$ref_main;
	@fan_default = @$ref_default if @$ref_default;
	$rows[$j]{$num++ . '#Fan Speeds (in RPM)'} = '';
	my $b_cpu = 0;
	for (my $i = 0; $i < scalar @fan_main; $i++){
		next if $i == 0;# starts at 1, not 0
		if (defined $fan_main[$i]){
			if ($i == 1 || ($i == 2 && !$b_cpu )){
				$rows[$j]{$num++ . '#cpu'} = $fan_main[$i];
				$b_cpu = 1;
			}
			elsif ($i == 2 && $b_cpu){
				$rows[$j]{$num++ . '#mobo'} = $fan_main[$i];
			}
			elsif ($i == 3){
				$rows[$j]{$num++ . '#psu'} = $fan_main[$i];
			}
			elsif ($i > 3){
				$fan_number = $i - 3;
				$rows[$j]{$num++ . '#sys-' . $fan_number} = $fan_main[$i];
			}
		}
	}
	for (my $i = 0; $i < scalar @fan_default; $i++){
		next if $i == 0;# starts at 1, not 0
		if (defined $fan_default[$i]){
			$rows[$j]{$num++ . '#fan-' . $i} =$fan_default[$i];
		}
	}
	if (scalar @gpu == 1 && defined $gpu[0]{'speed'}){
		my $gpu_fan = $gpu[0]{'speed'};
		my $gpu_type = $gpu[0]{'type'};
		$rows[$j]{$num++ . '#gpu'} = $gpu_type;
		$rows[$j]{$num++ . '#fan'} = $gpu_fan;
	}
	eval $end if $b_log;
	return @rows;
}
sub sensors_data {
	eval $start if $b_log;
	my (%sensors);
	my ($b_valid,$sys_fan_nu)  = (0,0);
	my ($adapter,$fan_working,$temp_working,$working_unit)  = ('','','','');
	@sensors_data = main::grabber(main::check_program('sensors') . " 2>/dev/null");
	@sensors_data = map {$_ =~ s/\s*:\s*\+?/:/;$_} @sensors_data;
	foreach (@sensors_data){
		# we get this from gpu_data()
		if (/^(amdgpu|intel|nouveau|radeon)-pci/){
			$b_valid = 0;
			$adapter = '';
			next;
		}
		if (/^!(amdgpu|intel|nouveau|radeon)-(isa|pci|virtual)-/){
			$b_valid = 1;
			$adapter = $1;
			next;
		}
		my @working = split /:/, $_;
		# There are some guesses here, but with more sensors samples it will get closer.
		# note: using arrays starting at 1 for all fan arrays to make it easier overall
		# we have to be sure we are working with the actual real string before assigning
		# data to real variables and arrays. Extracting C/F degree unit as well to use
		# when constructing temp items for array. 
		# note that because of charset issues, no "" degree sign used, but it is required 
		# in testing regex to avoid error.
		if (/^(M\/B|MB|SIO|SYS)(.*):([0-9\.]+)[ \t](C|F)/i) {
			$sensors{'mobo-temp'} = $2;
			$working_unit = $3;
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		# issue 58 msi/asus show wrong for CPUTIN so overwrite it if PECI 0 is present
		# http://www.spinics.net/lists/lm-sensors/msg37308.html
		if (/^CPU(.*)\+([0-9]+):([0-9\.]+)[ \t](C|F)/i) {
			$sensors{'cpu-temp'} = $2;
			$working_unit = $3;
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		if (/^PECI\sAgent\s0(.*):([0-9\.]+)[ \t](C|F)/i) {
			$sensors{'cpu-peci-temp'} = $2;
			$working_unit = $3;
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		if (/^(P\/S|Power)(.*):([0-9\.]+)[ \t](C|F)/i) {
			$sensors{'psu-temp'} = $3;
			$working_unit = $4;
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		# for temp1/2 only use temp1/2 if they are null or greater than the last ones
		if (/^temp1:([0-9\.]+)[ \t](C|F)/i) {
			$temp_working = $1;
			$working_unit = $2;
			if ( !$sensors{'temp1'} || ( defined $temp_working && $temp_working > 0 ) ) {
				$sensors{'temp1'} = $temp_working;
			}
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		if (/^temp2:([0-9\.]+)[ \t](C|F)/i) {
			$temp_working = $1;
			$working_unit = $2;
			if ( !$sensors{'temp2'} || ( defined $temp_working && $temp_working > 0 ) ) {
				$sensors{'temp2'} = $temp_working;
			}
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		# temp3 is only used as an absolute override for systems with all 3 present
		if (/^temp3:([0-9\.]+)[ \t](C|F)/i) {
			$temp_working = $1;
			$working_unit = $2;
			if ( !$sensors{'temp3'} || ( defined $temp_working && $temp_working > 0 ) ) {
				$sensors{'temp3'} = $temp_working;
			}
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		# final fallback if all else fails, funtoo user showed sensors putting
		# temp on wrapped second line, not handled
		if (/^(core0|core 0|Physical id 0)(.*):([0-9\.]+)[ \t](C|F)/i) {
			$temp_working = $3;
			$working_unit = $4;
			if ( !$sensors{'core-0-temp'} || ( defined $temp_working && $temp_working > 0 ) ) {
				$sensors{'core-0-temp'} = $temp_working;
			}
			$sensors{'temp-unit'} = set_temp_unit($sensors{'temp-unit'},$working_unit) if $working_unit;
		}
		# note: can be cpu fan:, cpu fan speed:, etc.
		if (/^CPU(.*):([0-9]+)[ \t]RPM/i) {
			$sensors{'fan-main'} = () if !$sensors{'fan-main'};
			$sensors{'fan-main'}[1] = $2;
		}
		if (/^(M\/B|MB|SYS)(.*):([0-9]+)[ \t]RPM/i) {
			$sensors{'fan-main'} = () if !$sensors{'fan-main'};
			$sensors{'fan-main'}[2] = $3;
		}
		if (/(Power|P\/S|POWER)(.*):([0-9]+)[ \t]RPM/i) {
			$sensors{'fan-main'} = () if !$sensors{'fan-main'};
			$sensors{'fan-main'}[3] = $3;
		}
		# note that the counters are dynamically set for fan numbers here
		# otherwise you could overwrite eg aux fan2 with case fan2 in theory
		# note: cpu/mobo/ps are 1/2/3
		if (/^(AUX[1]? |CASE[1]? |CHASSIS[1]? )(.*):([0-9]+)[ \t]RPM/i) {
			$temp_working = $3;
			$sensors{'fan-main'} = () if !$sensors{'fan-main'};
			for ( my $i = 4; $i < 7; $i++ ){
				next if defined $sensors{'fan-main'}[$i];
				if ( !defined $sensors{'fan-main'}[$i] ){
					$sensors{'fan-main'}[$i] = $temp_working;
					last;
				}
			}
		}
		if (/^(AUX[2-9] |CASE[2-9] |CHASSIS[2-9] )(.*):([0-9]+)[ \t]RPM/i) {
			$temp_working = $3;
			$sensors{'fan-main'} = () if !$sensors{'fan-main'};
			for ( my $i = 5; $i < 30; $i++ ){
				next if defined $sensors{'fan-main'}[$i];
				if ( !defined $sensors{'fan-main'}[$i] ){
					$sys_fan_nu = $i;
					$sensors{'fan-main'}[$i] = $temp_working;
					last;
				}
			}
		}
		# in rare cases syntax is like: fan1: xxx RPM
		if (/^FAN(1)?:([0-9]+)[ \t]RPM/i) {
			$sensors{'fan-default'} = () if !$sensors{'fan-default'};
			$sensors{'fan-default'}[1] = $2;
		}
		if (/^FAN([2-9]|1[0-9])(.*):([0-9]+)[ \t]RPM/i) {
			$fan_working = $3;
			$sys_fan_nu = $1;
			$sensors{'fan-default'} = () if !$sensors{'fan-default'};
			if ( $sys_fan_nu =~ /^([0-9]+)$/ ) {
				# add to array if array index does not exist OR if number is > existing number
				if ( defined $sensors{'fan-default'}[$sys_fan_nu] ) {
					if ( $fan_working >= $sensors{'fan-default'}[$sys_fan_nu] ) {
						$sensors{'fan-default'}[$sys_fan_nu] = $fan_working;
					}
				}
				else {
					$sensors{'fan-default'}[$sys_fan_nu] = $fan_working;
				}
			}
		}
	}
	#print Data::Dumper::Dumper \%sensors;
	%sensors = data_processor(%sensors);
	# print Data::Dumper::Dumper \%sensors;
	eval $end if $b_log;
	return %sensors;
}

# oddly, openbsd sysctl actually has hw.sensors data!
sub sysctl_data {
	eval $start if $b_log;
	my (@data,%sensors);
	foreach (@sysctl_sensors){
		if (/^hw.sensors\.([0-9a-z]+)\.(temp|fan|volt)([0-9])/){
			my $sensor = $1;
			my $type = $2;
			my $number = $3;
			my @working = split /:/, $_;
		}
		last if /^(hw.cpuspeed|hw.vendor|hw.physmem)/;
	}
	
	%sensors = data_processor(%sensors);
	eval $end if $b_log;
	return %sensors;
}
sub set_temp_unit {
	my ($sensors,$working) = @_;
	my $return_unit = '';
	
	if ( !$sensors && $working ){
		$return_unit = $working;
	}
	elsif ($sensors){
		$return_unit = $sensors;
	}
	return $return_unit;
}

sub data_processor {
	eval $start if $b_log;
	my (%sensors) = @_;
	my ($cpu_temp,$index_count_fan_default,$index_count_fan_main,$mobo_temp,$psu_temp) = (0,0,0,0,0);
	my ($fan_type,$i,$j) = (0,0,0);
	my $temp_diff = 20; # for C, handled for F after that is determined
	my (@fan_main,@fan_default);
	# first we need to handle the case where we have to determine which temp/fan to use for cpu and mobo:
	# note, for rare cases of weird cool cpus, user can override in their prefs and force the assignment
	# this is wrong for systems with > 2 tempX readings, but the logic is too complex with 3 variables
	# so have to accept that it will be wrong in some cases, particularly for motherboard temp readings.
	if ( $sensors{'temp1'} && $sensors{'temp2'} ){
		if ( $sensors_cpu_nu ) {
			$fan_type = $sensors_cpu_nu;
		}
		else {
			# first some fringe cases with cooler cpu than mobo: assume which is cpu temp based on fan speed
			# but only if other fan speed is 0.
			if ( $sensors{'temp1'} >= $sensors{'temp2'} && 
			     defined $fan_default[1] && defined $fan_default[2] && $fan_default[1] == 0 && $fan_default[2] > 0 ) {
				$fan_type = 2;
			}
			elsif ( $sensors{'temp2'} >= $sensors{'temp1'} && 
			        defined $fan_default[1] && defined $fan_default[2] && $fan_default[2] == 0 && $fan_default[1] > 0 ) {
				$fan_type = 1;
			}
			# then handle the standard case if these fringe cases are false
			elsif ( $sensors{'temp1'} >= $sensors{'temp2'} ) {
				$fan_type = 1;
			}
			else {
				$fan_type = 2;
			}
		}
	}
	# need a case for no temps at all reported, like with old intels
	elsif ( !$sensors{'temp2'} && !$sensors{'cpu-temp'} ){
		if ( !$sensors{'temp1'} && !$sensors{'mobo-temp'} ){
			$fan_type = 1;
		}
		elsif ( $sensors{'temp1'} && !$sensors{'mobo-temp'} ){
			$fan_type = 1;
		}
		elsif ( $sensors{'temp1'} && $sensors{'mobo-temp'} ){
			$fan_type = 1;
		}
	}
	# convert the diff number for F, it needs to be bigger that is
	if ( $sensors{'temp-unit'} eq "F" ) {
		$temp_diff = $temp_diff * 1.8
	}
	if ( $sensors{'cpu-temp'} ) {
		# specific hack to handle broken CPUTIN temps with PECI
		if ( $sensors{'cpu-peci-temp'} && ( $sensors{'cpu-temp'} - $sensors{'cpu-peci-temp'} ) > $temp_diff ){
			$cpu_temp = $sensors{'cpu-peci-temp'};
		}
		# then get the real cpu temp, best guess is hottest is real
		else {
			$cpu_temp = $sensors{'cpu-temp'};
		}
	}
	else {
		if ($fan_type ){
			# there are some weird scenarios
			if ( $fan_type == 1 ){
				if ( $sensors{'temp1'} && $sensors{'temp2'} && $sensors{'temp2'} > $sensors{'temp1'} ) {
					$cpu_temp = $sensors{'temp2'};
				}
				else {
					$cpu_temp = $sensors{'temp1'};
				}
			}
			else {
				if ( $sensors{'temp1'} && $sensors{'temp2'} && $sensors{'temp1'} > $sensors{'temp2'} ) {
					$cpu_temp = $sensors{'temp1'};
				}
				else {
					$cpu_temp = $sensors{'temp2'};
				}
			}
		}
		else {
			$cpu_temp = $sensors{'temp1'}; # can be null, that is ok
		}
		if ( $cpu_temp ) {
			# using $sensors{'temp3'} is just not reliable enough, more errors caused than fixed imo
			#if ( $sensors{'temp3'} && $sensors{'temp3'} > $cpu_temp ) {
			#	$cpu_temp = $sensors{'temp3'};
			#}
			# there are some absurdly wrong $sensors{'temp1'}: acpitz-virtual-0 $sensors{'temp1'}: +13.8C
			if ( $sensors{'core-0-temp'} && ($sensors{'core-0-temp'} - $cpu_temp) > $temp_diff ) {
				$cpu_temp = $sensors{'core-0-temp'};
			}
		}
	}
	# if all else fails, use core0/peci temp if present and cpu is null
	if ( !$cpu_temp ) {
		if ( $sensors{'core-0-temp'} ) {
			$cpu_temp = $sensors{'core-0-temp'};
		}
		# note that peci temp is known to be colder than the actual system
		# sometimes so it is the last fallback we want to use even though in theory
		# it is more accurate, but fact suggests theory wrong.
		elsif ( $sensors{'cpu-peci-temp'} ) {
			$cpu_temp = $sensors{'cpu-peci-temp'};
		}
	}
	# then the real mobo temp
	if ( $sensors{'mobo-temp'} ){
		$mobo_temp = $sensors{'mobo-temp'};
	}
	elsif ( $fan_type ){
		if ( $fan_type == 1 ) {
			if ( $sensors{'temp1'} && $sensors{'temp2'} && $sensors{'temp2'} > $sensors{'temp1'} ) {
				$mobo_temp = $sensors{'temp1'};
			}
			else {
				$mobo_temp = $sensors{'temp2'};
			}
		}
		else {
			if ( $sensors{'temp1'} && $sensors{'temp2'} && $sensors{'temp1'} > $sensors{'temp2'} ) {
				$mobo_temp = $sensors{'temp2'};
			}
			else {
				$mobo_temp = $sensors{'temp1'};
			}
		}
		## NOTE: not safe to assume $sensors{'temp3'} is the mobo temp, sad to say
		#if ( $sensors{'temp1'} && $sensors{'temp2'} && $sensors{'temp3'} && $sensors{'temp3'} < $mobo_temp ) {
		#	$mobo_temp = $sensors{'temp3'};
		#}
	}
	else {
		$mobo_temp = $sensors{'temp2'};
	}
	@fan_main = @{$sensors{'fan-main'}} if $sensors{'fan-main'};
	$index_count_fan_main = (@fan_main) ? scalar @fan_main : 0;
	@fan_default = @{$sensors{'fan-default'}} if $sensors{'fan-default'};
	$index_count_fan_default = (@fan_default) ? scalar @fan_default : 0;
	# then set the cpu fan speed
	if ( ! $fan_main[1] ) {
		# note, you cannot test for $fan_default[1] or [2] != "" 
		# because that creates an array item in gawk just by the test itself
		if ( $fan_type == 1 && defined $fan_default[1] ) {
			$fan_main[1] = $fan_default[1];
			$fan_default[1] = undef;
		}
		elsif ( $fan_type == 2 && defined $fan_default[2] ) {
			$fan_main[1] = $fan_default[2];
			$fan_default[2] = undef;
		}
	}
	# clear out any duplicates. Primary fan real trumps fan working always if same speed
	for ($i = 1; $i <= $index_count_fan_main; $i++) {
		if ( defined $fan_main[$i] && $fan_main[$i] ) {
			for ($j = 1; $j <= $index_count_fan_default; $j++) {
				if ( defined $fan_default[$j] && $fan_main[$i] == $fan_default[$j] ) {
					$fan_default[$j] = undef;
				}
			}
		}
	}
	# now see if you can find the fast little mobo fan, > 5000 rpm and put it as mobo
	# note that gawk is returning true for some test cases when $fan_default[j] < 5000
	# which has to be a gawk bug, unless there is something really weird with arrays
	# note: 500 > $fan_default[j] < 1000 is the exact trigger, and if you manually 
	# assign that value below, the > 5000 test works again, and a print of the value
	# shows the proper value, so the corruption might be internal in awk. 
	# Note: gensub is the culprit I think, assigning type string for range 501-1000 but 
	# type integer for all others, this triggers true for >
	for ($j = 1; $j <= $index_count_fan_default; $j++) {
		if ( defined $fan_default[$j] && $fan_default[$j] > 5000 && !$fan_main[2] ) {
			$fan_main[2] = $fan_default[$j];
			$fan_default[$j] = '';
			# then add one if required for output
			if ( $index_count_fan_main < 2 ) {
				$index_count_fan_main = 2;
			}
		}
	}
	# if they are ALL null, print error message. psFan is not used in output currently
	if ( !$cpu_temp && !$mobo_temp && !$fan_main[1] && !$fan_main[2] && !$fan_main[1] && !@fan_default ) {
		%sensors = ();
	}
	else {
		my ($psu_temp);
		if ( $sensors{'psu-temp'} ){
			$psu_temp = $sensors{'psu-temp'};
		}
		%sensors = (
		'cpu-temp' => $cpu_temp,
		'mobo-temp' => $mobo_temp,
		'psu-temp' => $psu_temp,
		'temp-unit' => $sensors{'temp-unit'},
		'fan-main' => \@fan_main,
		'fan-default' => \@fan_default,
		);
		if ($psu_temp){
			$sensors{'psu-temp'} = $psu_temp;
		}
	}
	
		
	eval $end if $b_log;
	return %sensors;
}
sub gpu_data {
	eval $start if $b_log;
	return @gpudata if $b_gpudata;
	my ($cmd,@data,@data2,$path,@screens,$temp);
	my ($j) = (0);
	if ($path = main::check_program('nvidia-settings')){
		# first get the number of screens. This only work if you are in X
		if ($b_display) {
			@data = main::grabber("$path -q screens");
			foreach (@data){
				if ( /(:[0-9]\.[0-9])/ ) {
					push @screens, $1;
				}
			}
		}
		# do a guess, this will work for most users, it's better than nothing for out of X
		else {
			$screens[0] = ':0.0';
		}
		# now we'll get the gpu temp for each screen discovered. The print out function
		# will handle removing screen data for single gpu systems. -t shows only data we want
		# GPUCurrentClockFreqs: 520,600
		# GPUCurrentFanSpeed: 50 0-100, not rpm, percent I think
		# VideoRam: 1048576
		# CUDACores: 16 
		# PCIECurrentLinkWidth: 16
		# PCIECurrentLinkSpeed: 5000
		# RefreshRate: 60.02 Hz [oer screen]
		# ViewPortOut=1280x1024+0+0}, DPY-1: nvidia-auto-select @1280x1024 +1280+0 {ViewPortIn=1280x1024,
		# ViewPortOut=1280x1024+0+0}
		# ThermalSensorReading: 50
		# PCIID: 4318,2661 - the pci stuff doesn't appear to work
		# PCIBus: 2
		# PCIDevice: 0
		# Irq: 30
		foreach my $screen (@screens){
			my $screen2 = $screen;
			$screen2 =~ s/\.[0-9]$//;
			$cmd = '-q GPUCoreTemp -q VideoRam -q GPUCurrentClockFreqs -q PCIECurrentLinkWidth ';
			$cmd .= '-q Irq -q PCIBus -q PCIDevice -q GPUCurrentFanSpeed';
			@data = main::grabber("$path -c $screen2 $cmd 2>/dev/null");
			@data = (@data,@data2);
			$j = scalar @gpudata;
			$gpudata[$j] = ({});
			foreach my $item (@data){
				if ($item =~ /^\s*Attribute\s\'([^']+)\'\s.*:\s*([\S]+)\.$/){
					my $attribute = $1;
					my $value = $2;
					$gpudata[$j]{'type'} = 'nvidia';
					$gpudata[$j]{'screen'} = $screen;
					if (!$gpudata[$j]{'temp'} && $attribute eq 'GPUCoreTemp'){
						$gpudata[$j]{'temp'} = $value;
					}
					elsif (!$gpudata[$j]{'ram'} && $attribute eq 'VideoRam'){
						$gpudata[$j]{'ram'} = $value;
					}
					elsif (!$gpudata[$j]{'clock'} && $attribute eq 'GPUCurrentClockFreqs'){
						$gpudata[$j]{'clock'} = $value;
					}
					elsif (!$gpudata[$j]{'bus'} && $attribute eq 'PCIBus'){
						$gpudata[$j]{'bus'} = $value;
					}
					elsif (!$gpudata[$j]{'bus-id'} && $attribute eq 'PCIDevice'){
						$gpudata[$j]{'bus-id'} = $value;
					}
					elsif (!$gpudata[$j]{'fan-speed'} && $attribute eq 'GPUCurrentFanSpeed'){
						$gpudata[$j]{'fan-speed'} = $value;
					}
				}
			}
		}
	}
	if ($path = main::check_program('aticonfig')){
		# aticonfig --adapter=0 --od-gettemperature
		@data = main::grabber("$path --adapter=all --od-gettemperature 2>/dev/null");
		foreach (@data){
			if (/Sensor [^0-9]*([0-9\.]+) /){
				$j = scalar @gpudata;
				$gpudata[$j] = ({});
				my $value = $1;
				$gpudata[$j]{'type'} = 'amd';
				$gpudata[$j]{'temp'} = $value;
			}
		}
	}
	if (@sensors_data){
		my ($b_found,$holder) = (0,'');
		foreach (@sensors_data){
			next if (/^Adapter:/ || /^\s*$/);
			if (/^(amdgpu|intel|nouveau|radeon)-pci-(.*)/){
				$b_found = 1;
				$holder = $1;
				$j = scalar @gpudata;
			}
			if ($b_found){
				if (/^temp.*:([0-9]+).*(C|F)/){
					$gpudata[$j]{'temp'} = $1;
					$gpudata[$j]{'type'} = $holder;
					$gpudata[$j]{'unit'} = $2;
				}
				if (/^fan.*:([0-9]+).*(RPM)?/){
					$gpudata[$j]{'fan-speed'} = $1;
				}
			}
			if (/!(intel|nouveau|radeon)-(pci|virtual|isa)-(.*)/){
				$b_found = 0;
				$holder = '';
			}
		}
	}
	# we'll probably use this data elsewhere so make it a one time call
	$b_gpudata = 1;
	# print Data::Dumper::Dumper \@gpudata;
	eval $end if $b_log;
	return @gpudata;
}
}

## SlotData
{
package SlotData;

sub get {
	eval $start if $b_log;
	my (@data,@rows,$key1,$val1);
	my $num = 0;
	my $ref = $alerts{'dmidecode'};
	if ($b_arm){
		$key1 = 'ARM';
		$val1 = main::row_defaults('arm-pci','');
		@rows = ({$num++ . "#$key1" => $val1,});
	}
	elsif ( $$ref{'action'} ne 'use'){
		$key1 = $$ref{'action'};
		$val1 = $$ref{$key1};
		$key1 = ucfirst($key1);
		@rows = ({$num++ . "#$key1" => $val1,});
	}
	else {
		@rows = slot_data();
	}
	return @rows;
	eval $end if $b_log;
	
}
sub slot_data {
	eval $start if $b_log;
	my (@data,@rows);
	my $num = 0;
	foreach (@dmi){
		$num = 1;
		my @ref = @$_;
		if ($ref[0] == 9){
			my ($designation,$id,$length,$type,$usage) = ('','','','','');
			# skip first two row, we don't need that data
			splice @ref, 0, 2 if @ref;
			my $j = scalar @rows;
			foreach my $item (@ref){
				if ($item !~ /^~/){ # skip the indented rows
					my @value = split /:\s+/, $item;
					if ($value[0] eq 'Type'){
						$type = $value[1];
					}
					if ($value[0] eq 'Designation'){
						$designation = $value[1];
					}
					if ($value[0] eq 'Current Usage'){
						$usage = $value[1];
						
					}
					if ($value[0] eq 'ID'){
						$id = $value[1];
					}
					if ($extra > 1 && $value[0] eq 'Length'){
						$length = $value[1];
					}
				}
			}
			if ($type){
				$id = 'N/A' if ($id eq '' );
				if ($type eq 'Other' && $designation){
					$type = $designation;
				}
				elsif ($type && $designation) {
					$type = "$type $designation";
				}
				@data = (
				{
				$num++ . "#Slot" => $id,
				$num++ . "#type" => $type,
				$num++ . "#status" => $usage,
				},
				);
				@rows = (@rows,@data);
				if ($extra > 1 ){
					$rows[$j]{$num++ . "#length"} = $length;
				}
			}
		}
	}
	if (!@rows){
		my $key = 'Message';
		@data = ({
		$num++ . "#$key" => main::row_defaults('pci-slot-data',''),
		},);
		@rows = (@rows,@data);
	}
	eval $end if $b_log;
	return @rows;
}
}

## UnmountedData
{
package UnmountedData;

sub get {
	eval $start if $b_log;
	my (@rows,$key1,$val1);
	my $num = 0;
# 	my $ref = $alerts{'sensors'};
# 	if ( $$ref{'action'} ne 'use'){
# 		$key1 = $$ref{'action'};
# 		$val1 = $$ref{$key1};
# 		$key1 = ucfirst($key1);
# 	}
# 	else {
		$key1 = 'Status';
		$val1 = main::row_defaults('dev');
# 	}
	my @data = ({$num++ . "#$key1" => $val1,});
	return @data;
	eval $end if $b_log;
	
}
sub unmounted_data {
	eval $start if $b_log;
	my (@rows);
	my $num = 0;
	
	eval $end if $b_log;
	return @rows;
}
}
## UsbData
{
package UsbData;

sub get {
	eval $start if $b_log;
	my (@data,@rows,$key1,$val1);
	my $num = 0;
	my $ref = $alerts{'lsusb'};
	my $ref2 = $alerts{'usbdevs'};
	if ( $$ref{'action'} ne 'use' && $$ref2{'action'} ne 'use'){
		if ($os eq 'linux' ){
			$key1 = $$ref{'action'};
			$val1 = $$ref{$key1};
		}
		else {
			$key1 = $$ref2{'action'};
			$val1 = $$ref2{$key1};
		}
		$key1 = ucfirst($key1);
		@rows = ({$num++ . "#$key1" => $val1,});
	}
	else {
		@rows = usb_data();
		#$key1 = 'Status';
		#$val1 = 'under development';
		if (!@rows){
			my $key = 'Message';
			@data = ({
			$num++ . "#$key" => main::row_defaults('usb-data',''),
			},);
			@rows = (@rows,@data);
		}
	}
	return @rows;
	eval $end if $b_log;
}
sub usb_data {
	eval $start if $b_log;
	return if ! @usb;
	my (@data,@row,@rows,$bus_id,$chip_id,$speed,$protocol,$class,$vendor,$product);
	my $num = 0;
	my $j = 0;
	# note: the data has been presorted in set_lsusb_data by:
	# bus id then device id, so we don't need to worry about the order
	foreach my $ref (@usb){
		my @id = @$ref;
		$j = scalar @rows;
		$bus_id = "$id[0]:$id[1]";
		$chip_id = $id[2];
		my $b_hub = 0;
		# it's a hub
		if ($id[1] == 1){
			foreach my $line (@id){
				#print "$line\n";
				@row = split /:/, $line;
				if ($row[0] eq 'bcdUSB'){
					$speed  = $row[1]
				}
				elsif ($row[0] eq '~bInterfaceProtocol'){
					$protocol = $row[2];
				}
			}
			#print "pt0:$protocol\n";
			@data = ({
			$num++ . "#Hub" => $bus_id,
			$num++ . "#usb" => $speed,
			$num++ . "#type" => $protocol,
			},);
			@rows = (@rows,@data);
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = $chip_id;
			}
		}
		# it's a device
		else {
			($class,$product,$protocol,$vendor,$speed) = ('','','','','');
			foreach my $line (@id){
				@row = split /:/, $line;
				if ($row[0] eq 'bcdUSB'){
					$speed  = $row[1]
				}
				elsif ($row[0] eq 'bDeviceClass' && $row[1] == 9){
					$b_hub = 1;
				}
				elsif ($row[0] eq 'idVendor'){
					$vendor  = main::cleaner($row[2]);
				}
				elsif ($row[0] eq 'idProduct'){
					$product = main::cleaner($row[2]) if $row[2];
				}
				# we want hubs to cascade to last item
				elsif ($row[0] eq '~bInterfaceClass' && $row[1] != 9){
					$class = main::cleaner($row[2]) if $row[2];
				}
				elsif ($row[0] eq '~bInterfaceProtocol'){
					$protocol = $row[2];
				}
			}
			if ( $b_hub ){
				if ($vendor && $product){
					$protocol = "$vendor $product";
				}
				elsif (!$product && $protocol && $vendor){
					$protocol = "$vendor $protocol";
				}
				#print "pt2:$protocol\n";
				@data = ({
				$num++ . "#Hub" => $bus_id,
				$num++ . "#usb" => $speed,
				$num++ . "#type" => $protocol,
				},);
				@rows = (@rows,@data);
			}
			else {
				if ($vendor && $product){
					if ($product !~ /$vendor/){
						$product = "$vendor $product";
					}
				}
				elsif (!$product && !$vendor && $protocol){
					$product = $protocol;
				}
				elsif (!$product){
					$product = $vendor;
				}
				# bInterfaceProtocol:0 but $row[2] undefined
				#print "pt3:$class:$product\n";
				if ($protocol && $class && $class ne $protocol){
					$class = $protocol;
				}
				$class ||= 'N/A';
				#print "pt3:$class:$product\n";
				$rows[$j]{$num++ . "#Device"} = $product;
				$rows[$j]{$num++ . "#bus ID"} = $bus_id;
				if ($extra > 0){
					$rows[$j]{$num++ . "#usb"} = $speed;
				}
				$rows[$j]{$num++ . "#type"} = $class;
			}
			if ($extra > 1){
				$rows[$j]{$num++ . "#chip ID"} = $chip_id;
			}
			
		}
		
	}
	#print Data::Dumper::Dumper \@rows;
	eval $end if $b_log;
	return @rows;
}
}

## add metric / imperial (us) switch
## WeatherData
{
package WeatherData;

sub get {
	eval $start if $b_log;
	my (@rows,$key1,$val1);
	my $num = 0;
	@rows = create_weather_data();
	eval $end if $b_log;
	return @rows;
}
sub create_weather_data {
	eval $start if $b_log;
	my $num = 0;
	my (@data,@location,@rows,%weather,);
	my ($conditions) = ('NA');
	if ($show{'weather-location'}){
		my $location_string;
		$location_string = $show{'weather-location'};
		$location_string =~ s/\+/ /g;
		if ( $location_string =~ /,/){
			my @temp = split /,/, $location_string;
			my $sep = '';
			my $string = '';
			foreach (@temp){
				$_ = ucfirst($_);
				$string .= $sep . $_;
				$sep = ', ';
			}
			$location_string = $string;
		}
		$location_string = main::apply_filter($location_string);
		@location = ($show{'weather-location'},$location_string,'');
	}
	else {
		@location = get_location();
		if (!$location[0]) {
			return @rows = ({
			$num++ . "#Message" => main::row_defaults('weather-null','current location'),
			});
		}
	}
	%weather = get_weather(@location);
	if (!$weather{'weather'}) {
		return @rows = ({
		$num++ . "#Message" => main::row_defaults('weather-null','weather data'),
		});
	}
	if ($weather{'temp'} && $weather{'weather'} ){
		$conditions = "$weather{'temp'} - $weather{'weather'}";
	}
	elsif ($weather{'temp'}){
		$conditions = $weather{'temp'};
	}
	elsif ($weather{'weather'}) {
		$conditions = $weather{'weather'};
	}
	@data = ({
	$num++ . "#Conditions" => $conditions,
	},);
	@rows = (@rows,@data);
	if ($extra > 0){
		$rows[0]{$num++ . "#Wind"} = $weather{'wind'};
		$rows[0]{$num++ . "#Humidity"} = $weather{'humidity'};
		$rows[0]{$num++ . "#Pressure"} = $weather{'pressure'};
	}
	if ($extra > 1){
		if ($weather{'heat-index'}){
			$rows[0]{$num++ . "#Heat Index"} = $weather{'heat-index'};
		}
		if ($weather{'windchill'}){
			$rows[0]{$num++ . "#Wind Chill"} = $weather{'windchill'};
		}
		if ($weather{'dewpoint'}){
			$rows[0]{$num++ . "#Dew Point"} = $weather{'dewpoint'};
		}
	}
	if ($extra > 2){
		if (!$show{'filter'}){
			$rows[0]{$num++ . "#Location"} = $location[1];
			$rows[0]{$num++ . "#Altitude"} = $weather{'elevation'};
		}
	}
	$rows[0]{$num++ . "#Time"} = $weather{'date-time'};
	if ($extra > 2){
		$rows[0]{$num++ . "#Observation Time"} = $weather{'observation-time-local'};
	}
	eval $end if $b_log;
	return @rows;
}
sub get_weather {
	eval $start if $b_log;
	my (@location) = @_;
	my $now = POSIX::strftime "%Y%m%d%H%M", localtime;
	my ($date_time,$freshness,$tz,@weather_data,%weather);
	my $loc_name = lc($location[0]);
	$loc_name =~ s/-\/|\s|,/-/g;
	$loc_name =~ s/--/-/g;
	my $file_cached = "$user_data_dir/weather-$loc_name.txt";
	if (-f $file_cached){
		@weather_data = main::reader($file_cached);
		$freshness = (split /\^\^/, $weather_data[0])[1];
		#print "$now:$freshness\n";
	}
	if (!$freshness || $freshness < $now - 90) {
		my $url = "http://api.wunderground.com/auto/wui/geo/WXCurrentObXML/index.xml?query=$location[0]";
 		my $temp;
# 		{
# 			#my $file2 = "$ENV{'HOME'}/bin/scripts/inxi/data/weather/weather-1.xml";
# 			# my $file2 = "$ENV{'HOME'}/bin/scripts/inxi/data/weather/feed-oslo-1.xml";
# 			local $/;
# 			my $file = "$ENV{'HOME'}/bin/scripts/inxi/data/weather/weather-1.xml";
# 			open my $fh, '<', $file or die "can't open $file: $!";
# 			$temp = <$fh>;
# 		}
 		$temp = main::download_file('stdout',$url);
		$temp =~ s/\r|\n\n/\n/g;
		my @weather_temp = split /\n/, $temp;
		foreach (@weather_temp){
			chomp $_;
			$_ =~ s/<\/[^>]+>//;
			$_ =~ s/.*icon.*|\r//g;
			$_ =~ s/\s\s/ /g;
			$_ =~ s/^\s+|\s+$//g;
			$_ =~ s/>/^^/;
			$_ =~ s/^<|NA$//g;
			$_ =~ s/^(current|credit|terms|image|title|link|.*_url).*//;
			push @weather_data, $_ if $_ !~ /^\s*$/;
		}
		unshift (@weather_data,("timestamp^^$now"));
		main::writer($file_cached,\@weather_data);
		#print "$file_cached: download/cleaned\n";
	}
	#print join "\n", @weather_data, "\n";
	
	foreach (@weather_data){
		my @working = split /\s*\^\^\s*/,$_;
		if ( $working[0] eq 'local_time' ){
			$weather{'local-time'} = $working[1];
		}
		elsif ( $working[0] eq 'weather' ){
			$weather{'weather'} = $working[1];
		}
		elsif ( $working[0] eq 'temperature_string' ){
			$weather{'temp'} = $working[1];
# 			$weather{'temp'} =~ s/\sF/\xB0 F/; # B0
# 			$weather{'temp'} =~ s/\sF/\x{2109}/;
# 			$weather{'temp'} =~ s/\sC/\x{2103}/;
		}
		elsif ( $working[0] eq 'relative_humidity' ){
			$weather{'humidity'} = $working[1];
		}
		elsif ( $working[0] eq 'wind_string' ){
			$weather{'wind'} = $working[1];
		}
		elsif ( $working[0] eq 'pressure_string' ){
			$weather{'pressure'} = $working[1];
		}
		elsif ( $working[0] eq 'heat_index_string' ){
			$weather{'head-index'} = $working[1];
		}
		elsif ( $working[0] eq 'windchill_string' ){
			$weather{'windchill'} = $working[1];
		}
		elsif ( $working[0] eq 'dewpoint_string' ){
			$weather{'dewpoint'} = $working[1];
		}
		elsif ( $working[0] eq 'observation_time_rfc822' ){
			$weather{'observation-time-gmt'} = $working[1];
		}
		elsif ( $working[0] eq 'observation_time_rfc822' ){
			$weather{'observation-time-gmt'} = $working[1];
		}
		elsif ( $working[0] eq 'observation_time' ){
			$weather{'observation-time-local'} = $working[1];
			$weather{'observation-time-local'} =~ s/Last Updated on //;
		}
		elsif (!$weather{'elevation'} && $working[0] eq 'elevation'){
			# note: bug in source data uses ft for meters, not 100% of time, but usually
			$weather{'elevation'} = $working[1];
			$weather{'elevation'} =~ s/ft/m/;
		}
	}
	if ($show{'weather-location'}){
		$weather{'observation-time-local'} =~ /^(.*)\s([\S]+)$/;
		$tz = $2;
		# very clever trick, just make the system think it's in the 
		# remote timezone for this local block only
		local $ENV{'TZ'} = $tz;
		$date_time = POSIX::strftime "%c", localtime;
		$weather{'date-time'} = $date_time;
	}
	else {
		$date_time = POSIX::strftime "%c", localtime;
		$tz = ( $location[2] ) ? " ($location[2])" : ''; 
		$weather{'date-time'} = $date_time . $tz;
	}
	return %weather;
	eval $end if $b_log;
}
sub get_location {
	eval $start if $b_log;
	my ($city,$country,$freshness,%loc,$loc_arg,$loc_string,@loc_data,$state);
	my $now = POSIX::strftime "%Y%m%d%H%M", localtime;
	my $file_cached = "$user_data_dir/location-main.txt";
	if (-f $file_cached){
		@loc_data = main::reader($file_cached);
		$freshness = (split /\^\^/, $loc_data[0])[1];
	}
	if (!$freshness || $freshness < $now - 90) {
		my $temp;
		my $url = "http://geoip.ubuntu.com/lookup";
# 		{
# 			local $/;
# 			my $file = "$ENV{'HOME'}/bin/scripts/inxi/data/weather/location-1.xml";
# 			open my $fh, '<', $file or die "can't open $file: $!";
# 			$temp = <$fh>;
# 		}
		$temp  = main::download_file('stdout',$url);
		@loc_data = split /\n/, $temp;
		@loc_data = map {
		s/<\?.*<Response>//;
		s/<\/[^>]+>/\n/g;
		s/>/^^/g;
		s/<//g;
		$_;
		} @loc_data;
		@loc_data = split /\n/, $loc_data[0];
		unshift (@loc_data,("timestamp^^$now"));
		main::writer($file_cached,\@loc_data);
		#print "$file_cached: download/cleaned\n";
	}
	foreach (@loc_data){
		my @working = split /\s*\^\^\s*/,$_;
		#print "$working[0]:$working[1]\n";
		if ($working[0] eq 'CountryCode3' ) {
			$loc{'country3'} = $working[1];
		}
		elsif ($working[0] eq 'CountryCode' ) {
			$loc{'country'} = $working[1];
		}
		elsif ($working[0] eq 'CountryName' ) {
			$loc{'country2'} = $working[1];
		}
		elsif ($working[0] eq 'RegionCode' ) {
			$loc{'region-id'} = $working[1];
		}
		elsif ($working[0] eq 'RegionName' ) {
			$loc{'region'} = $working[1];
		}
		elsif ($working[0] eq 'City' ) {
			$loc{'city'} = $working[1];
		}
		elsif ($working[0] eq 'ZipPostalCode' ) {
			$loc{'zip'} = $working[1];
		}
		elsif ($working[0] eq 'Latitude' ) {
			$loc{'lat'} = $working[1];
		}
		elsif ($working[0] eq 'Longitude' ) {
			$loc{'long'} = $working[1];
		}
		elsif ($working[0] eq 'TimeZone' ) {
			$loc{'tz'} = $working[1];
		}
	}
	#print Data::Dumper::Dumper \%loc;
	# assign location, cascade from most accurate
	# latitude,longitude first
	if ($loc{'lat'} && $loc{'long'}){
		$loc_arg = "$loc{'lat'},$loc{'long'}";
	}
	# city,state next
	elsif ($loc{'city'} && $loc{'region-id'}){
		$loc_arg = "$loc{'city'},$loc{'region-id'}";
	}
	# postal code last, that can be a very large region
	elsif ($loc{'zip'}){
		$loc_arg = $loc{'zip'};
	}
	$country = ($loc{'country3'}) ? $loc{'country3'} : $loc{'country'};
	$city = ($loc{'city'}) ? $loc{'city'} : 'City N/A';
	$state = ($loc{'region-id'}) ? $loc{'region-id'} : 'Region N/A';
	$loc_string = main::apply_filter("$city, $state, $country");
	my @location = ($loc_arg,$loc_string,$loc{'tz'});
	#print ($loc_arg,"\n", join "\n", @loc_data, "\n",scalar @loc_data, "\n");
	eval $end if $b_log;
	return @location;
}
}

#### -------------------------------------------------------------------
#### UTILITIES FOR DATA LINES
#### -------------------------------------------------------------------

sub get_compiler_version {
	eval $start if $b_log;
	my (@compiler);
	if (my $file = system_files('version') ) {
		@compiler = get_compiler_version_linux($file);
	}
	else {
		@compiler = get_compiler_version_bsd();
	}
	eval $end if $b_log;
	return @compiler;
}
sub get_compiler_version_bsd {
	eval $start if $b_log;
	my (@compiler,@working);
	if ($alerts{'sysctl'}{'action'} eq 'use'){
		# for dragonfly, we will use free mem, not used because free is 0
		my @working;
		foreach (@sysctl){
			# freebsd seems to use bytes here
			# Not every line will have a : separator though the processor should make 
			# most have it. This appears to be 10.x late feature add, I don't see it
			# on earlier BSDs
			if (/^kern.compiler_version/){
				@working = split /:\s*/, $_;
				$working[1] =~ /.*(gcc|clang)\sversion\s([\S]+)\s.*/;
				@compiler = ($1,$2);
				last;
			}
		}
	}
	else {
		@compiler = ('N/A','');
	}
	log_data(@compiler) if $b_log;
	eval $end if $b_log;
	return @compiler;
}
sub get_compiler_version_linux {
	eval $start if $b_log;
	my ($file) = @_;
	my (@compiler,$type);
	my @data = reader($file);
	my $result = $data[0] if @data;
	if ($result){
		$result =~ /(gcc|clang).*version\s([\S]+)/;
		# $result = $result =~ /\*(gcc|clang)\*eval\*/;
		if ($1){
			$type = $2;
			$type ||= 'N/A'; # we don't really know what linux clang looks like!
			@compiler = ($1,$type);
		}
	}
	log_data(@compiler) if $b_log;
	
	eval $end if $b_log;
	return @compiler;
}

## Get DesktopEnvironment
## returns array:
# 0 - desktop name
# 1 - version
# 2 - toolkit
# 3 - toolkit version
# 4 - info extra desktop data
{
package DesktopEnvironment;
my ($b_xprop,$kde_session_version,$xdg_desktop,@desktop,@data,@xprop);
sub get {
	# NOTE $XDG_CURRENT_DESKTOP envvar is not reliable, but it shows certain desktops better.
	# most desktops are not using it as of 2014-01-13 (KDE, UNITY, LXDE. Not Gnome)
	$xdg_desktop = ( $ENV{'XDG_CURRENT_DESKTOP'} ) ? lc($ENV{'XDG_CURRENT_DESKTOP'}) : '';
	$kde_session_version = ($ENV{'KDE_SESSION_VERSION'}) ? $ENV{'KDE_SESSION_VERSION'} : '';
	get_kde_data();
	if (!@desktop){
		get_env_de_data();
	}
	if (!@desktop){
		get_env_xprop_de_data();
	}
	if (!@desktop && $b_xprop ){
		get_xprop_de_data();
	}
	if (!@desktop){
		get_ps_de_data();
	}
	if ($extra > 2 && @desktop){
		set_info_data();
	}
	main::log_data('desktop data: ' . main::joiner(\@desktop, "\n", 'unset')) if $b_log;
	return @desktop;
}
sub get_kde_data {
	eval $start if $b_log;
	my ($program,@version_data,@version_data2);
	my $kde_full_session = ($ENV{'KDE_FULL_SESSION'}) ? $ENV{'KDE_FULL_SESSION'} : '';
	return 1 if ($xdg_desktop ne 'kde' && !$kde_session_version && $kde_full_session ne 'true' );
	# works on 4, assume 5 will id the same, why not, no need to update in future
	# KDE_SESSION_VERSION is the integer version of the desktop
	# NOTE: as of plasma 5, the tool: about-distro MAY be available, that will show
	# actual desktop data, so once that's in debian/ubuntu, if it gets in, add that test
	if ($xdg_desktop eq 'kde' || $kde_session_version ){
		if ($kde_session_version <= 4){
			@data = main::program_values("kded$kde_session_version");
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version("kded$kde_session_version",$data[0],$data[1],$data[2],$data[5]);
		}
		else {
			# NOTE: this command string is almost certain to change, and break, with next 
			# major plasma desktop, ie, 6. 
			# qdbus org.kde.plasmashell /MainApplication org.qtproject.Qt.QCoreApplication.applicationVersion
			# Qt: 5.4.2
			# KDE Frameworks: 5.11.0
			# kf5-config: 1.0
			# for QT, and Frameworks if we use it
			if ($program = main::check_program("kded$kde_session_version")){
				@version_data = main::grabber("$program --version 2>/dev/null");
			}
			if ($program = main::check_program("plasmashell")){
				@version_data2 = main::grabber("$program --version 2>/dev/null");
				$desktop[1] = main::awk(\@version_data2,'^plasmashell',-1,'\s+');
			}
			$desktop[0] = 'KDE Plasma';
		}
		if (!$desktop[1]){
			$desktop[1] = $kde_session_version;
		}
		# print Data::Dumper::Dumper \@version_data;
		if ($extra > 0 && @version_data){
			$desktop[2] = 'Qt';
			$desktop[3] = main::awk(\@version_data,'^Qt:', 2,'\s+');
		}
	}
	# KDE_FULL_SESSION property is only available since KDE 3.5.5.
	elsif ($kde_full_session eq 'true'){
		@version_data = main::grabber("kded --version 2>/dev/null");
		$desktop[0] = 'KDE';
		$desktop[1] = main::awk(\@version_data,'^KDE:',2,'\s+');
		if (!$desktop[1]){
			$desktop[1] = '3.5';
		}
		if ($extra > 0){
			$desktop[3] = main::awk(\@version_data,'^Qt:',2,'\s+');
		}
	}
	eval $end if $b_log;
}
sub get_env_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	
	if ($xdg_desktop eq 'unity'){
		@data = main::program_values('unity');
		$desktop[0] = $data[3];
		$desktop[0] ||= 'Unity';
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
	}
	elsif ( $xdg_desktop =~ /budgie/ ){
		@data = main::program_values('budgie');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('budgie-desktop',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
	}
	elsif ( $xdg_desktop eq 'lxqt' ){
		@data = main::program_values('lxqt');
		$desktop[0] = $data[3];
		$desktop[0] ||= 'LXQT';
		$desktop[1] = main::program_version('lxqt-about',$data[0],$data[1],$data[2],$data[5]);
		if ( $extra > 0 ){
			if ($program = main::check_program("kded$kde_session_version") ){
				@version_data = main::grabber("$program --version 2>/dev/null");
				$desktop[2] = 'Qt';
				$desktop[3] = main::awk(\@version_data,'^Qt:',2);
			}
			elsif ($program = main::check_program("qtdiag") ){
				@data = main::program_values('qtdiag');
				$desktop[3] = main::program_version($program,$data[0],$data[1],$data[2],$data[5]);
				$desktop[2] = $data[3];
			}
		}
	}
	# note, X-Cinnamon value strikes me as highly likely to change, so just 
	# search for the last part
	elsif ( $xdg_desktop =~ /cinnamon/ ){
		@data = main::program_values('cinnamon');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
	}
	eval $end if $b_log;
}
sub get_env_xprop_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	set_xprop();
	# note that cinnamon split from gnome, and and can now be id'ed via xprop,
	# but it will still trigger the next gnome true case, so this needs to go 
	# before gnome test eventually this needs to be better organized so all the 
	# xprop tests are in the same section, but this is good enough for now.
	if (main::check_program('muffin') && $b_xprop && main::awk(\@xprop,'_muffin' )){
		@data = main::program_values('cinnamon');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('cinnamon',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
		$desktop[0] ||= 'Cinnamon';
	}
	elsif ($xdg_desktop eq 'mate' || $b_xprop && main::awk(\@xprop,'_marco')){
		@data = main::program_values('mate');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('mate-about',$data[0],$data[1],$data[2],$data[5]);
		set_gtk_data() if $extra > 0;
		$desktop[0] ||= 'MATE';
	}
	# note, GNOME_DESKTOP_SESSION_ID is deprecated so we'll see how that works out
	# https://bugzilla.gnome.org/show_bug.cgi?id=542880
	elsif ($xdg_desktop eq 'gnome' || $ENV{'GNOME_DESKTOP_SESSION_ID'}){
		if ($program = main::check_program('gnome-about') ) {
			@data = main::program_values('gnome-about');
			$desktop[1] = main::program_version('gnome-about',$data[0],$data[1],$data[2],$data[5]);
		}
		elsif ($program = main::check_program('gnome-shell') ) {
			@data = main::program_values('gnome-shell');
			$desktop[1] = main::program_version('gnome-shell',$data[0],$data[1],$data[2],$data[5]);
		}
		set_gtk_data() if $extra > 0;
		$desktop[0] = ( $data[3] ) ? $data[3] : 'Gnome';
	}
	eval $end if $b_log;
}
sub get_xprop_de_data {
	eval $start if $b_log;
	my ($program,@version_data,$version);
	#print join "\n", @xprop, "\n";
	# String: "This is xfdesktop version 4.2.12"
	# alternate: xfce4-about --version > xfce4-about 4.10.0 (Xfce 4.10)
	if ($xdg_desktop eq 'xfce' || main::awk(\@xprop,'xfce' )){
		# this is a very expensive test that doesn't usually result in a find
		# talk to xfce to see what id they will be using for xfce 5
# 		if (main::awk(\@xprop, 'xfce4')){
# 			$version = '4';
# 		}
		if (main::awk(\@xprop, 'xfce5')){
			$version = '5';
		}
		else {
 			$version = '4';
		}
		@data = main::program_values('xfdesktop');
		$desktop[0] = $data[3];
		# xfdesktop --version out of x fails to get display, so no data
		@version_data = main::grabber('xfdesktop --version 2>/dev/null');
		# out of x, this error goes to stderr, so it's an empty result
		$desktop[1] = main::awk(\@version_data,$data[0],$data[1],'\s+');
		#$desktop[1] = main::program_version('xfdesktop',$data[0],$data[1],$data[2],$data[5]);
		if ( !$desktop[1] ){
			@data = main::program_values("xfce${version}-panel");
			# print Data::Dumper::Dumper \@data;
			# this returns an error message to stdout in x, which breaks the version
			# xfce4-panel --version out of x fails to get display, so no data
			$desktop[1] = main::program_version("xfce${version}-panel",$data[0],$data[1],$data[2],$data[5]);
			# out of x this kicks out an error: xfce4-panel: Cannot open display
			$desktop[1] = '' if $desktop[1] !~ /[0-9]\./; 
		}
		$desktop[0] ||= 'Xfce';
		$desktop[1] ||= 4;
		if ($extra > 0){
			@data = main::program_values('xfdesktop-toolkit');
			#$desktop[3] = main::program_version('xfdesktop',$data[0],$data[1],$data[2],$data[5]);
			$desktop[3] = main::awk(\@version_data,$data[0],$data[1],'\s+');
			$desktop[2] = $data[3];
		}
	}
	elsif ( (main::check_program('blackbox') || main::check_program('fluxbox')) && main::awk(\@xprop,'blackbox_pid' )){
		if (grep {/fluxbox/} @ps_cmd){
			@data = main::program_values('fluxbox');
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version('fluxbox',$data[0],$data[1],$data[2],$data[5]);
		}
		else {
			@data = main::program_values('blackbox');
			$desktop[0] = $data[3];
			$desktop[1] = main::program_version('blackbox',$data[0],$data[1],$data[2],$data[5]);
		}
	}
	# debian package: lxde-core
	elsif ( (main::check_program('lxpanel') || main::check_program('lxqt-session') ||
	     main::check_program('razor-session')) && main::awk(\@xprop,'openbox_pid' )){
		# note: openbox-lxde --version may be present, but returns openbox data
		@data = main::program_values('openbox');
		$desktop[1] = main::program_version('openbox',$data[0],$data[1],$data[2],$data[5]);
		if ($xdg_desktop eq 'lxde' || main::awk(\@ps_cmd, 'lxsession')){
			$desktop[1] = "(Openbox $desktop[1])" if $desktop[1];
			$desktop[0] = 'LXDE';
		}
		elsif ($xdg_desktop eq 'razor' || $xdg_desktop eq 'lxqt' || main::awk(\@ps_cmd, 'razor-desktop|lxqt-session')) {
			if (main::awk(\@ps_cmd,'lxqt-session' )){
				$desktop[0] = 'LXQt';
			}
			elsif (main::awk(\@ps_cmd, 'razor-desktop')){
				$desktop[0] = 'Razor-Qt';
			}
			else {
				$desktop[0] = 'LX-Qt-Variant';
			}
			$desktop[1] = "(Openbox $desktop[1])" if $desktop[1];
		}
		else {
			$desktop[0] = 'Openbox';
		}
	}
	elsif (main::check_program('icewm') && main::awk(\@xprop,'icewm' )){
		@data = main::program_values('icewm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('icewm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('enlightenment') && main::awk(\@xprop,'enlightenment' )){
		$desktop[0] = 'Enlightenment';
		# no -v or --version but version is in xprop -root
		# ENLIGHTENMENT_VERSION(STRING) = "Enlightenment 0.16.999.49898"
		$desktop[1] = main::awk(\@xprop,'enlightenment_version',2,'\s+=\s+' );
		$desktop[1] = (split /"/, $desktop[1])[1] if $desktop[1];
		$desktop[1] = (split /\s+/, $desktop[1])[1] if $desktop[1];
	}
	# debian package: i3-wm
	elsif (main::check_program('i3') && main::awk(\@xprop,'^i3_' )){
		@data = main::program_values('i3');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('i3',$data[0],$data[1],$data[2],$data[5]);
	}
	# debian package name: wmaker
	elsif (main::check_program('WindowMaker') && main::awk(\@xprop,'^windowmaker' )){
		@data = main::program_values('wmaker');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wmaker',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('wm2') && main::awk(\@xprop,'^_wm2' )){
		@data = main::program_values('wm2');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wm2',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('herbstluftwm') && main::awk(\@xprop,'herbstluftwm' )){
		@data = main::program_values('herbstluftwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('herbstluftwm',$data[0],$data[1],$data[2],$data[5]);
	}
	# need to check starts line because it's so short
	eval $end if $b_log;
}
sub get_ps_de_data {
	eval $start if $b_log;
	my ($program,@version_data);
	if ( main::check_program('fvwm-crystal') && main::awk(\@ps_cmd,'fvwm-crystal' )){
		@data = main::program_values('fvwm-crystal');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('fvwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif ((main::check_program('fvwm2') || main::check_program('fvwm')) && main::awk(\@ps_cmd,'fvwm' )){
		@data = main::program_values('fvwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('fvwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('pekwm') && main::awk(\@ps_cmd,'pekwm' )){
		@data = main::program_values('pekwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('pekwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('awesome') && main::awk(\@ps_cmd,'awesome' )){
		@data = main::program_values('awesome');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('awesome',$data[0],$data[1],$data[2],$data[5]);
	}
	# not in debian apt
	elsif (main::check_program('scrotwm') && main::awk(\@ps_cmd,'scrotwm' )){
		@data = main::program_values('scrotwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('scrotwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('spectrwm') && main::awk(\@ps_cmd,'spectrwm' )){
		@data = main::program_values('spectrwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('spectrwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('twm') && main::awk(\@ps_cmd,'(\s|\/)twm' )){
		# no version
		$desktop[0] = 'Twm';
	}
	# note: built from source, but I assume it will show: /usr/bin/dwm
	elsif (main::check_program('dwm') && main::awk(\@ps_cmd,'(\s|\/)dwm' )){
		@data = main::program_values('dwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('dwm',$data[0],$data[1],$data[2],$data[5]);
	}
	# not in debian apt, current is wmii, version 3
	elsif (main::check_program('wmii2') && main::awk(\@ps_cmd,'wmii2' )){
		@data = main::program_values('wmii2');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wmii2',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('wmii') && main::awk(\@ps_cmd,'wmii' )){
		@data = main::program_values('wmii');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('wmii',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('jwm') && main::awk(\@ps_cmd,'(\s|\/)jwm' )){
		@data = main::program_values('jwm');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('jwm',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif (main::check_program('sawfish') && main::awk(\@ps_cmd,'sawfish' )){
		@data = main::program_values('sawfish');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('sawfish',$data[0],$data[1],$data[2],$data[5]);
	}
	elsif ( main::check_program('afterstep') && grep {/afterstep/} @ps_cmd){
		@data = main::program_values('afterstep');
		$desktop[0] = $data[3];
		$desktop[1] = main::program_version('afterstep',$data[0],$data[1],$data[2],$data[5]);
	}
	eval $end if $b_log;
}

sub set_gtk_data {
	eval $start if $b_log;
	my ($version,$program,@data);
	# this is a hack, and has to be changed with every toolkit version change, and 
	# only dev systems 	# have this installed, but it's a cross distro command try it.
	if ($program = main::check_program('pkg-config')){
		@data = main::grabber("$program --modversion gtk+-4.0 2>/dev/null");
		$version = main::awk(\@data,'\S');
		# note: opensuse gets null output here, we need the command to get version and output sample
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-3.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
		if ( !$version ){
			@data = main::grabber("$program --modversion gtk+-2.0 2>/dev/null");
			$version = main::awk(\@data,'\S');
		}
	}
	# now let's go to more specific version tests, this will never cover everything and that's fine.
	if (!$version){
		# we'll try some known package managers next. dpkg will handle a lot of distros 
		# this is the most likely order as of: 2014-01-13. Not going to try to support all 
		# package managers too much work, just the very biggest ones.
		if ($program = main::check_program('dpkg')){
			@data = main::grabber("$program -s libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s+');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -s libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
			if (!$version){
				@data = main::grabber("$program -s libgtk2.0-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s+');
			}
		}
		elsif ($program = main::check_program('pacman')){
			@data = main::grabber("$program -Qi gtk3 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -Qi gtk4 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -Qi gtk2 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
		elsif ($program = main::check_program('rpm')){
			@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
			$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			# just guessing on gkt 4 package name
			if (!$version){
				@data = main::grabber("$program -qi libgtk-4-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
			if (!$version){
				@data = main::grabber("$program -qi libgtk-3-0 2>/dev/null");
				$version = main::awk(\@data,'^\s*Version',2,'\s*:\s*');
			}
		}
	}
	$desktop[2] = 'Gtk';
	eval $end if $b_log;
}
sub set_info_data {
	eval $start if $b_log;
	my (@data,@info,$item);
	if (@data = grep {/(gnome-shell|gnome-panel|kicker|lxpanel|mate-panel|plasma-desktop|plasma-netbook|xfce4-panel)(\s|$)/} @ps_cmd ) {
		# only one entry per type, can be multiple
		foreach $item (@data){
			if (! main::awk(\@info, "$item")){
				$item = main::trimmer($item);
				$item =~ s/.*\///;
				push @info, (split /\s+/, $item)[0];
			}
		}
	}
	$desktop[4] = join (',', @info) if @info;
	eval $end if $b_log;
}

sub set_xprop {
	eval $start if $b_log;
	if (my $program = main::check_program('xprop')){
		@xprop = main::grabber("xprop -root $display_opt 2>/dev/null");
		if (@xprop){
			@xprop = grep {/^\S/} @xprop;
			$_=lc for @xprop;
			$b_xprop = 1 if scalar @xprop > 5;
		}
	}
	eval $end if $b_log;
}

}

sub get_display_manager {
	eval $start if $b_log;
	my (@data,@found,$temp,$working);
	# ldm - LTSP display manager. Note that sddm does not appear to have a .pid 
	# extension in Arch note: to avoid positives with directories, test for -f 
	# explicitly, not -e
	my @dms = qw(entranced.pid gdm.pid gdm3.pid kdm.pid ldm.pid 
	lightdm.pid lxdm.pid mdm.pid nodm.pid sddm.pid sddm slim.lock 
	tint2.pid wdm.pid xdm.pid);
	# this is the only one I know of so far that has --version
	# lightdm outputs to stderr, so it has to be redirected
	my @dms_version = qw(lightdm);
	foreach my $id (@dms){
		# note: ${dm_id%.*}/$dm_id will create a dir name out of the dm id, then 
		# test if pid is in that note: sddm, in an effort to be unique and special, 
		# do not use a pid/lock file, but rather a random string inside a directory 
		# called /run/sddm/ so assuming the existence of the pid inside a directory named
		# from the dm. Hopefully this change will not have negative results.
		$working = $id;
		$working =~ s/\.\S+$//;
		# note: there's always been an issue with duplicated dm's in inxi, this should now correct it
		if ( ( -f "/run/$id" || -d "/run/$working" || -f "/var/run/$id" ) && ! grep {/$working/} @found ){
			if ($extra > 2 && awk( \@dms_version, $working) ){
				@data = main::grabber("$working --version 2>&1");
				$temp = awk(\@data,'\S',2,'\s+');
				$working .= ' ' . $temp if $temp;
			}
			push @found, $working;
		}
	}
	if (!@found && grep {/\/usr.*\/x/ && !/\/xprt/} @ps_cmd){
		if (awk (\@ps_cmd, 'startx') ){
			$found[0] = 'startx';
		}
	}
	# might add this in, but the rate of new dm's makes it more likely it's an 
	# unknown dm, so we'll keep output to N/A
	log_data('display manager: ' . main::joiner(\@found, '; ', 'unset')) if $b_log;
	eval $end if $b_log;
	return join ',', @found if @found;
}
## Get DistroData
{
package DistroData;
my ($distro);
sub get {
	if ($bsd_type){
		get_bsd_os();
	}
	else {
		get_linux_distro();
	}
	return $distro;
}

sub get_bsd_os {
	eval $start if $b_log;
	if ($bsd_type eq 'darwin'){
		my $file = '/System/Library/CoreServices/SystemVersion.plist';
		if (-f $file){
			my @data = main::reader($file);
			@data = grep {/(ProductName|ProductVersion)/} @data if @data;
			@data = grep {/<string>/} @data if @data;
			@data = map {s/<[\/]?string>//g; } @data if @data;
			$distro = join (' ', @data);
		}
	}
	else {
		my @uname = POSIX::uname();
		$distro = "$uname[0] $uname[2]";
	}
	
	eval $end if $b_log;
	return $distro;
}

sub get_linux_distro {
	eval $start if $b_log;
	my $distro_file = '';
	my (@working,$b_osr);
	my @derived = qw(antix-version aptosid-version kanotix-version knoppix-version 
	mandrake-release mx-version pardus-release porteus-version sabayon-release 
	siduction-version sidux-version slitaz-release solusos-release turbolinux-release 
	zenwalk-version);
	my $derived_s = join "|", @derived;
	my @primary = qw(arch-release gentoo-release redhat-release slackware-version 
	SuSE-release);
	my $primary_s = join "|", @primary;
	my $exclude_s = 'debian_version|devuan_version|ubuntu_version';
	my $lsb_good_s = 'mandrake-release|mandriva-release|mandrakelinux-release|manjaro-release';
	my $os_release_good_s = 'arch-release|SuSE-release';
	# note: always exceptions, so wild card after release/version: 
	# /etc/lsb-release-crunchbang
	# wait to handle since crunchbang file is one of the few in the world that 
	# uses this method
	my @distro_files = glob('/etc/*[-_]{[rR]elease,[vV]ersion}*');
	my $distro_files_s = join "|", @distro_files;
	my $lsb_release = '/etc/lsb-release';
	my $b_lsb = ( -f $lsb_release ) ? 1 : 0;
	my $issue = '/etc/issue';
	my $os_release = '/etc/os-release';
	my $b_os_release = ( -f $os_release ) ? 1 : 0;
	main::log_data( "distro files:\n" . main::joiner(\@distro_files, "\n", 'unset')) if $b_log;
	if ( $#distro_files == 1 ){
		$distro_file = $distro_files[0];
	}
	else {
		@working = (@derived,@primary);
		foreach my $file (@working){
			if ( "/etc/$file" =~ /($distro_files_s)$/){
				# Now lets see if the distro file is in the known-good working-lsb-list
				# if so, use lsb-release, if not, then just use the found file
				# this is for only those distro's with self named release/version files
				# because Mint does not use such, it must be done as below 
				## this if statement requires the spaces and * as it is, else it won't work
				if ($b_lsb && $file =~ /$lsb_good_s/){
					$distro_file = $lsb_release;
				}
				elsif ($b_os_release && $file =~ /($os_release_good_s)$/){
					$distro_file = $os_release;
				}
				else {
					$distro_file = "/etc/$file";
				}
				last;
			}
		}
		main::log_data("distro_file: $distro_file") if $b_log;
	}
	
	# first test for the legacy antiX distro id file
	if ( -f '/etc/antiX'){
		@working = main::reader('/etc/antiX');
		$distro = main::awk(\@working,'antix.*\.iso') if @working;
		$distro = main::clean_characters($distro) if $distro;
	}
	# this handles case where only one release/version file was found, and it's lsb-release. 
	# This would never apply for ubuntu or debian, which will filter down to the following 
	# conditions. In general if there's a specific distro release file available, that's to 
	# be preferred, but this is a good backup.
	elsif ($distro_file && $b_lsb && ($distro_file =~ /\/etc\/($lsb_good_s)$/ || $distro_file eq $lsb_release) ){
		$distro = get_lsb_release();
	}
	elsif ($distro_file eq $os_release){
		$distro = get_os_release();
		$b_osr = 1;
	}
	# if distro id file was found and it's not in the exluded primary distro file list, read it
	elsif ( $distro_file && -s $distro_file && $distro_file !~ /\/etc\/($exclude_s)$/){
		# new opensuse uses os-release, but older ones may have a similar syntax, so just use 
		# the first line
		if ($distro_file eq '/etc/SuSE-release'){
			# leaving off extra data since all new suse have it, in os-release, this file has 
			# line breaks, like os-release  but in case we  want it, it's: 
			# CODENAME = Mantis  | VERSION = 12.2 
			# for now, just take first occurrence, which should be the first line, which does 
			# not use a variable type format
			@working = main::reader($distro_file);
			$distro = main::awk(\@working,'suse');
			$distro = main::clean_characters($distro) if $distro;
		}
		else {
			$distro = (main::reader($distro_file))[0];
		}
	}
	# otherwise try  the default debian/ubuntu /etc/issue file
	elsif (-f $issue){
		@working = main::reader($issue);
		my $b_mint = scalar (grep {/mint/i} @working); 
		# os-release/lsb gives more manageable and accurate output than issue, 
		# but mint should use issue for now.
		if ($b_os_release && !$b_mint){
			$distro = get_os_release();
			$b_osr = 1;
		}
		elsif ($b_lsb && !$b_mint){
			$distro = get_lsb_release();
		}
		else {
			# debian issue can end with weird escapes like \n \l
			@working = main::reader($issue);
			$distro = (map {s/\\[a-z]|,|\*|\\||\"|[:\47]|^\s+|\s+$|n\/a//ig; $_} @working)[0] if @working;
			# this handles an arch bug where /etc/arch-release is empty and /etc/issue 
			# is corrupted only older arch installs that have not been updated should 
			# have this fallback required, new ones use os-release
			if ( $distro =~ /arch linux/i){
				$distro = 'Arch Linux';
			}
		}
	}
	# a final check. If a long value, before assigning the debugger output, if os-release
	# exists then let's use that if it wasn't tried already. Maybe that will be better.
	# not handling the corrupt data, maybe later if needed
	if ($distro && length($distro) > 50 ){
		if (!$b_osr && $b_os_release){
			$distro = get_os_release();
		}
	}
	# test for /etc/lsb-release as a backup in case of failure, in cases 
	# where > one version/release file were found but the above resulted 
	# in null distro value. 
	if (!$distro){
		if ($b_os_release){
			$distro = get_os_release();
		}
		elsif ($b_lsb){
			$distro = get_lsb_release();
		}
	}
	# now some final null tries
	if (!$distro ){
		# if the file was null but present, which can happen in some cases, then use 
		# the file name itself to set the distro value. Why say unknown if we have 
		# a pretty good idea, after all?
		if ($distro_file){
			$distro_file =~ s/[-_]|release|version//g;
		}
	}
	## finally, if all else has failed, give up
	$distro ||= 'unknown';
	eval $end if $b_log;
	return $distro;
}
sub get_lsb_release {
	eval $start if $b_log;
	my ($distro,$id,$release,$codename,$description,) = ('','','','','');
	my @content = main::reader('/etc/lsb-release');
	@content = map {s/,|\*|\\||\"|[:\47]|^\s+|\s+$|n\/a//ig; $_} @content if @content;
	foreach (@content){
		my @working = split /\s*=\s*/, $_;
		if ($working[0] eq 'DISTRIB_ID' && $working[1]){
			if ($working[1] =~ /^Arch$/i){
				$id = 'Arch Linux';
			}
			else {
				$id = $working[1];
			}
		}
		if ($working[0] eq 'DISTRIB_RELEASE' && $working[1]){
			$release = $working[1];
		}
		if ($working[0] eq 'DISTRIB_CODENAME' && $working[1]){
			$codename = $working[1];
		}
		# sometimes some distros cannot do their lsb-release files correctly, 
		# so here is one last chance to get it right.
		if ($working[0] eq 'DISTRIB_DESCRIPTION' && $working[1]){
			$description = $working[1];
		}
	}
	if (!$id && !$release && !$codename && $description){
		$distro = $description;
	}
	else {
		$distro = "$id $release $codename";
		$distro =~ s/^\s+|\s\s+|\s+$//g; # get rid of double and trailling spaces 
	}
	
	eval $end if $b_log;
	return $distro;
}
sub get_os_release {
	eval $start if $b_log;
	my ($pretty_name,$name,$version_name,$version_id,
	$distro_name,$distro) = ('','','','','','');
	my @content = main::reader('/etc/os-release');
	@content = map {s/\\||\"|[:\47]|^\s+|\s+$|n\/a//ig; $_} @content if @content;
	foreach (@content){
		my @working = split /\s*=\s*/, $_;
		if ($working[0] eq 'PRETTY_NAME' && $working[1]){
			$pretty_name = $working[1];
		}
		if ($working[0] eq 'NAME' && $working[1]){
			$name = $working[1];
		}
		if ($working[0] eq 'VERSION' && $working[1]){
			$version_name = $working[1];
		}
		if ($working[0] eq 'VERSION_ID' && $working[1]){
			$version_id = $working[1];
		}
	}
	# NOTE: tumbleweed has pretty name but pretty name does not have version id
	if ($pretty_name && $pretty_name !~ /tumbleweed/i){
		$distro = $pretty_name;
	}
	elsif ($name){
		$distro = $name;
		if ($version_name){
			$distro .= ' ' . $version_name;
		}
		elsif ($version_id){
			$distro .= ' ' . $version_id;
		}
		
	}
	eval $end if $b_log;
	return $distro;
}
}
sub get_gcc_data {
	eval $start if $b_log;
	my ($gcc,@data,@gccs,@temp);
	# NOTE: We can't use program_version because we don't yet know where
	# the version number is
	if (my $program = check_program('gcc') ){
		@data = grabber("$program --version 2>/dev/null");
		$gcc = awk(\@data,'^gcc');
	}
	if ($gcc){
		# strip out: gcc (Debian 6.3.0-18) 6.3.0 20170516
		# gcc (GCC) 4.2.2 20070831 prerelease [FreeBSD]
		$gcc =~ s/\([^\)]*\)//g;
		$gcc = get_piece($gcc,2);
	}
	if ($extra > 1){
		# glob /usr/bin for gccs, strip out all non numeric values
		@temp = globber('/usr/bin/gcc-*');
		foreach (@temp){
			if (/\/gcc-([0-9.]+)$/){
				push @gccs, $1;
			}
		}
	}
	unshift @gccs, $gcc;
	log_data("gccs: " . main::joiner(\@gccs, '; ', 'unset')) if $b_log;
	eval $end if $b_log;
	return @gccs;
}
sub get_hostname {
	eval $start if $b_log;
	my $hostname = '';
	if ( $ENV{'HOSTNAME'} ){
		$hostname = $ENV{'HOSTNAME'};
	}
	else {
		$hostname = hostname;
	}
	$hostname ||= 'N/A';
	eval $end if $b_log;
	return $hostname;
}
sub get_init_data {
	eval $start if $b_log;
	my $runlevel = get_runlevel_data();
	my $default = ($extra > 1) ? get_runlevel_default() : '';
	my ($init,$init_version,$rc,$rc_version,$program) = ('','','','','');
	my $comm = ( -e '/proc/1/comm' ) ? (reader('/proc/1/comm'))[0] : '';
	my (@data);
	# this test is pretty solid, if pid 1 is owned by systemd, it is systemd
	# otherwise that is 'init', which covers the rest of the init systems.
	# more data may be needed for other init systems.
	if ( $comm ){
		if ( $comm =~ /systemd/ ){
			$init = 'systemd';
			if ( $program = check_program('systemd')){
				$init_version = program_version($program,'^systemd','2','--version');
			}
			if (!$init_version && ($program = check_program('systemctl') ) ){
				$init_version = program_version($program,'^systemd','2','--version');
			}
		}
		# output: /sbin/init --version:  init (upstart 1.1)
		elsif ($init_version = program_version('init', 'upstart', '3','--version')){
			$init = 'Upstart';
		}
		# epoch version == Epoch Init System 1.0.1 "Sage"
		elsif ($comm =~ /epoch/){
			$init = 'Epoch';
			$init_version = program_version('epoch', '^Epoch', '4','version');
		}
		# missing data: note, runit can install as a dependency without being the 
		# init system: http://smarden.org/runit/sv.8.html
		# NOTE: the proc test won't work on bsds, so if runit is used on bsds we 
		# will need more data
		elsif ($comm =~ /runit/){
			$init = 'runit';
		}
	}
	if (!$init){
		if (check_program('launchctl')){
			$init = 'launchd';
		}
		elsif ( -f '/etc/inittab' ){
			$init = 'SysVinit';
			if (check_program('strings')){
				@data = grabber('strings /sbin/init');
				$init_version = awk(\@data,'version\s+[0-9]');
				$init_version = get_piece($init_version,2) if $init_version;
			}
		}
		elsif ( -f '/etc/ttys' ){
			$init = 'init (BSD)';
		}
	}
	if ( grep { /openrc/ } globber('/run/*openrc*') ){
		$rc = 'OpenRC';
		# /sbin/openrc --version == openrc (OpenRC) 0.13
		if ($program = check_program('openrc')){
			$rc_version = program_version($program, '^openrc', '3','--version');
		}
		# /sbin/rc --version == rc (OpenRC) 0.11.8 (Gentoo Linux)
		elsif ($program = check_program('rc')){
			$rc_version = program_version($program, '^rc', '3','--version');
		}
		if ( -e '/run/openrc/softlevel' ){
			$runlevel = (reader('/run/openrc/softlevel'))[0];
		}
		elsif ( -e '/var/run/openrc/softlevel'){
			$runlevel = (reader('/var/run/openrc/softlevel'))[0];
		}
		elsif ( $program = check_program('rc-status')){
			$runlevel = (grabber("$program -r 2>/dev/null"))[0];
		}
	}
	my %init = (
	'init-type' => $init,
	'init-version' => $init_version,
	'rc-type' => $rc,
	'rc-version' => $rc_version,
	'runlevel' => $runlevel,
	'default' => $default,
	);
	eval $end if $b_log;
	return %init;
}
sub get_kernel_data {
	eval $start if $b_log;
	my ($kernel,$ksplice) = ('','');
	# Linux; yawn; 4.9.0-3.1-liquorix-686-pae; #1 ZEN SMP PREEMPT liquorix 4.9-4 (2017-01-14); i686
	# FreeBSD; siwi.pair.com; 8.2-STABLE; FreeBSD 8.2-STABLE #0: Tue May 31 14:36:14 EDT 2016     erik5@iddhi.pair.com:/usr/obj/usr/src/sys/82PAIRx-AMD64; amd64
	my @uname = uname();
	if (@uname){
		$kernel = $uname[2];
		if (check_program('uptrack-uname') && $kernel){
			$ksplice = qx(uptrack-uname -rm);
			$ksplice = trimmer($ksplice);
			$kernel = ($ksplice) ? $ksplice . ' (ksplice)' : $kernel;
		}
		$kernel .= ' ' . $uname[scalar @uname - 1];
		$kernel = ($bsd_type) ? $uname[0] . ' ' . $kernel : $kernel;
	}
	
	$kernel ||= 'N/A';
	log_data("kernel: $kernel ksplice: $ksplice") if $b_log;
	eval $end if $b_log;
	return $kernel;
}
sub get_kernel_bits {
	eval $start if $b_log;
	my $bits = '';
	my @uname = uname();
	if (@uname){
		$bits = $uname[scalar @uname - 1];
		$bits = ($bits =~ /64/ ) ? 64 : 32;
	}
	$bits ||= 'N/A';
	eval $end if $b_log;
	return $bits;
}
sub get_memory_data {
	eval $start if $b_log;
	my ($memory);
	if (my $file = system_files('meminfo') ) {
		$memory = get_memory_data_linux($file);
	}
	else {
		$memory = get_memory_data_bsd();
	}
	eval $end if $b_log;
	return $memory;
}
sub get_memory_data_linux {
	eval $start if $b_log;
	my ($file) = @_;
	my $memory = '';
	my $total = 0;
	my $not_used = 0;
	my @data = reader($file);
	foreach (@data){
		if ($_ =~ /^MemTotal:/){
			$total = get_piece($_,2);
		}
		elsif ($_ =~ /^(MemFree|Buffers|Cached):/){
			$not_used +=  get_piece($_,2);
		}
	}
	my $used = $total - $not_used;
	my $percent = ($used && $total) ? sprintf(" (%.1f%%)", ($used/$total)*100) : '';
	$memory = sprintf("%.1f/%.1f MB", $used/1024, $total/1024) . $percent;
	log_data("memory: $memory") if $b_log;
	eval $end if $b_log;
	return $memory;
}
# openbsd/linux
# procs    memory       page                    disks    traps          cpu
# r b w    avm     fre  flt  re  pi  po  fr  sr wd0 wd1  int   sys   cs us sy id
# 0 0 0  55256 1484092  171   0   0   0   0   0   2   0   12   460   39  3  1 96
# freebsd:
# procs      memory      page                    disks     faults         cpu
# r b w     avm    fre   flt  re  pi  po    fr  sr ad0 ad1   in   sy   cs us sy id
# 0 0 0  21880M  6444M   924  32  11   0   822 827   0   0  853  832  463  8  3 88
# with -H
# 2 0 0 14925812  936448    36  13  10   0    84  35   0   0   84   30   42 11  3 86
# dragonfly
#  procs      memory      page                    disks     faults      cpu
#  r b w     avm    fre  flt  re  pi  po  fr  sr ad0 ad1   in   sy  cs us sy id
#  0 0 0       0  84060 30273993 2845 12742 1164 407498171 320960902   0   0 ....
sub get_memory_data_bsd {
	eval $start if $b_log;
	my $memory = '';
	my ($avail,$total,$free_mem,$real_mem) = (0,0,0,0);
	my (@data,$message);
	if (my $program = check_program('vmstat')){
		# see above, it's the last line. -H makes it hopefully all in kB so no need 
		# for K/M/G tests
		my $row = (grabber('vmstat -H 2>/dev/null','\n','strip'))[-1];
		if ( $row ){
			@data = split /\s+/, $row;
			# dragonfly can have 0 avg, but they may fix that so make test dynamic
			if ($data[3] != 0){
				$avail = sprintf ('%.1f',$data[3]/1024);
			}
			elsif ($data[4] != 0){
				$free_mem = sprintf ('%.1f',$data[4]/1024);
			}
		}
	}
	## code to get total goes here:
	my $ref = $alerts{'sysctl'};
	if ($$ref{'action'} eq 'use'){
		# for dragonfly, we will use free mem, not used because free is 0
		my @working;
		foreach (@sysctl){
			# freebsd seems to use bytes here
			if (!$real_mem && /^hw.physmem:/){
				@working = split /:\s*/,$_;
				#if ($working[1]){
					$working[1] =~ s/^[^0-9]+|[^0-9]+$//g;
					$real_mem = sprintf("%.1f", $working[1]/1024/1024);
				#}
				last if $free_mem;
			}
			# But, it uses K here. Openbsd/Dragonfly do not seem to have this item
			# this can be either: Free Memory OR Free Memory Pages
			elsif (/^Free Memory:/){
				@working = split /:\s*/,$_;
				$working[1] =~ s/[^0-9]+//g;
				$free_mem = sprintf("%.1f", $working[1]/1024);
				last if $real_mem;
			}
		}
	}
	else {
		$message = "sysctl $$ref{'action'}"
	}
	# not using, but leave in place for a bit in case we want it
	# my $type = ($free_mem) ? ' free':'' ;
	# hack: temp fix for openbsd/darwin: in case no free mem was detected but we have physmem
	if (($avail || $free_mem) && !$real_mem){
		my $error = ($message) ? $message: 'total N/A';
		my $used = (!$free_mem) ? $avail : $real_mem - $free_mem;
		$memory = "$used/($error) MB";
	}
	# use openbsd/dragonfly avail mem data if available
	elsif (($avail || $free_mem) && $real_mem) {
		my $used = (!$free_mem) ? $avail : $real_mem - $free_mem;
		my $percent = ($used && $real_mem) ? sprintf(" (%.1f%%)", ($used/$real_mem)*100) : '';
		$memory = "$used/$real_mem MB" . $percent;
	}
	eval $end if $b_log;
	return $memory;
}

sub get_module_version {
	eval $start if $b_log;
	my ($module) = @_;
	return if ! $module;
	my ($version);
	my $path = "/sys/module/$module/version";
	if (-f $path){
		$version = (reader($path))[0];
	}
	elsif (-f "/sys/module/$module/uevent"){
		$version = 'kernel';
	}
	#print "version:$version\n";
	if (!$version) {
		if (my $path = check_program('modinfo')){
			my @data = grabber("$path $module 2>/dev/null");
			$version = awk(\@data,'^version',2,':\s+') if @data;
		}
	}
	$version ||= '';
	eval $end if $b_log;
	return $version;
}
# # check? /var/run/nologin for bsds?
sub get_runlevel_data {
	eval $start if $b_log;
	my $runlevel = '';
	if ( my $program = check_program('runlevel')){
		$runlevel = (grabber($program))[0];
		$runlevel =~ s/[^\d]//g;
		#print_line($runlevel . ";;");
	}
	eval $end if $b_log;
	return $runlevel;
}
# note: it appears that at least as of 2014-01-13, /etc/inittab is going 
# to be used for default runlevel in upstart/sysvinit. systemd default is 
# not always set so check to see if it's linked.
sub get_runlevel_default {
	eval $start if $b_log;
	my @data;
	my $default = '';
	my $b_systemd = 0;
	my $inittab = '/etc/inittab';
	my $systemd = '/etc/systemd/system/default.target';
	my $upstart = '/etc/init/rc-sysinit.conf';
	# note: systemd systems do not necessarily have this link created
	if ( -e $systemd){
		$default = readlink($systemd);
		$default =~ s/.*\/// if $default; 
		$b_systemd = 1;
	}
	# http://askubuntu.com/questions/86483/how-can-i-see-or-change-default-run-level
	# note that technically default can be changed at boot but for inxi purposes 
	# that does not matter, we just want to know the system default
	elsif ( -e $upstart){
		# env DEFAULT_RUNLEVEL=2
		@data = reader($upstart);
		$default = awk(\@data,'^env\s+DEFAULT_RUNLEVEL',2,'=');
	}
	# handle weird cases where null but inittab exists
	if (!$default && -e $inittab ){
		@data = reader($inittab);
		$default = awk(\@data,'^id.*initdefault',2,':');
	}
	eval $end if $b_log;
	return $default;
}
sub get_self_version {
	eval $start if $b_log;
	my $patch = $self_patch;
	if ( $patch ne '' ){
		# for cases where it was for example: 00-b1 clean to -b1
		$patch =~ s/^[0]+-?//;
		$patch = "-$patch";
	}
	eval $end if $b_log;
	return $self_version . $patch;
}
sub sensors_gpu_search {
	return 'amdgpu|intel|radeon|nouveau';
}
sub get_shell_data {
	eval $start if $b_log;
	my ($ppid) = @_;
	my $shell = qx(ps -p $ppid -o comm= 2>/dev/null);
	chomp($shell);
	if ($shell){
		# when run in debugger subshell, would return sh as shell,
		# and parent as perl, that is, pinxi itself, which is actually right.
		if ($shell eq 'sh' && $shell ne $ENV{'SHELL'}){
			$shell = $ENV{'SHELL'};
			$shell =~ s/^.*\///;
		}
		# sh because -v/--version doesn't work on it, ksh because
		# it takes too much work to handle all the variants
		if ( $shell ne 'sh' && $shell ne 'ksh' ) {
			@app = main::program_values(lc($shell));
			if ($app[0]){
				$client{'version'} = main::program_version($shell,$app[0],$app[1],$app[2]);
			}
			# guess that it's two and --version
			else {
				$client{'version'} = main::program_version($shell,2,'');
			}
			$client{'version'} =~ s/(\(.*|-release|-version)//;
		}
		$client{'name'} = lc($shell);
		$client{'name-print'} = $shell;
	}
	else {
		$client{'name'} = 'shell';
		$client{'name-print'} = 'Unknown Shell';
	}
	eval $end if $b_log;
}
sub get_shell_source {
	eval $start if $b_log;
	my (@data);
	my ($script_parent,$shell_parent) = ('','');
	my $ppid = getppid();
	$script_parent = get_start_parent($ppid);
	if ($script_parent){
		$shell_parent = get_shell_parent($script_parent);
		# no idea why have to do script_parent action twice in su case, but you do.
		if ( $shell_parent && $shell_parent eq 'su' ){
			$script_parent = get_start_parent($script_parent);
			$script_parent = get_start_parent($script_parent);
			$shell_parent = get_shell_parent($script_parent);
		}
	}
	log_data("parents: script: $script_parent shell: $shell_parent") if $b_log;
	eval $end if $b_log;
	return $shell_parent;
}
# utilities for get_shell_source 
# arg: 1 - parent id
sub get_start_parent {
	my ($parent) = @_;
	my @data = grabber("ps -j -fp $parent");
	my $script_parent = awk(\@data,"$parent",3,'\s+');
	return $script_parent;
}
# arg: 1 - parent id
sub get_shell_parent {
	my ($parent) = @_;
	my @data = grabber("ps -j -p $parent");
	my $shell_parent = awk(\@data, "$parent",-1,'\s+',);
	return $shell_parent;
}

sub get_tty_console_irc {
	eval $start if $b_log;
	return $tty_session if $tty_session;
	my $ppid = getppid();
	$tty_session = awk(\@ps_aux,".*$ppid.*$client{'name'}",7,'\s+');
	$tty_session =~ s/^[^[0-9]+// if $tty_session;
	$tty_session = '' if ! defined $tty_session;
	log_data("conole-irc-tty:$tty_session") if $b_log;
	eval $end if $b_log;
	return $tty_session;
}
sub get_tty_number {
	eval $start if $b_log;
	my $tty = POSIX::ttyname(1);
	#variants: /dev/pts/1 /dev/tty1 /dev/pts/5 /dev/ttyp2 /dev/pts/1
	$tty =~ s/.*\/[^0-9]*//g if defined $tty;
	$tty = '' if ! defined $tty;
	log_data("tty:$tty") if $b_log;
	eval $end if $b_log;
	return $tty;
}
# 2:58PM  up 437 days,  8:18, 3 users, load averages: 2.03, 1.72, 1.77
sub get_uptime {
	eval $start if $b_log;
	my $uptime = '';
	if (check_program('uptime')){
		$uptime = qx(uptime);
		$uptime = trimmer($uptime);
		$uptime = (split /,\s+/, $uptime)[0];
		my @temp = split /\s+/, $uptime;
		# units only start with days, not hours
		$uptime = ($temp[3]) ? $temp[2] . ' ' . $temp[3] : $temp[2];
	}
	$uptime ||= 'N/A';
	eval $end if $b_log;
	return $uptime;
}

#### -------------------------------------------------------------------
#### INITIALIZE DATA VALUES
#### -------------------------------------------------------------------

sub set_dmesg_boot_data {
	eval $start if $b_log;
	if (my $file = system_files('dmesg-boot') ){
		return if ! -r $file;
		@dmesg_boot = reader($file);
		# replace all indented items with ~ so we can id them easily while
		# processing note that if user, may get error of read permissions
		# for some weird reason, real mem and avail mem are use a '=' separator, 
		# who knows why, the others are ':'
		@dmesg_boot = map {
		$_ =~ s/\s*=\s*|:\s*/:/;
		$_ =~ s/\"//g;
		$_ =~ s/^\s+/~/;
		$_ =~ s/\s\s/ /g;
		$_;
		} @dmesg_boot;
	}
	log_data(@dmesg_boot) if $b_log;
	eval $end if $b_log;
}
# note, all actual tests have already been run in check_tools so if we
# got here, we're good. 
sub set_dmi_data {
	eval $start if $b_log;
	if ($alerts{'dmidecode'}{'action'} eq 'use' ){
		set_dmidecode_data();
	}
	eval $end if $b_log;
}

sub set_dmidecode_data {
	eval $start if $b_log;
	my (@data,@working,$type,$handle);
	#my $file = "$ENV{'HOME'}/bin/scripts/inxi/data/dmidecode/pci-freebsd-8.2-2";
	#open my $fh, '<', $file or die "can't open $file: $!";
	#chomp(@data = <$fh>);
	my $content = qx(dmidecode 2>/dev/null);
	@data = split /\n/, $content;
	# we don't need the opener lines of dmidecode output
	# but we do want to preserve the indentation. Empty lines
	# won't matter, they will be skipped, so no need to handle them.
	# some dmidecodes do not use empty line separators
	splice @data, 0, 5 if @data;
	my $j = 0;
	my $b_skip = 1;
	foreach (@data){
		if (!/^Hand/){
			next if $b_skip;
			if (/^[^\s]/){
				$_ = lc($_);
				$_ =~ s/\s(information)//;
				push @working, $_;
			}
			elsif (/^\t/){
				$_ =~ s/^\t\t/~/;
				$_ =~ s/^\t|\s+$//g;
				push @working, $_;
			}
		}
		elsif (/^Handle\s(0x[0-9A-Fa-f]+).*DMI\stype\s([0-9]+),.*/){
			$j = scalar @dmi;
			$handle = hex($1);
			$type = $2;
			$b_skip = ( $type > 126 )? 1 : 0;
			next if $b_skip;
			# we don't need 32, system boot, or 127, end of table
			if (@working){
				if ($working[0] != 32 && $working[0] < 127){
					$dmi[$j] = (
					[@working],
					);
				}
			}
			@working = ($type,$handle);
		}
	}
	if (@working && $working[0] != 32 && $working[0] != 127){
		$j = scalar @dmi;
		$dmi[$j] = (
		[@working],
		);
	}
	# last by not least, sort it by dmi type, now we don't have to worry
	# about random dmi type ordering in the data, which happens. Also sort 
	# by handle, as secondary sort.
	@dmi = sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @dmi;
	print Dumper \@dmi if $test[2];
	eval $end if $b_log;
}

sub set_ip_data {
	eval $start if $b_log;
	if ($alerts{'ip'}{'action'} eq 'use' ){
		set_ip_addr();
	}
	elsif ($alerts{'ifconfig'}{'action'} eq 'use'){
		set_ifconfig();
	}
	eval $end if $b_log;
}
sub set_ip_addr {
	eval $start if $b_log;
	my $program = check_program('ip');
	my @data = grabber("$program addr 2>/dev/null",'\n','strip');
	#my @data = reader("$ENV{'HOME'}/bin/scripts/inxi/data/if/scope-ipaddr-1.txt",'strip') or die $!;
	my ($b_skip,$broadcast,$if,$ip,@ips,$scope,$if_id,$type,@temp,@temp2);
	foreach (@data){
		if (/^[0-9]/){
			#print "$_\n";
			if (@ips){
			#print "$if\n";
				@temp = ($if,[@ips]);
				@ifs = (@ifs,@temp);
				@ips = ();
			}
			@temp = split /:\s+/,$_;
			$if = $temp[1];
			if ($if eq 'lo'){
				$b_skip = 1;
				$if = '';
				next;
			}
			$b_skip = 0;
			@temp = ();
		}
		elsif (!$b_skip && /^inet/){
			#print "$_\n";
			@temp = split /\s+/, $_;
			($broadcast,$ip,$scope,$if_id,$type) = ('','','','','');
			$ip = $temp[1];
			$type = ($temp[0] eq 'inet') ? 4 : 6 ;
			if ($temp[2] eq 'brd'){
				$broadcast = $temp[3];
			}
			if (/scope\s([^\s]+)(\s(.+))?/){
				$scope = $1;
				$if_id = $3;
			}
			@temp = ($type,$ip,$broadcast,$scope,$if_id);
			@ips = (@ips,[@temp]);
			#print Dumper \@ips;
		}
	}
	#print Dumper \@ips if $test[4];
	if (@ips){
		@temp = ($if,[@ips]);
		@ifs = (@ifs,@temp);
	}
	print Dumper \@ifs if $test[3];
	eval $end if $b_log;
}
sub set_ifconfig {
	eval $start if $b_log;
	my $program = check_program('ifconfig'); # not in user path, sbin
	my @data = grabber("$program 2>/dev/null",'\n','');
	#my @data = reader("$ENV{'HOME'}/bin/scripts/inxi/data/if/vps-ifconfig-1.txt",'') or die $!;
	my ($b_skip,$broadcast,$if,@ips_bsd,$ip,@ips,$scope,$if_id,$type,@temp,@temp2);
	my ($state,$speed,$duplex,$mac);
	foreach (@data){
		if (/^[\S]/i){
			#print "$_\n";
			if (@ips){
			#print "here\n";
				@temp = ($if,[@ips]);
				@ifs = (@ifs,@temp);
				@ips = ();
			}
			if ($mac){
				@temp = ($if,[($state,$speed,$duplex,$mac)]);
				@ifs_bsd = (@ifs_bsd,@temp);
				($state,$speed,$duplex,$mac,$if_id) = ('','','','','');
			}
			$if = (split /\s+/,$_)[0];
			$if =~ s/:$//; # em0: flags=8843
			$if_id = $if;
			$if = (split /:/, $if)[0] if $if;
			if ($if =~ /^lo/){
				$b_skip = 1;
				$if = '';
				$if_id = '';
				next;
			}
			$b_skip = 0;
		}
		elsif (!$b_skip && $bsd_type && /^\s+(ether|media|status)/){
			$_ =~ s/^\s+//;
			# media: Ethernet 100baseTX <full-duplex> freebsd 7.3 
			# media: Ethernet autoselect (1000baseT <full-duplex>) Freebsd 8.2
			# 
			if (/^media/){
				$_ =~ /<([^>]+)>/;
				$duplex = $1;
				$_ =~ /[\s\(]([1-9][\S]+\s)/;
				$speed = $1;
				$speed =~ s/\s+$// if $speed;
			}
			elsif (/^ether/){
				$mac = (split /\s+/, $_)[1];
			}
			elsif (/^status/){
				$state = (split /\s+/, $_)[1];
			}
		}
		elsif (!$b_skip && /^\s+inet/){
			#print "$_\n";
			$_ =~ s/^\s+//;
			$_ =~ s/addr:\s/addr:/;
			@temp = split /\s+/, $_;
			($broadcast,$ip,$scope,$type) = ('','','','');
			$ip = $temp[1];
			# fe80::225:90ff:fe13:77ce%em0
# 			$ip =~ s/^addr:|%([\S]+)//;
			if ($1 && $1 ne $if_id){
				$if_id = $1;
			}
			$type = ($temp[0] eq 'inet') ? 4 : 6 ;
			if (/(Bcast:|broadcast\s)([\S]+)/){
				$broadcast = $2;
			}
			if (/(scopeid\s[^<]+<|Scope:|scopeid\s)([^>]+)[>]?/){
				$scope = $2;
			}
			$scope = 'link' if $ip =~ /^fe80/;
			@temp = ($type,$ip,$broadcast,$scope,$if_id);
			@ips = (@ips,[@temp]);
			#print Dumper \@ips;
		}
	}
	if (@ips){
		@temp = ($if,[@ips]);
		@ifs = (@ifs,@temp);
	}
	if ($mac){
		@temp = ($if,[($state,$speed,$duplex,$mac)]);
		@ifs_bsd = (@ifs_bsd,@temp);
		($state,$speed,$duplex,$mac) = ('','','','');
	}
	print Dumper \@ifs if $test[3];
	print Dumper \@ifs_bsd if $test[3];
	eval $end if $b_log;
}

sub set_pci_data {
	eval $start if $b_log;
	if ( $b_pci ){
		if (!$bsd_type){
			if ($alerts{'lspci'}{'action'} eq 'use' ){
				set_lspci_data();
			}
		}
		else {
			#if (1 == 1){
			if ($alerts{'pciconf'}{'action'} eq 'use'){
				set_pciconf_data();
			}
		}
	}
	eval $end if $b_log;
}
# 0 type
# 1 type_id
# 2 bus_id
# 3 sub_id
# 4 device
# 5 vendor_id
# 6 chip_id
# 7 rev
# 8 port
# 9 driver
# 10 modules
# 11 driver_nu [bsd, like: em0 - driver em; nu 0. Used to match IF in -n
sub set_lspci_data {
	eval $start if $b_log;
	my ($busid,$busid_nu,$port,$driver,$modules,$device,$vendor_id,$chip_id,$rev,
	$type,$type_id,@temp);
	# my @pcis = grabber('lspci -nnv','\n','strip');
	my @pcis = split /\n/, qx(lspci -nnv);
	#print scalar @pcis;
	@pcis = map {$_ =~ s/^\s+//; $_} @pcis;
	foreach (@pcis){
		#print "$_\n";
		if ($device){
			if ($_ =~ /^\s*$/) {
				@temp = ($type,$type_id,$busid,$busid_nu,$device,$vendor_id,$chip_id,
				$rev,$port,$driver,$modules);
				@pci = (@pci,[@temp]);
				$device = '';
				#print "$busid $device_id r:$rev p: $port\n$type\n$device\n";
			}
			elsif ($_ =~ /^I\/O\sports/){
				$port = (split /\s+/,$_)[3];
				#print "p:$port\n";
			}
			elsif ($_ =~ /^Kernel\sdriver\sin\suse/){
				$driver = (split /:\s*/,$_)[1];
			}
			elsif ($_ =~ /^Kernel\smodules/i){
				$modules = (split /:\s*/,$_)[1];
			}
			
		}
		elsif ($_ =~ /^([0-9a-f]{2}:[0-9a-f]{2})[.:]([0-9a-f]+)\s(.*)\s\[([0-9a-f]{4}):([0-9a-f]{4})\](\s\(rev\s([^\)]+)\))?/){
			$busid = $1;
			$busid_nu = hex($2);
			my @working = split /:\s+/, $3;
			$device = $working[1];
			$type = $working[0];
			$vendor_id = $4;
			$chip_id = $5;
			$rev = ($7)?$7 : '';
			$device = cleaner($device);
			$working[0] =~ /\[([^\]]+)\]$/;
			$type_id = $1;
			$type = lc($type);
			$type = pci_cleaner($type);
			$type =~ s/\s+$//;
			$port = '';
			$driver = '';
			$modules = '';
		}
	}
	if ($device && $busid){
		@temp = ($type,$type_id,$busid,$busid_nu,$device,$vendor_id,$chip_id,$rev,$port,$driver,$modules);
		@pci = (@pci,[@temp]);
		$device = '';
	}
	print Dumper \@pci if $test[4];
	eval $end if $b_log;
}
# em0@pci0:6:0:0:	class=0x020000 card=0x10d315d9 chip=0x10d38086 rev=0x00 hdr=0x00
#     vendor     = 'Intel Corporation'
#     device     = 'Intel 82574L Gigabit Ethernet Controller (82574L)'
#     class      = network
#     subclass   = ethernet
sub set_pciconf_data {
	eval $start if $b_log;
	my ($busid,$busid_nu,$port,$driver,$driver_nu,$modules,$device,$vendor,$vendor_id,$chip_id,$rev,
	$type,$type_id,@data,@temp,@working);
# 	my $file = "$ENV{'HOME'}/bin/scripts/inxi/data/pciconf/pci-freebsd-8.2-2";
# 	open my $fh, '<', $file or die "can't open $file: $!";
# 	chomp(@data = <$fh>);
	my $content = qx(pciconf -lv 2>/dev/null);
	@data = split /\n/, $content;
	foreach (@data){
		if ($_ =~ /^[^@]+\@pci/){
			push @working, '';
		}
		$_ =~ s/^\s+//;
		push @working, $_;
	}
	foreach (@working){
		if ($driver){
			if ($_ =~ /^\s*$/) {
				$vendor = cleaner($vendor);
				$device = cleaner($device);
				if ($vendor && $device){
					if ($vendor !~ /$device/i){
						$device = "$vendor $device";
					}
				}
				elsif (!$device){
					$device = $vendor;
				}
				@temp = ($type,$type_id,$busid,$busid_nu,$device,$vendor_id,$chip_id,
				$rev,$port,$driver,$modules,$driver_nu);
				@pci = (@pci,[@temp]);
				$driver = '';
				#print "$busid $device_id r:$rev p: $port\n$type\n$device\n";
			}
			elsif ($_ =~ /^vendor/){
				$vendor = (split /\s+=\s+/,$_)[1];
				#print "p:$port\n";
			}
			elsif ($_ =~ /^device/){
				$device = (split /\s+=\s+/,$_)[1];
			}
			elsif ($_ =~ /^class/i){
				$type = (split /\s+=\s+/,$_)[1];
			}
			
		}
		elsif (/^([^@]+)\@pci([0-9]{1,3}:[0-9]{1,3}:[0-9]{1,3}):([0-9]{1,3}).*class=([^\s]+)\scard=([^\s]+)\schip=([^\s]+)\srev=([^\s]+)/){
			$driver = $1;
			$busid = $2;
			$busid_nu = $3;
			$type_id = $4;
			#$vendor_id = $5;
			$vendor_id = substr($6,6,4);
			$chip_id = substr($6,2,4);
			$rev = $7;
			$vendor = '';
			$device = '';
			$type = '';
			$driver =~ /(^[a-z]+)([0-9]+$)/;
			$driver = $1;
			$driver_nu = $2;
		}
	}
	if ($driver && $busid){
		$vendor = cleaner($vendor);
		$device = cleaner($device);
		$device = ( $vendor && $device !~ /$vendor/) ? "$vendor $device" : $device;
		@temp = ($type,$type_id,$busid,$busid_nu,$device,$vendor_id,$chip_id,$rev,$port,$driver,$modules,$driver_nu);
		@pci = (@pci,[@temp]);
		$device = '';
	}
	print Dumper \@pci if $test[4];
	eval $end if $b_log;
}
sub set_ps_aux {
	eval $start if $b_log;
	@ps_aux = split "\n",qx(ps aux);;
	shift @ps_aux; # get rid of header row
	$_=lc for @ps_aux; # this is a super fast way to set to lower
	# this is for testing for the presence of the command
	@ps_cmd = map {
		my @split = split /\s+/, $_;
		# slice out 10th to last elements of ps aux rows
		my $final = $#split;
		# some stuff has a lot of data, chrome for example
		$final = ($final > 12) ? 12 : $final;
		@split = @split[10 .. $final ];
		join " ", @split;
	} @ps_aux;
	print Dumper \@pci if $test[5];
	eval $end if $b_log;
}

sub set_sysctl_data {
	eval $start if $b_log;
	return if $alerts{'sysctl'}{'action'} ne 'use';
	# darwin sysctl has BOTH = and : separators, and repeats data. Why? 
	my $program = check_program('sysctl');
	my @temp = grabber("$program -a 2>/dev/null");
	foreach (@temp){
		$_ =~ s/\s*=\s*|:\s+/:/;
		$_ =~ s/\"//g;
		push @sysctl, $_;
		# we're building these here so we can use these arrays to test 
		# in each feature if we will try to build the feature for bsds
		if (/^hw\.sensors/ && !/^hw\.sensors\.acpibat/ && !/^hw.sensors.softraid/){
			push @sysctl_sensors, $_;
		}
		elsif (/^hw\.(vendor|product|version|serialno|uuid)/){
			push @sysctl_machine, $_;
		}
		elsif (/^hw\.sensors\.acpibat/){
			push @sysctl_battery, $_;
		}
	}
	print Dumper \@sysctl if $test[7];
	eval $end if $b_log;
}
sub set_usb_data {
	eval $start if $b_log;
	if ($alerts{'lsusb'}{'action'} eq 'use' ){
		#$usb_level = 2;
		if ($usb_level == 2){
			set_lsusb_data_long();
		}
		else {
			set_lsusb_data_short();
		}
	}
	elsif ( $alerts{'usbdevs'}{'action'} eq 'use'){
		set_usbdevs_data();
	}
	eval $end if $b_log;
}

sub set_lsusb_data_short {
	eval $start if $b_log;
	my (@data);
	my $b_live = 1;
	if ($b_live){
		my $content = qx(lsusb 2>/dev/null);
		@data = split /\n/, $content;
	}
	else {
		open my $fh, '<', "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/mdmarmer-lsusb.txt" or die $!;
		chomp(@data = <$fh>);
	}
	foreach (@data){
		my @working = split /\s+/, $_;
		$working[3] =~ s/:$//;
		my $id = int($working[3]);
		if ($id > 1){
			my $bus = int($working[1]);
			my $chip = $working[5];
			my @temp = @working[6..$#working];
			my $name = join ' ', @temp;
			if ($name !~ /hub/i){
				@usb = (@usb,[$bus,$id,$chip,$name]);
			}
		}
	}
	print Dumper \@usb if $test[6];
	eval $end if $b_log;
}
sub set_lsusb_data_long {
	eval $start if $b_log;
	my (@data,@working,$bus_id,$device_id,$id,$b_skip);
	my $j = 0;
	my $b_live = 1;
	if ($b_live){
		my $content = qx(lsusb -v 2>/dev/null);
		@data = split /\n/, $content;
	}
	else {
		open my $fh, '<', "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/mdmarmer-lsusb-v.txt" or die $!;
		chomp(@data = <$fh>);
	}
	foreach (@data){
		# we won't need all the lsusb data, so set it to skip
		# after the last item we might want
		if (!$b_skip && $bus_id && /^\s\s/){
			next if /^\s*$/; # expensive second call: || /UNAVAIL/
			if ($_ =~ /^\s+([\S]+)\sDescriptor:/){
				$_ = "Descriptor_$1";
			}
			else {
				$_ =~ s/^\s\s//;
				$_ =~ s/^[\s]+/~/g;
				$_ =~ s/[\s]+$//g;
				$_ =~ s/\sType/_Type/g;
				$_ =~ s/^([\S]+)[\s]+(.*)//;
				$_ = "$1:$2";
				$b_skip = 1 if $1 eq '~bInterfaceProtocol';
				#$_ = cleaner($_);
				if (/([\S]+):([0-9]+|0x[0-9a-f]+)\s(.*)/){
					$_ = "$1:$2:$3";
					$b_skip = 1 if $1 eq '~bInterfaceProtocol';
				}
				#print "$1\n";
			}
			push @working, $_;
		}
		elsif (/^Bus\s([0-9]+)\sDevice\s([0-9]+):\sID\s(([0-9a-f]{4}):([0-9a-f]{4})).*/){
			$j = scalar @usb;
			$bus_id = int($1);
			$device_id = int($2);
			$id = $3;
			$b_skip = 0;
			# we don't need 32, system boot, or 127, end of table
			if (@working){
				if ($working[0] != 32 && $working[0] != 127){
					$usb[$j] = (
					[@working],
					);
				}
			}
			@working = ($bus_id,$device_id,$id);
		}
	}
	if (@working){
		$j = scalar @usb;
		$usb[$j] = (
		[@working],
		);
	}
	# last by not least, sort it by dmi type, now we don't have to worry
	# about random dmi type ordering in the data, which happens
	@usb = sort { $a->[0] <=> $b->[0] || $a->[1] <=> $b->[1] } @usb;
	print Dumper \@usb if $test[6];
	eval $end if $b_log;
}
# Controller /dev/usb2:
# addr 1: full speed, self powered, config 1, UHCI root hub(0x0000), Intel(0x8086), rev 1.00
#  port 1 addr 2: full speed, power 98 mA, config 1, USB Receiver(0xc52b), Logitech(0x046d), rev 12.01
#  port 2 powered
sub set_usbdevs_data {
	eval $start if $b_log;
	my (@data,@working,$class,$bus_id,$addr_id,$id,$speed,$protocol);
	my $b_live = 1;
	my $j = 0;
	my $ports = 0;
	if ($b_live){
		my $program = check_program('usbdevs');
		my $content = qx($program -v 2>/dev/null);
		@data = split /\n/, $content;
	}
	else {
		open my $fh, '<', "$ENV{'HOME'}/bin/scripts/inxi/data/lsusb/bsd-usbdevs-v-1.txt" or die $!;
		chomp(@data = <$fh>);
	}
	foreach (@data){
		if (/^Controller\s\/dev\/usb([0-9]+)/){
			$j = scalar @usb;
			$ports = 0;
			$bus_id = $1;
			@working = ();
		}
		elsif (/^addr\s([0-9]+):\s([^,]+),[^,]+,[^,]+,\s?([^,]+)\(0x([0-9a-f]{4})\),\s?([^,]+)\s?\(0x([0-9a-f]{4})\)/){
			$j = scalar @usb;
			$addr_id = $1;
			$speed = "bcdUSB:$2";
			$id = "$4:$6";
			$protocol="~bInterfaceProtocol:0:$5 $3";
			#print "p1:$protocol\n";
			$class='bDeviceClass:9:Hub';
			@working = ($bus_id,$addr_id,$id,$speed,$class,$protocol);
			if (@working){
				$usb[$j] = (
				[@working],
				);
			}
			@working = ();
		}
		elsif (/^\s+port\s([0-9]+)\saddr\s([0-9]+):\s([^,]+),[^,]+,[^,]+,\s?([^,]+)\(0x([0-9a-f]{4})\),\s?([^,]+)\s?\(0x([0-9a-f]{4})\)/){
			$j = scalar @usb;
			$addr_id = "$2";
			$speed = "bcdUSB:$3";
			$id = "$5:$7";
			$protocol="~bInterfaceProtocol:0:$6 $4";
			#print "p2:$protocol\n";
			$ports++;
			@working = ($bus_id,$addr_id,$id,$speed,$protocol);
			if (@working){
				$usb[$j] = (
				[@working],
				);
			}
			@working = ();
		}
		elsif (/^\s+port\s([0-9]+)\spowered/){
			$ports++;
		}
	}
	if (@working){
		$j = scalar @usb;
		$usb[$j] = (
		[@working],
		);
	}
	print Dumper \@usb if $test[6];
	eval $end if $b_log;
}

########################################################################
#### GENERATE LINES
########################################################################

#### -------------------------------------------------------------------
#### LINE CONTROLLERS
#### -------------------------------------------------------------------

sub assign_data {
	my (%row) = @_;
	return if ! %row;
	if ($output_type eq 'screen'){
		print_data(%row);
	}
	else {
		%rows = (%rows,%row);
	}
}

sub generate_lines {
	eval $start if $b_log;
	my (%row,$b_pci_check,$b_dmesg_boot_check,$b_dmi_check);
	set_ps_aux() if ! @ps_aux;
	set_sysctl_data() if $b_sysctl;
# 	if ($test[3]){
# 		%row = generate_test_data();
# 		assign_data(%row);
# 		return 1;
# 	}
	if ( $show{'short'} ){
		%row = generate_short_data();
		assign_data(%row);
	}
	else {
		if ( $show{'system'} ){
			%row = generate_system_data();
			assign_data(%row);
		}
		if ( $show{'machine'} ){
			if ($b_dmi && !$b_dmi_check ){
				set_dmi_data() ; 
				$b_dmi_check = 1;
			}
			if ($bsd_type && $b_dmesg_boot_check){
				set_dmesg_boot_data();
				$b_dmesg_boot_check = 1;
			}
			%row = line_handler('Machine','machine');
			assign_data(%row);
		}
		if ( $show{'battery'} ){
			set_dmi_data() if $b_dmi && !$b_dmi_check; 
			$b_dmi_check = 1;
			%row = line_handler('Battery','battery');
			if (%row || $show{'battery-forced'}){
				assign_data(%row);
			}
		}
		if ( $show{'ram'} ){
			set_dmi_data() if $b_dmi && !$b_dmi_check; 
			$b_dmi_check = 1;
			%row = line_handler('Memory','ram');
			assign_data(%row);
		}
		if ( $show{'slot'} ){
			set_dmi_data() if $b_dmi && !$b_dmi_check; 
			$b_dmi_check = 1;
			%row = line_handler('PCI Slots','slot');
			assign_data(%row);
		}
		if ( $show{'cpu'} || $show{'cpu-basic'} ){
			if ($bsd_type && $b_dmesg_boot_check){
				set_dmesg_boot_data();
				$b_dmesg_boot_check = 1;
			}
			my $arg = ($show{'cpu-basic'}) ? 'basic' : 'full' ;
			%row = line_handler('CPU','cpu',$arg);
			assign_data(%row);
		}
		if ( $show{'graphic'} ){
			set_pci_data() if !$b_pci_check; 
			$b_pci_check = 1;
			%row = line_handler('Graphics','graphic');
			assign_data(%row);
		}
		if ( $show{'audio'} ){
			set_pci_data() if !$b_pci_check; 
			$b_pci_check = 1;
			%row = line_handler('Audio','audio');
			assign_data(%row);
		}
		if ( $show{'network'} ){
			set_usb_data() if !$b_usb_check;
			set_pci_data() if !$b_pci_check; 
			set_ip_data() if ($show{'ip'} || ($bsd_type && $show{'network-advanced'}));
			$b_pci_check = 1;
			$b_usb_check = 1;
			%row = line_handler('Network','network');
			assign_data(%row);
		}
		if ( $show{'disk'} || $show{'disk-basic'} || $show{'disk-total'} || $show{'optical'} ){
			if ($bsd_type && $b_dmesg_boot_check){
				set_dmesg_boot_data();
				$b_dmesg_boot_check = 1;
			}
			%row = line_handler('Drives','disk');
			assign_data(%row);
		}
		if ( $show{'partition'} ){
			%row = line_handler('Partition','partition');
			assign_data(%row);
		}
		if ( $show{'raid'} ){
			%row = line_handler('RAID','raid');
			assign_data(%row);
		}
		if ( $show{'unmounted'} ){
			%row = line_handler('Unmounted','unmounted');
			assign_data(%row);
		}
		if ( $show{'usb'} ){
			set_usb_data() if !$b_usb_check;
			%row = line_handler('USB Info','usb');
			assign_data(%row);
			$b_usb_check = 1;
		}
		if ( $show{'sensor'} ){
			%row = line_handler('Sensors','sensor');
			assign_data(%row);
		}
		if ( $show{'repo'} ){
			%row = line_handler('Repos','repo');
			assign_data(%row);
		}
		if ( $show{'process'} ){
			%row = line_handler('Processes','process');
			assign_data(%row);
		}
		if ( $show{'weather'} ){
			%row = line_handler('Weather','weather');
			assign_data(%row);
		}
		if ( $show{'info'} ){
			%row = generate_info_data();
			assign_data(%row);
		}
	}
	if ( $output_type ne 'screen' ){
		output_handler(%rows);
	}
	eval $end if $b_log;
}
sub line_handler {
	my ($key,$sub,$arg) = @_;
	my %subs = (
	'audio' => \&AudioData::get,
	'battery' => \&BatteryData::get,
	'cpu' => \&CpuData::get,
	'disk' => \&DiskData::get,
	'graphic' => \&GraphicData::get,
	'machine' => \&MachineData::get,
	'network' => \&NetworkData::get,
	'partition' => \&PartitionData::get,
	'raid' => \&RaidData::get,
	'ram' => \&RamData::get,
	'repo' => \&RepoData::get,
	'process' => \&ProcessData::get,
	'sensor' => \&SensorData::get,
	'slot' => \&SlotData::get,
	'unmounted' => \&UnmountedData::get,
	'usb' => \&UsbData::get,
	'weather' => \&WeatherData::get,
	);
	my (%data);
	my $data_name = $prefix++ . "#$key";
	my @rows = $subs{$sub}->($arg);
	if (@rows){
		%data = ($data_name => \@rows,);
	}
	eval $end if $b_log;
	return %data;
}

#### -------------------------------------------------------------------
#### SHORT, DEBUG
#### -------------------------------------------------------------------

sub generate_short_data {
	eval $start if $b_log;
	my $num = 0;
	my $kernel_os = ($bsd_type) ? 'OS' : 'Kernel';
	my $client = $client{'name-print'};
	my $client_shell = ($b_irc) ? 'Client' : 'Shell';
	if ($client{'version'}){
		$client .= ' ' . $client{'version'};
	}
	my ($cpu_string,$speed,$speed_key,$type) = ('','','speed','');
	my $memory = get_memory_data();
 	my @cpu = CpuData::get('short');
 	if (scalar @cpu > 1){
		$type = ($cpu[2]) ? " (-$cpu[2]-)" : '';
		($speed,$speed_key) = ('','');
		if ($cpu[6]){
			$speed_key = "$cpu[3]/$cpu[5]";
			$cpu[4] =~ s/ MHz//;
			$speed = "$cpu[4]/$cpu[6]";
		}
		else {
			$speed_key = $cpu[3];
			$speed = $cpu[4];
		}
		$cpu_string = $cpu[0] . ' ' . $cpu[1] . $type;
	}
	elsif ($bsd_type) {
		if ($alerts{'sysctl'}{'action'}){
			if ($alerts{'sysctl'}{'action'} ne 'use'){
				$cpu_string = "sysctl $alerts{'sysctl'}{'action'}";
				$speed = "sysctl $alerts{'sysctl'}{'action'}";
			}
			else {
				$cpu_string = 'bsd support coming';
				$speed = 'bsd support coming';
			}
		}
	}
 	#print join '; ', @cpu, " sleep: $cpu_sleep\n";
	$memory ||= 'N/A';
	my @data = ({
		$num++ . "#CPU" => $cpu_string,
		$num++ . "#$speed_key" => $speed,
		$num++ . "#$kernel_os" => &get_kernel_data(),
		$num++ . "#Up" => &get_uptime(),
		$num++ . "#Mem" => $memory,
		$num++ . "#HD" => 'N/A',
		# could make -1 for ps aux itself, -2 for ps aux and self
		$num++ . "#Procs" => scalar @ps_aux,
		$num++ . "#$client_shell" => $client,
		$num++ . "#$self_name" => &get_self_version(),
	},);
	my %row = (
	$prefix . '#SHORT' => [(@data),],
	);

	eval $end if $b_log;
	return %row;
}

sub generate_test_data {
	eval $start if $b_log;
	my %data = (
	$prefix++ . '#System' => [
		{
		'1#Host' => 'fred',
		'02#Kernel' => '4.9.0-3.1-liquorix-686-pae i686',
		'3#bits' => '32',
		'4#gcc' => '6.2.1',
		},
		{
		'5#Desktop' => 'Xfce 4.12.3 (Gtk 2.24.31)',
		'6#info' => 'xfce4-panel',
		'7#dm' => 'lightdm',
		'08#Distro' => 'sidux-20070102-d:1',
		},
		
	],
	$prefix++ . '#CPU' => [
		{
		"0#CPU flags" => '3dnow 3dnowext 3dnowprefetch apic clflush cmov 
		cmp_legacy cr8_legacy cx16 cx8 de eagerfpu extapic extd_apicid fpu
		fxsr fxsr_opt ht lahf_lm lbrv lm mca mce mmx mmxext msr mtrr nx pae
		pat pge pni pse pse36 rdtscp rep_good sep sse sse2 svm syscall tsc
		vme vmmcall',
		},
	],
	$prefix++ . '#Network' => [
		{
		'0#Card' => 'Realtek RTL8101/2/6E PCI Express Fast/Gigabit Ethernet controller',
		'1#driver' => 'r8169',
		'2#v' => '2.3LK-NAPI',
		'3#port' => '2000',
		'4#bus-ID' => '02:00.0',
		'5#chip-ID' => '10ec:8136 fred bob george same gus byron henry george gus fred sandy jeff',
		},
		{
		'0#IF' => 'enp2s0',
		'1#state' => 'up',
		'2#speed' => '100 Mbps',
		'3#duplex' => 'full',
		'4#mac' => '00:23:8b:cd:27:82',
		},
		{
		'0#Card' => 'Realtek RTL8187B Wireless 802.11g 54Mbps Network Adapter',
		'1#usb-ID' => '001-003',
		'2#chip-ID' => '0bda:8189',
		},
		{
		'1#IF' => 'null-if-id',
		'2#state' => 'N/A',
		'3#mac' => 'N/A',
		},
	],
	$prefix++ . '#Repos' => [
		{
		'0#Active apt sources in file' => '/etc/apt/sources.list',
		},
		[
		'deb http: //mirrors.kernel.org/debian unstable main contrib non-free',
		'deb http: //mirrors.kernel.org/debian buster main contrib non-free',
		'deb http: //www.deb-multimedia.org/ buster main non-free',
		'deb http: //deb.opera.com/opera-stable stable non-free',
		'deb http: //liquorix.net/debian unstable main',
		],
		{
		'0#Active apt sources in file' => '/etc/apt/sources.list.d/google-earth.list',
		},
		[
		'deb http: //dl.google.com/linux/earth/deb/ stable main',
		],
	],
	);
	eval $end if $b_log;
	return %data;
}

#### -------------------------------------------------------------------
#### CONSTRUCTED LINES
#### -------------------------------------------------------------------

sub generate_info_data {
	eval $start if $b_log;
	my $num = 0;
	my $gcc_alt = '';
	my $running_in = '';
	my $data_name = $prefix++ . '#Info';
	my ($b_gcc,%row,$gcc,$index,$ref,$val1);
	my $client_shell = ($b_irc) ? 'Client' : 'Shell';
	my $client = $client{'name-print'};
	my @gccs = get_gcc_data();
	if (@gccs){
		$gcc = shift @gccs;
		if ($extra > 1 && @gccs){
			$gcc_alt = join '/', @gccs;
		}
		$b_gcc = 1;
	}
	$gcc ||= 'N/A';
	if ($client{'version'}){
		$client .= ' ' . $client{'version'};
	}
	if (!$b_irc && $extra > 1 ){
		if ($b_display){
			$val1 = get_shell_source();
		}
		else {
			$val1 = get_tty_number();
			$val1 = "tty $val1" if $val1 ne '';
		}
		if ($val1 eq 'login'){
			$val1 = undef;
		}
		# can be tty 0 so test for defined
		$running_in = $val1 if defined $val1;
	}
	my $memory = get_memory_data();
	$memory ||= 'N/A';
	
	my %data = (
	$data_name => [
		{
		$num++ . '#Processes' => scalar @ps_aux, 
		$num++ . '#Uptime' => &get_uptime(),
		$num++ . '#Memory' => $memory,
		},
	],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	if ( !$show{'display-data'} || $extra > 0 ){
		my %init = get_init_data();
		my $init_type = ($init{'init-type'}) ? $init{'init-type'}: 'N/A';
		$data{$data_name}[$index]{$num++ . '#Init'} = $init_type;
		if ($extra > 1 ){
			my $init_version = ($init{'init-version'}) ? $init{'init-version'}: 'N/A';
			$data{$data_name}[$index]{$num++ . '#v'} = $init_version;
		}
		if ($init{'runlevel'}){
			$data{$data_name}[$index]{$num++ . '#runlevel'} = $init{'runlevel'};
		}
		if ($extra > 1 ){
			if ($init{'default'}){
				my $default = ($init{'init-type'} eq 'systemd' && $init{'default'} =~ /[^0-9]$/ ) ? 'target' : 'default';
				$data{$data_name}[$index]{$num++ . "#$default"} = $init{'default'};
			}
		}
	}
	if ($extra > 0 ){
		my $b_clang;
		my $clang_version = '';
		if (my $path = check_program('clang')){
			$clang_version = program_version($path,'clang',3,'--version');
			$clang_version ||= 'N/A';
			$b_clang = 1;
		}
		my $compiler = ($b_gcc || $b_clang) ? '': 'N/A';
		$data{$data_name}[$index]{$num++ . '#Compilers'} = $compiler;
		if ($b_gcc){
			$data{$data_name}[$index]{$num++ . '#gcc'} = $gcc;
			if ( $extra > 1 && $gcc_alt){
				$data{$data_name}[$index]{$num++ . '#alt'} = $gcc_alt;
			}
		}
		if ($b_clang){
			$data{$data_name}[$index]{$num++ . '#clang'} = $clang_version;
		}
	}
	$data{$data_name}[$index]{$num++ . '#' . $client_shell} =  $client;
	if ( $running_in ){
		$data{$data_name}[$index]{$num++ . '#running in'} = $running_in;
	}
	$data{$data_name}[$index]{$num++ . '#' . $self_name} = &get_self_version();
	
	eval $end if $b_log;
	return %data;
}

sub generate_system_data {
	eval $start if $b_log;
	my $num = 0;
	my (%row,$ref,$index,$val1);
	my $data_name = $prefix++ . '#System';
	my ($desktop,$desktop_info,$desktop_key) = ('','','Desktop');
	my (@desktop_data,$desktop_version);
	
	my %data = (
	$data_name => [{}],
	);
	$index = scalar(@{ $data{$data_name} } ) - 1;
	if ($show{'host'}){
		$data{$data_name}[$index]{$num++ . '#Host'} = &get_hostname();
	}
	$data{$data_name}[$index]{$num++ . '#Kernel'} = &get_kernel_data();
	$data{$data_name}[$index]{$num++ . '#bits'} = &get_kernel_bits;
	if ($extra > 0){
		my @compiler = get_compiler_version(); # get compiler data
		if (scalar @compiler != 2){
			@compiler = ('N/A', '');
		}
		
		$data{$data_name}[$index]{$num++ . "#compiler"} = $compiler[0];
		# if no compiler, obviously no version, so don't waste space showing.
		if ($compiler[0] ne 'N/A'){
			$compiler[1] ||= 'N/A';
			$data{$data_name}[$index]{$num++ . "#v"} = $compiler[1];
		}
	}
	# note: tty can have the value of 0 but the two tools 
	# return '' if undefined, so we test for explicit ''
	
	if ($b_display){
		my @desktop_data = DesktopEnvironment::get();
		$desktop = $desktop_data[0] if $desktop_data[0];
		$desktop_version = $desktop_data[1] if $desktop_data[1];
		$desktop .= ' ' . $desktop_version if $desktop_version;
		if ($extra > 0 && $desktop_data[3]){
			$desktop .= ' (' . $desktop_data[2];
			$desktop .= ( $desktop_data[3] ) ? ' ' . $desktop_data[3] . ')' : ')';
		}
		if ($extra > 2 && $desktop_data[4]){
			$desktop_info = $desktop_data[4];
		}
	}
	if (!$b_display || ( ! $desktop && $b_root)) {
		my $tty = get_tty_number();
		if (!$desktop){
			$desktop_info = '';
		}
		# it is defined, as ''
		if ( $tty eq '' && $client{'console-irc'}){
			$tty = get_tty_console_irc();
		}
		$desktop = "tty $tty" if $tty ne '';
		$desktop_key = 'Console';
	}
	$desktop ||= 'N/A';
	$data{$data_name}[$index]{$num++ . "#$desktop_key"} = $desktop;
	if ($extra > 2){
		if ($desktop_info){
			$data{$data_name}[$index]{$num++ . '#info'} = $desktop_info;
		}
	}
	if ($extra > 1){
		my $dms = get_display_manager();
		$dms ||= 'N/A';
		$data{$data_name}[$index]{$num++ . '#dm'} = $dms;
	}
	my $distro_key = ($bsd_type) ? 'OS': 'Distro' ;
	my $distro = DistroData::get();
	$distro ||= 'N/A';
	$data{$data_name}[$index]{$num++ . "#$distro_key"} = $distro;
	
	eval $end if $b_log;
	return %data;
}

#######################################################################
#### LAUNCH
########################################################################

main(); ## From the End comes the Beginning

## note: this EOF is needed for smxi handling, this is what triggers the full download ok
###**EOF**###
